{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/utils/helpers.js","webpack:///./src/utils/exports.js","webpack:///./src/Stateless.js","webpack:///./src/utils/propTypes.js","webpack:///./src/Component.js","webpack:///./src/renderers/Template.js","webpack:///./src/utils/definition.js","webpack:///./src/mixins/Store.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","addClassNames","customElement","shadowRoot","querySelectorAll","forEach","el","classList","add","localName","prepareTemplate","template","document","querySelector","ShadyCSS","whenComponentsAreDefined","root","undefinedComponents","promises","Array","slice","map","component","customElements","whenDefined","Promise","all","e","resolve","requestAnimationFrame","sym","description","String","undefined","noise","split","replace","Math","random","toString","microtaskDebounce","fn","isQueued","createElement","MutationObserver","observe","childList","textContent","warn","message","console","bubble","context","detail","config","event","CustomEvent","bubbles","composed","dispatchEvent","dashToCamel","input","match","substr","toUpperCase","camelToDash","toLowerCase","compatUpdated","shadyPrepared","obj","window","innerHTML","styleElement","_shadyPrepared","nativeShadow","eventHandlers","entries","addEventListener","removeEventListener","getDefaultLocale","EUI","Localizer","defaultLocale","prop","options","target","descriptor","writable","initializer","constructor","_propDefs","registerMixin","superMixins","mixins","from","includes","push","hasMixin","Base","_mixins","indexOf","mixinName","helpers","super","this","_lifecycleDebounced","_executeLifecycle","connectedCallback","intercepts","disconnectedCallback","compatElementUpdated","executeRender","didUpgrade","customName","is","define","error","safeParse","JSON","parse","typeMapping","type","coerce","serialize","deserialize","Boolean","Number","isNaN","stringify","isArray","getLocalePath","locale","home","localePath","async","fetchLocale","_fetch","_getWindow","localeFile","localeStrings","json","initI18n","i18n","Proxy","_string","loc","_defaultLocale","localesCache","getString","Map","components","componentClass","_prevProps","_connected","_justConnected","_findProps","_setAttributes","didDisconnect","keys","reduce","memo","_observedAttributes","filter","attribute","propDef","defaultValue","default","attributes","required","valueSymbol","existingValue","set","v","_syncPropertyToAttribute","didConnect","didChangeProps","changedProps","shouldRender","some","willRender","didRender","propMap","startsWith","has","updateLocale","size","locales","_locale","fetchLocales","localeData","data","triggerComponentUpdate","attributeChangedCallback","oldValue","newValue","propName","_syncAttributeToProperty","prevWasUndefined","prev","_setDiff","props","_shouldRenderLocale","previous","current","changes","_syncingAttributeToProperty","_syncingPropertyToAttribute","attributeName","removeAttribute","setAttribute","Shady","attachShadow","_template","styleText","div","clone","content","cloneNode","style","appendChild","createTextNode","prepend","getTemplateElement","_initialized","then","id","selector","currentScript","ownerDocument","_currentScript","trigger","eventName","find","many","getElementById","APPEND","PREPEND","definition","templatePosition","_event","configKeysPath","$components","callback","setHome","targetStyle","optionStyle","setStyles","targetTemplate","optionTemplate","pos","setTemplates","StoreMixin","_stateChanged","getState","provider","store","dispatch","action","payload","storeDisconnect","properties","disconnect","storeConnect","connect","addActions","actionName","func","listen","removeActions","unlisten","state","Stateless","StatelessComponentMixin","HTMLElement","Component","StatefulComponentMixin","TemplateComponent","Template"],"mappings":"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","file":"Main.debug.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/* global requestAnimationFrame, MutationObserver, ShadyCSS */\n/* eslint arrow-body-style:0 */\n\n// export const registerMixin = (superMixins, name) => {\n//   const mixins = superMixins ? Array.from(superMixins) : [];\n//   if (!mixins.includes(name)) {\n//       mixins.push(name);\n//   }\n//   return mixins;\n// };\n//\n// export const hasMixin = (Base, name) => {\n//   return Base._mixins !== undefined && Base._mixins.indexOf(name) > -1;\n// };\n\nconst whenComponentsAreDefined = (root) => {\n  try {\n    const undefinedComponents = root.querySelectorAll(':not(:defined)');\n    const promises = Array.prototype.slice.call(undefinedComponents)\n      .map((component) => customElements.whenDefined(component.localName));\n    return Promise.all(promises);\n  } catch (e) {\n    // this fails in firefox because the selector is not valid,\n    // so just wait a frame and all components are more likely\n    // to be updated at that point.\n    return new Promise(((resolve) => {\n      requestAnimationFrame(resolve);\n    }));\n  }\n};\n\n/**\n * @description Polyfill for Symbol - returns a random string if not supported\n */\nconst sym = (description) => {\n  if (typeof Symbol === 'function') {\n    return Symbol(description ? String(description) : undefined);\n  }\n  // Symbol not supported, make a random string\n  const noise = 'xxxxxx'\n    .split('')\n    /* eslint no-bitwise:0 */\n    .replace(/./g, () => (Math.random() * 16 | 0).toString(16));\n  return `${description ? String(description) : ''}-${noise}`;\n};\n\n/**\n * @description Debounce a 0-arg function into the microtask queue using a MutationObserver.\n * This ensures that the update will be processed on the tail-end of this task,\n * before the next tick / browser repaint.\n * More info on this approach:\n * https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n *\n * @param {Function} fn\n * @return {Function}\n */\nconst microtaskDebounce = (fn) => {\n  let isQueued = false;\n  const el = document.createElement('i');\n  new MutationObserver(() => {\n    fn();\n    isQueued = false;\n  }).observe(el, { childList: true });\n  let i = 0;\n  return () => {\n    if (!isQueued) {\n      isQueued = true;\n      el.textContent = `${i}`;\n      i += 1;\n    }\n  };\n};\n\n/**\n * @description Warn the developer about improper library usage.\n * @todo: Make only active in dev mode (no-op in production)\n */\nconst warn = (message) => { console.warn(message); };\n\n// COMPAT\n/**\n * Manually add the correct scoped classnames, if ShadyCSS doesn't\n * seem to be doing its job.\n */\nconst addClassNames = (customElement) => {\n  customElement.shadowRoot.querySelectorAll('*').forEach((el) => {\n    el.classList.add(customElement.localName);\n    el.classList.add('style-scope');\n  });\n};\n\n/**\n * ShadyCSS prepareTemplate, but check it's not doubling up\n */\nconst prepareTemplate = (template, name) => {\n  if (document.querySelector(`head > style[scope=${name}]`) == null) {\n    ShadyCSS.prepareTemplate(template, name);\n  }\n};\n\n// DOM EVENTS\nconst bubble = (context, name, detail = {}, config = {}) => {\n  const event = new CustomEvent(name, {\n    bubbles: true,\n    composed: true,\n    ...config,\n    detail,\n  });\n  context.dispatchEvent(event);\n  return event;\n};\n\n// PROPS\n/**\n * Transform dash-case (HTML) into camelCase (JS)\n * @param {string} input\n * @returns {string}\n */\nconst dashToCamel = (input) => {\n  /* eslint no-useless-escape:0 */\n  return input.replace(/\\-./g, (match) => match.substr(1).toUpperCase());\n};\n\n/**\n * Transform camelCase (JS) into dash-case (HTML)\n *\n * @param {string} input\n * @returns {string}\n */\nconst camelToDash = (input) => {\n  return input.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);\n};\n\nconst compatUpdated = (shadyPrepared, obj) => {\n  if (window.ShadyCSS) {\n    // Things which only need to happen on the first render\n    if (!shadyPrepared) {\n      const template = document.createElement('template');\n      template.innerHTML = obj.shadowRoot.innerHTML;\n      prepareTemplate(template, obj.localName);\n      ShadyCSS.styleElement(obj);\n      obj._shadyPrepared = true;\n    }\n    // Things which need to happen on prop update\n    // ShadyCSS.styleSubtree(this);\n    if (!ShadyCSS.nativeShadow) {\n      obj.shadowRoot.querySelectorAll('style').forEach((el) => {\n        el.textContent = '';\n      });\n      addClassNames(obj);\n    }\n  }\n};\n\nconst eventHandlers = (obj, add = true) => {\n  if (obj) {\n    if (add) {\n      Object.entries(obj).forEach(([key, value]) => {\n        this.addEventListener(key, value);\n      });\n      return;\n    }\n    Object.entries(obj).forEach(([key, value]) => {\n      this.removeEventListener(key, value);\n    });\n  }\n};\n\n/**\n * @description Gets the default locale\n * @function getDefaultLocale\n * @returns string or null\n */\nfunction getDefaultLocale() {\n  try {\n    return window.EUI.Localizer.defaultLocale;\n  } catch (e) {\n    console.warn('Helpers: Error fetching default locale, error: %o', e);\n    return null;\n  }\n}\n\nexport default {\n  whenComponentsAreDefined,\n  sym,\n  microtaskDebounce,\n  warn,\n  addClassNames,\n  prepareTemplate,\n  bubble,\n  dashToCamel,\n  camelToDash,\n  compatUpdated,\n  eventHandlers,\n  getDefaultLocale,\n};\n","/**\n * A decorator used to decorate props in a component.\n * use like...\n *\n * @prop({\n *   attribute: [true|false],\n *   type: ['string'|'number'|'boolean'|'array'|'object'],\n *   default: value, required: [true|false]})\n * propA;\n *\n * @param {Object} options - define the prop.\n * @deprecated\n */\nexport function prop(options = {}) {\n  return (target, name, descriptor) => {\n    // Some stuff which is needed to stop babel decorators-legacy from\n    // overwriting the property descriptor with a `value` type.\n    // See: https://stackoverflow.com/questions/39267780/how-to-disable-defining-class-properties-in-babel-transform-decorators-legacy\n    delete descriptor.writable;\n    descriptor.get = () => {};\n    delete descriptor.initializer;\n    target.constructor._propDefs = {\n      ...target.constructor._propDefs,\n      [name]: options,\n    };\n  };\n}\n\n/**\n * @function registerMixin\n *\n * @param {*} superMixins\n * @param { String } name - name of mixin\n * @returns { Array } mixins\n */\nexport const registerMixin = (superMixins, name) => {\n  const mixins = superMixins ? Array.from(superMixins) : [];\n  if (!mixins.includes(name)) {\n    mixins.push(name);\n  }\n  return mixins;\n};\n\n/**\n * @function hasMixin\n *\n * @param { Object } Base - the mixin\n * @param { String } name - name of the mixin\n * @returns { Boolean }\n */\n// eslint-disable-next-line max-len\nexport const hasMixin = (Base, name) => Base._mixins !== undefined && Base._mixins.indexOf(name) > -1;\n","import helpers from './utils/helpers';\nimport { registerMixin, hasMixin } from './utils/exports';\n\nexport default (Base) => {\n  const mixinName = 'StatelessComponentMixin';\n  const {\n    eventHandlers,\n    compatUpdated,\n    bubble,\n    microtaskDebounce,\n  } = helpers;\n\n  if (hasMixin(Base, mixinName)) {\n    console.warn(`Tried to add existing mixin ${mixinName}`);\n    return Base;\n  }\n  return class Stateless extends Base {\n    static get _mixins() {\n      return registerMixin(super._mixins, mixinName);\n    }\n\n    constructor() {\n      super();\n      this._shadyPrepared = false;\n      this._lifecycleDebounced = microtaskDebounce(this._executeLifecycle.bind(this));\n    }\n\n    connectedCallback() {\n      this._executeLifecycle();\n      eventHandlers(this.intercepts);\n    }\n\n    disconnectedCallback() { eventHandlers(this.intercepts, false); }\n\n    compatElementUpdated() { compatUpdated(this._shadyPrepared, this); }\n\n    bubble(name, detail = {}, config = {}) { return bubble(this, name, detail, config); }\n\n    _executeLifecycle() { this.executeRender(); }\n\n    executeRender() { }\n\n    /**\n     * Lifecycle hook\n     * Implement this hook in your component if you are interested\n     * to know when the component is upgraded.\n     * Renderers should call this only once when the shadowRoot is\n     * attached and the template is added.\n     *\n     * Executes only once in the component lifecycle.\n     * Initial render has taken place and changes flushed to the DOM.\n     * All props are accessible and the shadowRoot is available.\n     * This hook gives the ability to check the presence of slotted children.\n     *\n     * If the component listens for slotchange events on a slot, then this\n     * is the place to get their initial state. In Safari browser the\n     * component is mutated before the shadowRoot is added which means\n     * the slotchange won't fire on first render.\n     *\n     *\n     * @function didUpgrade\n     */\n    didUpgrade() {}\n\n    /**\n     * Define the component as a Custom Element. The optional customName MUST be a valid\n     * custom element and contain at least one dash (-).\n     *\n     * @function register\n     * @param { String } customName - name of the component\n     */\n    static register(customName) {\n      if (customName) {\n        this.is = customName;\n      }\n      if (!customElements.get(this.is)) {\n        try {\n          customElements.define(this.is, this);\n        } catch (error) {\n          console.error(`Failed to register component. \"${this.is}\" is not a valid component name. Valid component names must include at least one dash (-)`);\n        }\n      }\n    }\n  };\n};\n","export const safeParse = (value) => {\n  try {\n    return JSON.parse(value);\n  } catch (e) {\n    if (e.name === 'SyntaxError') {\n      console.warn(`Invalid JSON: '${value}'`);\n    }\n    return null;\n  }\n};\n\nexport const typeMapping = (type) => {\n  switch (type) {\n    case String:\n      return {\n        coerce: (value) => (value == null ? null : String(value)),\n        serialize: (value) => (value == null ? null : String(value)),\n        deserialize: (value) => value,\n      };\n\n    case Boolean:\n      return {\n        coerce: (value) => Boolean(value),\n        serialize: (value) => (value ? '' : null),\n        deserialize: (value) => value != null,\n      };\n\n    case Number:\n      return {\n        /* eslint no-restricted-globals:0 */\n        coerce: (value) => ((value == null || isNaN(value))\n          ? null\n          : Number(value)),\n        serialize: (value) => (value == null ? null : String(value)),\n        deserialize: (value) => (value == null ? null : Number(value)),\n      };\n\n    case Object:\n      return {\n        coerce: (value) => ((value == null || typeof value !== 'object')\n          ? null\n          : value),\n        serialize: (value) => (value == null ? null : JSON.stringify(value)),\n        deserialize: (value) => (value == null ? null : safeParse(value)),\n      };\n\n    case Array:\n      return {\n        coerce: (value) => (Array.isArray(value) ? value : null),\n        serialize: (value) => (value == null ? null : JSON.stringify(value)),\n        deserialize: (value) => (value == null ? null : safeParse(value)),\n      };\n\n    default:\n      return {\n        coerce: (value) => value,\n        serialize: (value) => value,\n        deserialize: (value) => value,\n      };\n  }\n};\n","import { registerMixin, hasMixin } from './utils/exports';\nimport helpers from './utils/helpers';\nimport { typeMapping } from './utils/propTypes';\n\n/**\n * @description Returns the locale path\n * @param {Object} context\n * @param {String} locale\n * @returns {String} locale path\n */\nfunction getLocalePath(context, locale) {\n  const { home } = context;\n  if (!home || !locale) { return null; }\n\n  let localePath = `locale/${locale}.json`;\n  if (home !== '/') {\n    localePath = `${home}/locale/${locale}.json`;\n  }\n\n  return localePath;\n}\n\n/**\n * @description Fetches the locale\n * @param {Object} context\n * @param {String} locale\n */\nasync function fetchLocale(context, locale) {\n  const localePath = getLocalePath(context, locale);\n  if (!localePath) { return null; }\n\n  try {\n    const _fetch = context._getWindow('fetch');\n    const localeFile = await _fetch(localePath);\n    const localeStrings = await localeFile.json();\n    return { locale, localeStrings };\n  } catch (e) {\n    console.warn('Localizer: %o', e);\n    return null;\n  }\n}\n\n/**\n *\n * @param {Object} context\n * @param {Array} locales\n * @returns {Array} List of locales\n */\nasync function fetchLocales(context, locales) {\n  return Promise.all(locales.map((_locale) => fetchLocale(context, _locale)));\n}\n\nexport default (Base) => {\n  // Define the mixin name, this is required to determine if the mixin has\n  // Already been applied\n  const mixinName = 'StatefulComponent';\n  // Determine if there is an attempt to re initialize the mixin\n  if (hasMixin(Base, mixinName)) {\n    console.warn(`Tried to add existing mixin ${mixinName}`);\n    return Base;\n  }\n\n  // Fetch the requested string\n  function getString(obj, prop) {\n    let _string = obj.loc[prop];\n    if (!_string) {\n      const _defaultLocale = helpers.getDefaultLocale();\n      const _localesCache = obj.localesCache.get(_defaultLocale)\n        || obj.localesCache.get('en-us');\n      _string = _localesCache[prop];\n\n      if (!_string) {\n        _string = obj.localesCache.get('en-us')[prop];\n      }\n    }\n    return _string;\n  }\n\n  // Initialize i18n support for component\n  function initI18n(context) {\n    if (!context) {\n      console.warn('Component: Invalid Context provided');\n      return;\n    }\n\n    if (!context.home) {\n      return;\n    }\n\n    context.i18n = new Proxy(context, {\n      get(obj, prop) {\n        return getString(obj, prop);\n      },\n    });\n\n    context.loc = {};\n    context.localesCache = new Map();\n  }\n\n  return class StatefulComponent extends Base {\n    static get _mixins() {\n      return registerMixin(super._mixins, mixinName);\n    }\n\n    /**\n     * Define the components as Custom Elements.\n     *\n     * @function registerComponents\n     * @param { Array } components - array of components\n     */\n    static registerComponents(components) {\n      if (!components) {\n        console.warn('No component provided to register');\n        return;\n      }\n      if (!Array.isArray(components)) {\n        console.warn('incorrect type provided');\n        return;\n      }\n      components.forEach((component) => {\n        const { is } = component;\n        let { componentClass } = component;\n        if (typeof component === 'object' && (!is || !componentClass)) {\n          console.warn('Object:component not defined properly');\n          return;\n        }\n\n        if (!componentClass) {\n          // if component class is not specified explicity, its same as component.\n          componentClass = component;\n        }\n        if (!customElements.get(is)) {\n          customElements.define(is, componentClass);\n        }\n      });\n    }\n\n    /**\n     * Define the component as a Custom Element. The optional customName MUST be a valid\n     * custom element and contain at least one dash (-).\n     *\n     * @function register\n     * @param { String } customName - name of the component\n     */\n    static register(customName) {\n      if (customName) {\n        this.is = customName;\n      }\n      if (!customElements.get(this.is)) {\n        customElements.define(this.is, this);\n      }\n    }\n\n    /**\n     * @protected\n     * @function constructor\n     * @description Parse the custom element attributes as props\n     */\n    constructor() {\n      super();\n      // COMPAT\n      this._shadyPrepared = false;\n\n      // PROPS\n      this._prevProps = undefined;\n      this._connected = false;\n      this._justConnected = false;\n      // Debounce prop updates leading to lifecycle callbacks, so that\n      // setting multiple props in sequence (e.g. via a declarative\n      // renderer calling setAttribute many times) just triggers one big\n      // update, not several partial ones.\n      this._lifecycleDebounced = helpers.microtaskDebounce(this._executeLifecycle.bind(this));\n      // Find any props initialize for the component\n      if (this.constructor._propDefs) {\n        this._findProps();\n      }\n    }\n\n    /**\n     * @protected\n     * @function connectedCallback\n     * @description The Default connected callback\n     */\n    connectedCallback() {\n      // DOM EVENTS\n      helpers.eventHandlers(this.intercepts);\n      this._setAttributes();\n      this._connected = true;\n      this._justConnected = true;\n      this._lifecycleDebounced();\n    }\n\n    /**\n     * @protected\n     * @function disconnectedCallback\n     * @description The Default disconnected callback\n     */\n    disconnectedCallback() {\n      // DOM EVENTS\n      helpers.eventHandlers(this.intercepts, false);\n      this.didDisconnect();\n\n      this._connected = false;\n    }\n\n    // COMPAT\n    /**\n     * @description Call this from your renderer once you've rendered to the DOM\n     */\n    compatElementUpdated() {\n      helpers.compatUpdated(this._shadyPrepared, this);\n    }\n\n    // DOM EVENTS\n    bubble(name, detail = {}, config = {}) { return helpers.bubble(this, name, detail, config); }\n\n    /**\n     * @description Get object with current values of all props in this INSTANCE.\n     */\n    get props() {\n      if (this.constructor._propDefs) {\n        // Loop through the component's CONSTRUCTOR props definition\n        return Object.keys(this.constructor._propDefs).reduce((memo, key) => {\n          memo[key] = this[key];\n          return memo;\n        }, {});\n      }\n      return {};\n    }\n\n    /**\n     * @description Let the browser know which attributes to observe.\n     * Part of the Custom Elements v1 spec, the browser will observe all\n     * the attributes listed here, triggering attributeChangedCallback any\n     * time they are set\n     * @return {string[]}\n     */\n    static get observedAttributes() {\n      initI18n(this);\n\n      if (this._propDefs !== undefined) {\n        this._observedAttributes = Object.entries(this._propDefs)\n          // eslint-disable-next-line no-unused-vars\n          .filter(([key, value]) => value.attribute === true)\n          // eslint-disable-next-line no-unused-vars\n          .map(([key, value]) => helpers.camelToDash(key));\n      }\n      return this._observedAttributes;\n    }\n\n    /**\n     * Loop over each prop defined by the user and set the values for props.\n     *\n     * @function _setAttributes\n     * @private\n     */\n    _setAttributes() {\n      if (this.constructor._propDefs) {\n        Object.entries(this.constructor._propDefs).forEach(([key, propDef]) => {\n          const defaultValue = propDef.default;\n\n          // Attributes can't be set in the constructor, and must be\n          // deferred to the connectedCallback, as per the spec.\n          if (this[key] === undefined\n            && this.attributes[helpers.camelToDash(key)] === undefined\n            && !propDef.required) {\n            switch (propDef.type) {\n              case Object:\n                this[key] = defaultValue !== undefined ? { ...defaultValue } : null;\n                break;\n\n              case Array:\n                this[key] = defaultValue !== undefined ? [...defaultValue] : null;\n                break;\n\n              default:\n                this[key] = defaultValue !== undefined ? defaultValue : null;\n            }\n          }\n        });\n      }\n    }\n\n    /**\n     * @private\n     * @description Find an props for the component\n     */\n    _findProps() {\n      // Loop over each prop defined by the user\n      Object.entries(this.constructor._propDefs).forEach(([key, propDef]) => {\n        // Use a Symbol to avoid cluttering object namespace\n        const valueSymbol = helpers.sym(key);\n        const { coerce, serialize } = typeMapping(propDef.type);\n        const defaultValue = propDef.default;\n        const existingValue = this[key];\n        // Warn against bad API usage\n        if (propDef.required && propDef.default !== undefined) {\n          helpers.warn(`[${this.constructor.is}] Required prop \"${key}\" should not also have a default set`);\n        }\n        // Apply custom getters/setters to the property\n        // TODO: Could move this to the prototype for efficiency\n        Object.defineProperty(this, key, {\n          // configurable: false,\n          enumerable: true,\n          get() {\n            return this[valueSymbol];\n          },\n          set(v) {\n            // Make sure the received value is of the expected type\n            let value = coerce(v);\n            if (value == null) {\n              // Was it required?  If so, this shouldn't be happening\n              if (propDef.required) {\n                helpers.warn(`[${this.constructor.is}] Required prop \"${key}\" should not be set to null/undefined`);\n              }\n              // Use the default value if one was provided\n              if (defaultValue !== undefined) {\n                value = defaultValue;\n              }\n            }\n            this[valueSymbol] = value;\n            if (propDef.attribute === true) {\n              this._syncPropertyToAttribute(key, value, serialize);\n            }\n\n            this._lifecycleDebounced();\n          },\n        });\n        if (existingValue != null) { this[key] = existingValue; }\n      });\n    }\n\n    /**\n     * LIFECYCLE HOOKS\n     * The component has been connected to the DOM (even with the polyfill,\n     * which happens asynchronously).\n     * Unlike in the constructor, all props are accessible, so this is a\n     * good place to set initial internal state values (or reset them, if\n     * this component could be connected multiple times).\n     * Also good time to create any subscribers (remember to destroy them\n     * later), or bubble any events.\n     *\n     * Call order:\n     * connectedCallback() -> didConnect() -> didChangeProps()\n     *\n     * @function didConnect\n     */\n    didConnect() {}\n\n    /**\n     * Lifecycle hook\n     * Option to set internal state based on newly received external props.\n     * Also a good place to do things like send off ajax requests in\n     * response to changing props.\n     * Make sure to compare prev/current values to be sure it's actually changed.\n     *\n     *\n     * @function didChangeProps\n     * @param {Map} changedProps - Keys are the names of changed properties;\n     * Values are the corresponding previous values.\n     */\n    // eslint-disable-next-line no-unused-vars\n    didChangeProps(changedProps) {}\n\n    // TODO: this function should be re-written so the user doesn't need\n    // to call super.shouldRender(prev); componentShouldRender is doing more\n    // than just providing a hook.\n    /**\n     * Lifecycle hook\n     * Determine whether the props have changed enough to need a re-render\n     * Defaults to using a shallow === check, so won't pick up deep changes\n     * in objects (for example).  Use the immutable pattern to avoid this.\n     * this.someProp = { ...this.someProp, foo: 'new' }\n     * You could also override this to perform a different checking logic\n     * in a component, if you need.\n     *\n     * @function shouldRender\n     * @param {Map} changedProps - Keys are the names of changed properties;\n     * Values are the corresponding previous values.\n     * @return {boolean} True to trigger a re-render\n     */\n    shouldRender(changedProps) {\n      const flag = [...changedProps].some(([key, value]) => value !== this[key]);\n      return flag;\n    }\n\n    /**\n     * Lifecycle hook\n     * Option to do any preparation needed for a render.\n     * Do not set internal state here.\n     *\n     *\n     * @function willRender\n     * @param {Map} changedProps - Keys are the names of changed properties;\n     * Values are the corresponding previous values.\n     */\n    // eslint-disable-next-line no-unused-vars\n    willRender(changedProps) {}\n\n    /**\n     * Lifecycle hook\n     * Renderers should hook into this.\n     *\n     *\n     * @function executeRender\n     */\n    executeRender() {}\n\n    /**\n     * Lifecycle hook\n     * Implement this hook in your component if you are interested\n     * to know when the component is upgraded.\n     * Renderers should call this only once when the shadowRoot is\n     * attached and the template is added.\n     *\n     * Executes only once in the component lifecycle.\n     * Initial render has taken place and changes flushed to the DOM.\n     * All props are accessible and the shadowRoot is available.\n     * This hook gives the ability to check the presence of slotted children.\n     *\n     * If the component listens for slotchange events on a slot, then this\n     * is the place to get their initial state. In Safari browser the\n     * component is mutated before the shadowRoot is added which means\n     * the slotchange won't fire on first render.\n     *\n     *\n     * @function didUpgrade\n     */\n    didUpgrade() {}\n\n    /**\n     * Lifecycle hook\n     * Rendering has taken place and changes flushed to the DOM, so an\n     * opportunity to carry out any imperative updates that may be needed.\n     * Frequently used to imperatively set props on slotted children.\n     * Do not set internal state here.\n     *\n     *\n     * @function didRender\n     * @param {Map} changedProps - Keys are the names of changed properties;\n     * Values are the corresponding previous values.\n     */\n    // eslint-disable-next-line no-unused-vars\n    didRender(changedProps) {}\n\n    /**\n     * Lifecycle hook\n     * Component is about to be disconnected from the DOM (but may be\n     * connected again later...).\n     * Good time to remove any subscribers.\n     *\n     *\n     * @function didDisconnect\n     */\n    didDisconnect() {}\n\n    /**\n     * Get the property definitions as defined for the component.\n     * @returns {Map}\n     */\n    get propDefinitions() {\n      const propMap = new Map();\n      Object.keys(this.constructor._propDefs)\n        .filter((key) => !key.startsWith('_'))\n        .forEach((key) => {\n          propMap.set(key, this.constructor._propDefs[key]);\n        });\n      return propMap;\n    }\n\n    /**\n     * This function is used to check if the locale prop was changed. If so then the new locale\n     * must be fetched.\n     *\n     * @function _shouldRenderLocale\n     * @param {Map} changedProps - Keys are the names of changed properties;\n     * Values are the corresponding previous values.\n     * @private\n     */\n    async _shouldRenderLocale(changedProps) {\n      if (changedProps.has('locale')) {\n        await this.constructor.updateLocale(this.locale);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @description returns the global window property\n     * @param {String} prop\n     */\n    static _getWindow(prop) {\n      return window[prop];\n    }\n\n    /**\n     * @description Updates the components' locale\n     * @param {string} locale\n     */\n    static async updateLocale(locale) {\n      if (!locale) { return; }\n\n      const localePath = getLocalePath(this, locale);\n      if (!localePath) { return; }\n\n      // init component's locale cache\n      if (this.localesCache.size < 1) {\n        const data = await fetchLocales(this, ['en-us', helpers.getDefaultLocale()]);\n        data.forEach((localeData) => {\n          if (!localeData) { return; }\n          this.localesCache.set(localeData.locale, localeData.localeStrings);\n        });\n      }\n\n      if (this.localesCache.has(locale)) {\n        this.loc = this.localesCache.get(locale);\n        return;\n      }\n\n      try {\n        const data = await fetchLocale(this, locale);\n        if (!data) { return; }\n        this.localesCache.set(data.locale, data.localeStrings);\n        this.loc = data.localeStrings;\n      } catch (e) {\n        console.warn('Component: Error loading locale: %o, error: %o', localePath, e);\n      }\n    }\n\n    /**\n     * @description Manually trigger lifecycle callbacks.  Would be used in conjunction\n     * with a custom arePropsChangedCallback.\n     */\n    triggerComponentUpdate() { this._lifecycleDebounced(); }\n\n    /**\n     * @description Called (as part of HTML spec) when attribute changes\n     * @param {string} name\n     * @param {string} oldValue\n     * @param {string} newValue\n     */\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (super.attributeChangedCallback) {\n        super.attributeChangedCallback(name, oldValue, newValue);\n      }\n      const propName = helpers.dashToCamel(name);\n      const propDef = this.constructor._propDefs[propName];\n      const { deserialize } = typeMapping(propDef.type);\n      if (propDef && propDef.attribute === true) {\n        this._syncAttributeToProperty(propName, newValue, deserialize);\n      }\n    }\n\n    /**\n     * @description Invoke the props changed/rendering lifecycle\n     */\n    async _executeLifecycle() {\n      // Skip lifecycle callbacks if component isn't connected. Don't\n      // want to try manipulating a DOM tree that doesn't exist.\n      if (!this._connected) {\n        return;\n      }\n\n      // Prev/next callbacks, passed on to lifecycle callbacks\n      const prevWasUndefined = this._prevProps === undefined;\n      const prev = prevWasUndefined ? {} : this._prevProps;\n\n      // Initial render only\n      if (this._justConnected) {\n        // Check for any missing required props\n        if (this.constructor._propDefs) {\n          Object.entries(this.constructor._propDefs).forEach(([key, propDef]) => {\n            if (propDef.required && this[key] == null) {\n              helpers.warn(`[${this.constructor.is}] Required prop \"${key}\" was not set`);\n            }\n          });\n        }\n        this.didConnect();\n\n        this._justConnected = false;\n      }\n\n      const changedProps = this._setDiff(prev, this.props);\n\n      // call didChangeProps when there is a change.\n      if (changedProps.size > 0) {\n        this.didChangeProps(changedProps);\n      }\n\n      // Set _prevProps ready for next update, after giving the user a\n      // chance to update internal state props in earlier lifecycle hooks\n      this._prevProps = this.props;\n\n      if (prevWasUndefined) {\n        await this.constructor.updateLocale(this.locale);\n      }\n\n      // Never let the user bypass the initial render.\n      if (prevWasUndefined || await this._shouldRenderLocale(changedProps)\n        || this.shouldRender(changedProps)) {\n        this.willRender(changedProps);\n\n        try {\n          this.executeRender();\n          this.didRender(changedProps);\n        } catch (error) {\n          console.error(`[${this.localName}] ${error}`);\n        }\n      }\n    }\n\n    /**\n     * Perform a comparison between previous prop values and current prop values\n     * to determine differences. Each different prop (key:value) is put into a Map.\n     * This Map is set as the changeProps map and used as input to all lifecycle callbacks.\n     *\n     * @function _setDiff\n     * @param {Object} previous - previous prop values\n     * @param {Object} current - current prop values\n     * @private\n     */\n    _setDiff(previous, current) {\n      const changes = new Map();\n      const keys = Object.keys(previous);\n      keys.forEach((key) => {\n        if (previous[key] !== current[key]) {\n          changes.set(key, previous[key]);\n        }\n      });\n      return changes;\n    }\n\n    /**\n     * Sync the HTML attribute value to the JS object property\n     *\n     * @param {string} name\n     * @param {string} value\n     */\n    _syncAttributeToProperty(name, v, deserialize) {\n      if (name in (this.constructor._propDefs)) {\n        this._syncingAttributeToProperty = true;\n        // Deserialize based on prop type\n        const value = deserialize(v);\n        this[name] = value;\n        this._syncingAttributeToProperty = false;\n      }\n    }\n\n    /**\n     * Sync a property value to an HTML attribute\n     * @param {string} name\n     * @param {*} value\n     */\n    _syncPropertyToAttribute(name, v, serialize) {\n      if (!this._syncingAttributeToProperty) {\n        this._syncingPropertyToAttribute = true;\n        // Serialize to string | null\n        const value = serialize(v);\n        const attributeName = helpers.camelToDash(name);\n        if (value == null) {\n          this.removeAttribute(attributeName);\n        } else {\n          this.setAttribute(attributeName, value);\n        }\n        this._syncingPropertyToAttribute = false;\n      }\n    }\n  };\n};\n","/* global ShadyCSS */\nimport { registerMixin, hasMixin } from '../utils/exports';\nimport helpers from '../utils/helpers';\n\nconst Shady = window.ShadyCSS !== undefined;\nconst { whenComponentsAreDefined } = helpers;\n/**\n * @description Adds a simple renderer using static template tags.\n * @TODO Fix ShadyCSS support\n */\nexport default (Base) => {\n  function getTemplateElement(template, styleText) {\n    if (template === undefined) {\n      template = '';\n    }\n\n    if (typeof template === 'string') {\n      const div = document.createElement('div');\n      div.innerHTML = `<template id=\"the-template\">${template}</template>`;\n      template = div.querySelector('template#the-template');\n    }\n    const clone = template.content.cloneNode(template, true);\n\n    if (typeof styleText === 'string') {\n      const style = document.createElement('style');\n      style.appendChild(document.createTextNode(styleText));\n      clone.prepend(style);\n    }\n    return clone;\n  }\n\n  const mixinName = 'Template';\n  if (hasMixin(Base, mixinName)) {\n    console.warn(`Tried to add existing mixin ${mixinName}`);\n    return Base;\n  }\n\n  return class Template extends Base {\n    static get _mixins() {\n      return registerMixin(super._mixins, mixinName);\n    }\n\n    constructor() {\n      super();\n      this.attachShadow({ mode: 'open' });\n      this._template = getTemplateElement(\n        this.constructor.template,\n        this.constructor.style,\n      );\n      this.root.appendChild(this._template);\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) {\n        super.connectedCallback();\n      }\n\n      if (!this._initialized) {\n        if (Shady) {\n          ShadyCSS.styleElement(this);\n        }\n        this._initialized = true;\n        // all the nested custom elements may not have been\n        // upgraded so we need to wait until they are.\n        // https://developers.google.com/web/fundamentals/architecture/building-components/customelements\n        // see the 'Element upgrades' section.\n        whenComponentsAreDefined(this.root).then(() => {\n          this.didUpgrade();\n        });\n      }\n    }\n\n    get root() {\n      return this.shadowRoot;\n    }\n\n    static getTemplate(id) {\n      const selector = (id) ? `#${id}` : 'template';\n      const template = document.currentScript.ownerDocument.querySelector(selector)\n        || document._currentScript.ownerDocument.querySelector(selector);\n\n      if (Shady && id) {\n        ShadyCSS.prepareTemplate(template, id);\n      }\n      return template;\n    }\n\n    trigger(eventName, options) {\n      this.dispatchEvent(new CustomEvent(eventName, {\n        detail: options || {},\n      }));\n    }\n\n    find(value, many) {\n      if (many) {\n        return this.root.querySelectorAll(value);\n      }\n      return this.root.getElementById(value);\n    }\n  };\n};\n","/**\n * This file provides the @definition decorator which is used to setup the\n * definition of a custom component.\n *\n * Usage example\n * import { definition, APPEND } from 'definition';\n *\n * ...\n *\n * @definition('e-my-component', {\n *   style: 'someStyle',\n *   template: 'someTemplate',\n *   templatePosition: APPEND,\n *   props: {\n *     propName: { attribute: true, type: Boolean }\n *   }\n * })\n * class MyComponent extends TemplateComponent {}\n */\n\n/**\n * APPEND - Append the template to the existing markup of the component being extended (if any)\n */\nexport const APPEND = 1;\n\n/**\n * PREPEND = Prepend the template to the existing markup of the component being extended (if any)\n */\nexport const PREPEND = 2;\n\n/**\n * Set the template of the component. Setting the optional position of\n * where extended markup will be placed.\n *\n * @function setTemplates\n * @param { Object } target - Component.\n * @param { String } targetTemplate - template form the base component.\n * @param { String } optionTemplate - template form the extended component.\n * @param { String } pos - [PREPEND|APPEND] position fo the extended template.\n */\nfunction setTemplates(target, targetTemplate = null, optionTemplate = null, pos = APPEND) {\n  if (!targetTemplate && !optionTemplate) {\n    target.template = targetTemplate;\n  } else if (targetTemplate && optionTemplate) {\n    if (pos === PREPEND) {\n      target.template = `${optionTemplate}${targetTemplate}`;\n    } else if (pos === APPEND) {\n      target.template = `${targetTemplate}${optionTemplate}`;\n    }\n  } else if (!targetTemplate && optionTemplate) {\n    target.template = optionTemplate;\n  }\n}\n\n/**\n * Set the style of the component\n *\n * @function setStyles\n * @param {*} target - Component.\n * @param {*} targetStyle - style from the base component.\n * @param {*} optionStyle - style from the extended component.\n */\nfunction setStyles(target, targetStyle = null, optionStyle = null) {\n  if (targetStyle && !optionStyle) {\n    target.style = targetStyle.toString();\n  } else if (targetStyle && optionStyle) {\n    target.style = `${targetStyle.toString()}${optionStyle.toString()}`;\n  } else if (!targetStyle && optionStyle) {\n    target.style = optionStyle.toString();\n  }\n}\n\n/**\n * Sets home of the component by dispatching 'GET_CONFIG' custom event\n * for getting the base path of the component.\n *\n * @function setHome\n * @param {Object} target - Component class\n * @param {Object} options - Component class properties\n * @fires document#GET_CONFIG\n */\nfunction setHome(target, options) {\n  const { home } = options;\n  target.home = home;\n\n  if (!home) {\n    return;\n  }\n\n  const configKeysPath = {\n    $components: 'component/componentsPath',\n  };\n\n  const callback = (data) => {\n    target.home = data.$components + home;\n  };\n\n  const _event = new CustomEvent('GET_CONFIG', {\n    detail: {\n      configKeysPath,\n      callback,\n    },\n  });\n\n  /**\n   * Get config event\n   * Container consumes this event if used inside it.\n   * @event document#GET_CONFIG\n   * @type {Object}\n   * @property {Object} detail.configKeysPath - path to default components directory\n   * @property {Function} detail.callback - callback function to trigger\n   */\n  document.dispatchEvent(_event);\n}\n\n/**\n * A decorator function which sets the decorated Class (target) as a custom component.\n * It allows the specification of the custom name (is),\n * the style and template (options).\n *\n * @function definition\n * @template {String} [K]\n * @param { string } is - custom name of the component.\n * @param { object } [options] - style, template, templatePosition and props of the component.\n * @param { string } [options.style] - CSS style for component\n * @param { string } [options.template] - template markup for component\n * @param { number } [options.templatePosition] - template position for the component,\n * this is used when extending existing Components.\n *\n * @param { Object.<string, {\n *  attribute?: boolean,\n *  type?: (boolean|string|object|Array<any>|number )\n *  default?: (boolean|string|object|Array<any>|number )\n *  required?: boolean\n * }> } [options.props] - the properties for the component\n * @param { object<T> } target - the Class\n */\nexport const definition = (is, options = {\n  style: null,\n  template: null,\n  templatePosition: null,\n  props: null,\n}) => (target) => {\n  target.is = is;\n  target.i18n = {};\n  setHome(target, options);\n  target._propDefs = { ...target._propDefs, ...options.props };\n  target._propDefs.locale = { attribute: false, type: String, default: '' };\n\n  setStyles(target, target.style, options.style);\n  setTemplates(target, target.template, options.template, options.templatePosition);\n};\n","import { prop, registerMixin, hasMixin } from '../utils/exports.js';\n\nexport const StoreMixin = (Base) => {\n  const mixinName = 'StoreMixin';\n  if (hasMixin(Base, mixinName)) {\n    console.warn(`Tried to add existing mixin ${mixinName}`);\n    return Base;\n  }\n\n  return class Store extends Base {\n    static get _mixins() {\n      return registerMixin(super._mixins, mixinName);\n    }\n\n    @prop({ attribute: false, type: Object, default: {} })\n    state;\n\n    constructor(options) {\n      super(options);\n      this._stateChanged = this._stateChanged.bind(this);\n    }\n\n    /**\n     * @protected\n     * @function getState\n     * @description Get a state value from the Store\n     */\n    getState(key) {\n      if (this.provider !== undefined && this.provider.store !== undefined) {\n        return this.provider.store.getState(key);\n      }\n      return null;\n    }\n\n    /**\n     * @protected\n     * @function dispatch\n     * @description Dispatch a state update action, this will be captured by the App Store\n     */\n    dispatch(action, payload) {\n      if (this.provider !== undefined && this.provider.store !== undefined) {\n        this.provider.store.dispatch(action, payload);\n      }\n    }\n\n    /**\n     * @protected\n     * @function disconnect\n     * @description Disconnect the app from the store\n     * @param {Array} properties - The properties in the store previously registered\n     */\n    storeDisconnect(properties) {\n      if (this.provider !== undefined && this.provider.store !== undefined) {\n        return this.provider.store.disconnect(this, properties);\n      }\n      return null;\n    }\n\n    /**\n     * @protected\n     * @function connect\n     * @description Connect to the store and received update notifications for\n     * various state values\n     * @param {Array} properties - The properties in the store to request notification changes on\n     */\n    storeConnect(properties) {\n      if (this.provider !== undefined && this.provider.store !== undefined) {\n        return this.provider.store.connect(this, properties);\n      }\n      return null;\n    }\n\n    /**\n     * @protected\n     * @function addActions\n     * @description Set up an action listener\n     * @param {String} actionName - The action name to listen to, or an array of actions\n     * @param {Function} func - The action function (for single action only)\n     */\n    addActions(actionName, func) {\n      if (this.provider !== undefined && this.provider.store !== undefined) {\n        if (typeof actionName === 'string') {\n          this.provider.store.listen(actionName, func);\n        } else {\n          actionName.forEach((obj) => {\n            this.provider.store.listen(obj.name, obj.action);\n          });\n        }\n      }\n    }\n\n    /**\n     * @protected\n     * @function removeActions\n     * @description Remove an action listener(s)\n     * @param {String} actionName - The action name to listen to, or an array of actions\n     * @param {Function} func - The action function (for single action only)\n     */\n    removeActions(actionName, func) {\n      if (this.provider !== undefined && this.provider.store !== undefined) {\n        if (typeof actionName === 'string') {\n          this.provider.store.unlisten(actionName, func);\n        } else {\n          actionName.forEach((obj) => {\n            this.provider.store.unlisten(obj.name, obj.action);\n          });\n        }\n      }\n    }\n\n    /**\n     * @private\n     * @function _stateChanged\n     * @description Function executed by the app store for state changes\n     * @param {Object} state - The state object with values for the execution\n     */\n    _stateChanged(state) {\n      const current = { ...this.state };\n      Object.keys(current).forEach((key) => {\n        if (state[key] !== undefined) {\n          current[key] = state[key];\n        }\n      });\n      this.state = current;\n    }\n  };\n};\n","import StatelessComponentMixin from './Stateless';\nimport StatefulComponentMixin from './Component';\nimport Template from './renderers/Template';\n\n/* eslint no-undef:0 */\nexport class Stateless extends StatelessComponentMixin(HTMLElement) {}\nexport class Component extends StatefulComponentMixin(HTMLElement) {}\nexport class TemplateComponent extends Template(StatefulComponentMixin(HTMLElement)) {}\n\nexport {\n prop, registerMixin, hasMixin,\n} from './utils/exports';\nexport { definition, APPEND, PREPEND } from './utils/definition';\nexport { StoreMixin as Store } from './mixins/Store';\n"],"sourceRoot":""}