# E-UI SDK Application core framework
This is currently a simple extension base class to support container connectivity and state management.

The App class is an extension of LitComponent, however a means will later be provided to allow it to simply extend Component if the LitHtml renderer is not required.

## Setup

### Install the dependencies

```bash
npm install
```

### Build the project (with source maps)

```bash
npm run build
```

### Linting the project
```bash
npm run lint
```

### Run tests in Headless Chrome and Firefox (with test coverage)

```bash
npm run test
```

### Run tests in the browser

```bash
npm run test:browser
```

### Run tests in the terminal (with test coverage)

```bash
npm run test:chrome
npm run test:firefox
```

### Run tests in dev mode (with source maps)

```bash
npm run test:chrome:dev
npm run test:firefox:dev
```

## App Methods
The key inbuilt methods that an App can access are:

```
this.getState(KEY);
// Returns the current value for a state property stored in the AppStore, this may be any value

this.dispatch(ACTION, PARAMS);
// Dispatches a state update request. If there are listeners configured to observe
// the state change request, then the state update responsibility is delegated
// to them so that they can perform additional functionality such as asyc requests
// prior to the store being updated.

// If there are no action listeners for the given action then the store will be
// updated with the values supplied.

this.plugin(NAME, METHOD, PARAMS);
// Locates a loaded plugin and executes a specific method passing params,
// see the container for more information related to plugins and plugin creation.

this.connect(PROPERTIES);
// Connects a app to the store to observe state changes on the specified
// properties, when a value is updated the app is notified. The state prop of
// the App will automatically be updated triggering a render(). This state prop
// can be captured in the Component Lifecycle methods. See the component package
// for more information in LifeCycle.

this.disconnect(PROPERTIES);
// Disconnects the app from the store registered properties, you may disconnect
// from all or some.

this.actionListeners(ACTIONNAME, FUNCTION);
// Adds action listening functions, these function can reside anywhere, as
// methods within a class or externally. The action listeners will be passed the
// state values if supplied, and the store so that state updates can be applied
// after they have performed their task.

this.removeListeners(ACTIONNAME, FUNCTION);
// Removes an action listener

this.api(PATH, { file:'json'}, OPTIONAL_CALLBACK );
// Loads a JSON file and returns a promise or executes an optional callback

this.api(PATH, { type:'GET'}, OPTIONAL_DATA_FORMATTER, OPTIONAL_CALLBACK );
// Executes a promise ajax request, the 2nd argument is the fetch options
// which can include a header object, mode='cors' or alternate value, and
// other fetch properties.

```

## App Props
The App Class requires that a "state" prop be created in the App, if the app
wishes to connect to the store, see example below.

## Example usage
```
import { App, html, Define, prop } from '@eui/app';
import style from './app1.css';

// Constant
const ACTION_LOGOUT = 'ACTION_LOGOUT';

// Action handler, this is a simple function and can reside independently
// or as a method within the App Class
const logoutAction = (payload, store) => {
  console.log('LOGOUT ACTION', payload, store);
}


@Define('eui-my-app')
export default class App1 extends App {
  // Special Case Prop specifically for connecting to the App Store, the
  // store notifies and updates the state when a component is connected
  // as an observer to the state change.

  // DEFAULT state listener values must be supplied
  @prop({ attribute: false, default: {
      isLoggedIn: false,
      "some-val1":null,
      "some-val2":null
    }
  })
  state;

  static get style() {
    return style;
  }

  /**
   * @public
   * @function constructor
   * @description Constructor for the component
   */
  constructor(options) {
    super(options);
    this.options = options;
    this.buttonClicked = this.buttonClicked.bind(this);
  }

  /**
   * @protected
   * @function componentDidConnect
   * @description Lifecycle callback, when the component connects get the initial MD
   */
  componentDidConnect() {
    // Connect this application to the appStore to observe for state
    // changes for a specified state property or list of properties
    this.state = this.connect(this.state);
    this.actionListeners(ACTION_LOGOUT, logoutAction);
  }

  /**
   * @private
   * @function buttonClicked
   * @description Handles the logged out button click event
   */
  buttonClicked(e) {
    // Execute a method on the authentication plugin to clear the user
    // session, however that may have been stored
    this.plugin('authentication', 'clearSession', { userId: 12345 });
    // Dispatch an action to the store to update the state and execute any
    // pre state change functionality
    this.dispatch(ACTION_LOGOUT, { isLoggedIn: false });
    // Set the window location to the login page
    window.location = 'login.html';
  }

  /**
   * @private
   * @function render
   * @description Render the component
   */
  render() {
    // Check the current state using the in built method
    let loggedInStatus = 'The user is NOT logged in';
    let button = null;
    // Check the state prop for the current logged in status
    // the state prop is updated when the AppStore receives state changes
    // for the isLoggedIn state value
    if(this.state.isLoggedIn){
      loggedInStatus = 'The user is logged in';
      button = html`<button style="background:none; border:none" onclick=${this.buttonClicked}>Logout</button>`;
    }
    return html`
      <div class="main-container">
        <h1>App-1 Sample Header</h1>
        <div class="logged-in-status">${loggedInStatus}</div>
        ${button}
        <h2>Other Values</h2>
        Some Value1 = ${this.state['some-val1']}
        Some Value2 = ${this.state['some-val2']}
      </div>
    `;
  }
}
```
