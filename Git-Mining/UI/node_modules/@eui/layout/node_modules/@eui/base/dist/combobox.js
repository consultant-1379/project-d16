import { definition, LitComponent, nothing, html, ifDefined, styleMap } from '@eui/lit-component';
import { Icon } from '@eui/theme/icon';
import { TextField } from './text-field.js';
import { Menu } from './menu.js';
import { MenuItem } from './menu-item.js';
import './checkbox.js';

var style = ":host {\n  font-family: var(--font-main, 'Ericsson Hilda', 'Helvetica');\n  display: inline-block;\n}\n\n.dropdown {\n  display: inline-block;\n  position: relative;\n  width:fit-content;\n  line-height: initial;\n}\n.btnLabel {\n  display: flex;\n  align-items: center;\n}\n.btnText {\n  flex: 1;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  text-align: left\n}";

var comboboxTypes = {
  SINGLE: 'single',
  MULTI: 'multi',
  CLICK: 'click',
};

/**
 * @license
 * COPYRIGHT Ericsson 2022
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 */

/**
 * @property {Array} data - data to configure the tree
 * @property {String} dataType - define if comboBox contains actions,
 * single select or multi select
 * @property {Array} dataInnerlabel - label of dropdown button on selecting
 * checkbox menu item when data type is multi
 * @property {String} noResultLabel - label of comboBox menuItem when searched string is unavailable
 * @property {Boolean} disabled - disabled the comboBox button
 * @property {String} placeholder - set textfield placeholder attribute for combobox
 * @property {String} selectAll - Set the label of the select all option.
 * @property {String} width - allows to set fixed width for comboBox component
 */
class ComboBox extends LitComponent {
  static get components() {
    return {
      'eui-text-field': TextField,
      'eui-menu': Menu,
      'eui-menu-item': MenuItem,
      'eui-icon': Icon,
    };
  }

  constructor() {
    super();
    this.position = {};
    this.hide = this.hide.bind(this);
    this.handleInputChange = this.handleInputChange.bind(this);
    this._getFilteredList = this._getFilteredList.bind(this);
  }

  /**
   * Lifecycle callback executed when the component is connected to the DOM
   *
   * @method didConnect
   *
   */
  didConnect() {
    this.menuItems = null;
    this.suffixes = new Map(this.dataInnerlabel);
  }

  /**
   * lifecycle hook
   *
   * @method didUpgrade
   *
   */
  didUpgrade() {
    this.inputField = this.shadowRoot.querySelector('eui-text-field');
    this.menu = this.shadowRoot.querySelector('eui-menu');

    // Enforce correct dataType
    this.dataType = ['single', 'multi'].includes(this.dataType)
      ? this.dataType
      : 'single';

    // Set initial Text-field value
    this._setTextFieldLabel();
  }

  /**
   * lifecycle hook to hook into changes to props.
   *
   * @function didChangeProps
   * @param {Object} changedProps - map containing changed props
   */
  didChangeProps(changedProps) {
    if (changedProps.has('noResultLabel')) {
      const emptyElem = this.menu.shadowRoot.querySelector('.empty');
      if (emptyElem) {
        // Element won't exist until menu is first toggled
        emptyElem.innerHTML = this.noResultLabel;
      }
    }
    if (changedProps.has('dataInnerlabel')) {
      this.suffixes = new Map(this.dataInnerlabel);
      this._setTextFieldLabel();
    }
    if (changedProps.has('data')) {
      // Clear menuItems as they will be the old menuItem elements.
      this.menuItems = null;
      this._setTextFieldLabel();
    }
    if (changedProps.has('dataType')) {
      this.dataType = ['single', 'multi'].includes(this.dataType)
        ? this.dataType
        : 'single';
    }
    if (changedProps.has('disabled')) {
      if (this.disabled && this._visible === true) {
        this.hide();
      }
    }
  }

  /**
   * create icons within menu items
   *
   * @method _makeIconsOptions
   * @param {object[]} iconOpts - an array of icon definitions.
   * @param {string} iconOpts[].name - the name of the icon.
   * @param {string} [iconOpts[].position] - the position of the icon (left/right).
   * @param {string} [iconOpts[].color] - the color of the icon.
   * @private
   */
  _makeIconsOptions(iconOpts) {
    if (!Array.isArray(iconOpts)) {
      return nothing;
    }

    return iconOpts.map(({ name, position = 'left', color }) => {
      if (name == null) {
        return nothing;
      }

      return html`<eui-icon
        name="${name}"
        slot="${position}"
        color="${ifDefined(color)}"
      ></eui-icon>`;
    });
  }

  /**
   * create comboBox menu items
   * @method _makeDropdownOptions
   * @private
   */
  _makeDropdownOptions() {
    return this.data.map(({ disabled, label, value, checked, icons }) => {
      const parseValue = dataValue => {
        let parsedValue;

        switch (typeof dataValue) {
          case 'string':
            parsedValue = dataValue;
            break;
          case 'number':
          case 'boolean':
            parsedValue = `${dataValue}`;
            break;
        }
        return parsedValue;
      };

      let menuValue = parseValue(value);
      let menuLabel = parseValue(label);

      // fallbacks
      if (!menuValue && !menuLabel) {
        // No valid item
        return nothing;
      }

      // use value or label if the other one is undefined
      if (!menuValue) {
        menuValue = menuLabel;
      } else if (!menuLabel) {
        menuLabel = menuValue;
      }

      return html`<eui-menu-item
        label=${menuLabel}
        value=${menuValue}
        ?selected=${checked}
        ?disabled=${disabled}
        >${icons ? this._makeIconsOptions(icons) : nothing}</eui-menu-item
      >`;
    });
  }

  /**
   * set menu position
   * @method _setMenuPosition
   * @private
   */
  _setMenuPosition() {
    const { x, y, height, width } = this.getBoundingClientRect();
    this.menu.position = {
      x,
      y: y + height,
      height,
      width,
    };
    this.menu.style.minWidth = `${this.offsetWidth}px`;
  }

  /**
   * make comboBox menu visible
   * @method show
   *
   * @public
   */
  show = () => {
    if (this.disabled || this._visible) {
      return;
    }

    // initialize menuItems when show first time
    if (!this.menuItems) {
      this.setMenuItems();
    }

    if (this.dataType === comboboxTypes.SINGLE) {
      // Display selected filtered menu-item if any, otherwise display all
      const selectedMenuItem = this.menu.querySelector(
        'eui-menu-item[selected]',
      );
      if (selectedMenuItem) {
        this.showFilteredList([selectedMenuItem]);
      } else {
        this.showFilteredList(this._getFilteredList());
      }
    } else if (this.dataType === comboboxTypes.MULTI) {
      this._setInputFieldValue('');
      this.showFilteredList(this._getFilteredList());
      if (this.selectAll) {
        this._makeSelectAllOptionVisible();
        // set the position of menu
        this._setMenuPosition();
      }
    }

    if (!this._visible) {
      this._visible = true;
      this.menu.show = true;
      const menu = this.menu.shadowRoot.querySelector('.menu');
      menu.removeAttribute('tabindex');
      const inputFld =
        this.inputField &&
        this.inputField.shadowRoot.querySelector('input[type="text"]');
      const len = inputFld.value && inputFld.value.length;
      inputFld.focus();
      inputFld.setSelectionRange(len, len);
    }
  };

  /**
   * make comboBox menu hidden
   * @method hide
   *
   * @public
   */
  hide() {
    this._visible = false;
    this.menu.show = false;
  }

  /**
   * return component's value
   *
   * @return {string}
   */
  get value() {
    return this.inputField.value;
  }

  /**
   * set input field value
   *
   * @param {string} newVal
   *
   */
  set value(newVal = '') {
    // If not a string or number, then just return
    if (typeof newVal !== 'string' && typeof newVal !== 'number') {
      return;
    }
    this._setInputFieldValue(newVal);
    this.handleInputChange();
  }

  /**
   * set comboBox input textfield value
   * @function _setInputFieldValue
   * @private
   */
  _setInputFieldValue = value => {
    this.inputField.value = value;
  };

  /**
   * filter menu-items based on text entered in input field
   * @function _getFilteredList
   *
   * @returns {Array} filtered item-list
   */
  _getFilteredList() {
    if (this.menuItems === null) {
      return [];
    }
    let inputValue = this.value ? this.value.toLowerCase() : '';

    // eslint-disable-next-line max-len
    const filteredList = this.menuItems.filter(item =>
      item.label.toLowerCase().includes(inputValue),
    );
    // Input value may have characters that need escaped for regexp pattern
    inputValue = inputValue.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    for (let i = 0; i < filteredList.length; i += 1) {
      if (inputValue !== '') {
        const regex = new RegExp(inputValue, 'gi');
        const menuItemName =
          filteredList[i].shadowRoot.querySelector('#label').textContent;
        const finalValue = menuItemName.replace(
          regex,
          str => `<span class="bold">${str}</span>`,
        );
        filteredList[i].shadowRoot.querySelector('#label').innerHTML =
          finalValue;
      } else {
        this.menu.focusedChild = -1;
        const _checkForBoldFont =
          filteredList[i].shadowRoot.querySelectorAll('.bold');
        if (_checkForBoldFont.length > 0) {
          _checkForBoldFont.forEach(el => el.classList.remove('bold'));
        }
        filteredList[i].classList.remove('highlight');
      }
    }
    return filteredList;
  }

  /**
   * handle display of filtered list
   *
   * @function showFilteredList
   *
   */
  showFilteredList(list) {
    // handle No Result Found scenario
    const menu = this.menu.shadowRoot.querySelector('.menu');
    let emptyElem = menu.querySelector('.empty');
    if (!emptyElem) {
      // inject into menu's shadow an empty div- No Result found element
      const div = document.createElement('div');
      div.className = 'empty hidden';
      div.innerHTML = this.noResultLabel;
      emptyElem = menu.appendChild(div);
    }

    if (this.menuItems !== null) {
      // Hide all items
      this.menuItems.forEach(item => {
        item.classList.add('hidden');
      });
    }

    if (Array.isArray(list) && list.length === 0) {
      emptyElem.classList.remove('hidden'); // if filtered array is empty show empty div
    } else {
      emptyElem.classList.add('hidden');

      // Unhide only filtered list
      list.forEach(item => {
        item.classList.remove('hidden');
      });
    }
    this._positionFilteredMenuItems();
  }

  /**
   * set the position of menu when the menu items are filtered
   *
   * @function _positionFilteredMenuItems
   *
   */
  _positionFilteredMenuItems() {
    this._setMenuPosition();
    this.menu._positionMenu();
  }

  /**
   * handle value change in input textfield
   * @function handleInputChange
   * @public
   */
  handleInputChange() {
    if (!this.menuItems) {
      this.setMenuItems();
    }
    if (!this._visible && this.value) {
      this.show();
    }

    const filteredList = this._getFilteredList();
    this.showFilteredList(filteredList);

    // To clear highlighted menuItem on deleting/removing it from input field
    if (this.dataType === comboboxTypes.SINGLE) {
      const selectedMenuItem = this.menu.querySelector(
        'eui-menu-item[selected]',
      );
      const dataItemSelected =
        this.data && this.data.filter(item => item.checked);
      if (selectedMenuItem) {
        selectedMenuItem.selected = false;
        if (dataItemSelected) {
          dataItemSelected[0].checked = false;
        }
      }
    }

    if (this.dataType === comboboxTypes.MULTI && this.selectAll) {
      if (this.value === '') {
        this._makeSelectAllOptionVisible();
      } else {
        const checkForSelectAllItem = this.menu.hasAttribute('select-all');
        if (checkForSelectAllItem) {
          const selectAllMenuItem =
            this.menu.shadowRoot.querySelector('#select-all');
          selectAllMenuItem.classList.add('hidden');

          const horizontalBreak = this.menu.shadowRoot.querySelector('hr');
          horizontalBreak.classList.add('hidden');
        }
      }
    }
  }

  /**
   * set the menu items in context
   * @method setMenuItems
   *
   * @public
   */
  setMenuItems = () => {
    const menuItems = this.menu.querySelectorAll('eui-menu-item');
    if (menuItems.length > 0) {
      this.menuItems = Array.from(menuItems);
    }
  };

  /**
   * handle key chevron click
   * @function handleChevronClick
   *
   */
  handleChevronClick = event => {
    event.stopPropagation();
    if (this._visible) {
      this.hide();
      this._setTextFieldLabel();
    } else {
      this.show();
    }
  };

  /**
   * Handle event 'eui-menu:click'
   *
   * @function handleEvent
   * @param {Event} event - an event
   */
  handleEvent(event) {
    if (event.code === 'PageUp' || event.code === 'PageDown') {
      event.preventDefault();
    } else if (event.code === 'Tab') {
      this.hide();
    } else if (event.type === 'eui-menu:change') {
      event.stopPropagation();
      this._handleMultipleComboxes();
      this.bubble('eui-combobox:change', event.detail);
    } else if (event.type === 'eui-menu:click') {
      event.stopPropagation();
      if (this.dataType === 'single') {
        this.hide();
      }
      this.bubble('eui-combobox:click', event.detail);
    } else if (event.type === 'eui-menu:hidden') {
      event.preventDefault();
      this.hide();
      this._setTextFieldLabel();
    } else if (
      event.code === 'Enter' ||
      event.code === 'ArrowDown' ||
      event.code === 'ArrowUp' ||
      event.code === 'Escape'
    ) {
      this.menu._handleKeyboard(event);
    }
  }

  /**
   * handle click event being triggered on menu-item
   * for both single and multi-select comobobox
   * @function _handleMultipleDropdowns
   * @private
   */
  _handleMultipleComboxes = () => {
    this._setTextFieldLabel();
    this._syncComboboxDataProp();
  };

  /**
   * sync the data prop with respect to selected state of the menu-items
   * @function _syncComboboxDataProp
   * @private
   */
  _syncComboboxDataProp() {
    if (this.data) {
      const selectedItems = this.menu.menuItems.filter(item => item.selected);
      if (this.dataType === comboboxTypes.SINGLE && selectedItems.length) {
        this.data.forEach(element => {
          element.checked = element.label === selectedItems[0].label;
        });
      } else if (
        this.dataType === comboboxTypes.MULTI &&
        selectedItems.length
      ) {
        const selectedItemsLabel = new Set(
          selectedItems.map(item => item.label),
        );
        this.data.forEach(element => {
          element.checked = selectedItemsLabel.has(element.label);
        });
      } else {
        this.data.forEach(element => {
          element.checked = false;
        });
      }
      this.data = [...this.data];
    }
  }

  /**
   * Make select-all option visible
   * @function _makeSelectAllOptionVisible
   * @private
   */
  _makeSelectAllOptionVisible() {
    const selectAllMenuItem = this.menu.shadowRoot.querySelector('#select-all');
    if (selectAllMenuItem.classList.contains('hidden')) {
      selectAllMenuItem.classList.remove('hidden');
      const horizontalBreak = this.menu.shadowRoot.querySelector('hr');
      horizontalBreak.classList.remove('hidden');
    }
  }

  /**
   * Set suffix for input field label
   * @function _setLabelSuffix
   * @param {array} selectedItems - array of selectedItems
   */
  _setLabelSuffix(selectedItems) {
    let labelName = null;
    if (selectedItems.length === 1) {
      labelName = 'one';
    } else {
      labelName = 'other';
    }
    this._setInputFieldValue(
      `${selectedItems.length} ${this.suffixes.get(labelName)}`,
    );
  }

  /**
   * Check if text-field value is present in menuItems set
   * @function  _isLabelPresent
   * @returns {Boolean} true/false
   * @private
   */
  _isLabelPresent = () => {
    const { menuItems } = this.menu;
    const menuItemsLabel = new Set(menuItems.map(item => item.label));
    return menuItemsLabel.has(this.value);
  };

  /**
   * Set label for ComboBox input field
   * @function _setTextFieldLabel
   * @private
   */
  _setTextFieldLabel() {
    const dataItemsSelected =
      this.data && this.data.filter(item => item.checked);
    const totalDataItems = this.data;
    const menuItemsSelected = this.menu.value;
    const totalMenuItems = this.menu && this.menu.menuItems;

    if (this.dataType === comboboxTypes.SINGLE) {
      if (dataItemsSelected && dataItemsSelected.length > 0) {
        this._setInputFieldValue(dataItemsSelected[0].label);
        this.hide();
      } else if (menuItemsSelected && menuItemsSelected.length > 0) {
        this._setInputFieldValue(menuItemsSelected[0].label);
        this.hide();
      } else if (menuItemsSelected.length === 0 && this._isLabelPresent()) {
        this._setInputFieldValue('');
        this.hide();
      } else if (!this.menu.show && !this._isLabelPresent()) {
        this._setInputFieldValue('');
      }
    } else if (this.dataType === comboboxTypes.MULTI) {
      if (dataItemsSelected) {
        if (dataItemsSelected.length === totalDataItems.length) {
          this._setInputFieldValue(this.suffixes.get('all'));
        } else {
          this._setLabelSuffix(dataItemsSelected);
        }
      } else if (menuItemsSelected) {
        if (menuItemsSelected.length === totalMenuItems.length) {
          this._setInputFieldValue(this.suffixes.get('all'));
        } else {
          this._setLabelSuffix(menuItemsSelected);
        }
      }
    }
  }

  /**
   * Move menuItem on slot change
   * @function  _moveMenuItem
   * @param {Event} event - an event
   */
  _moveMenuItem = event => {
    const menuItems = event.target.assignedElements();
    if (menuItems.length > 0) {
      this.menu.appendChild(menuItems[0]);
    }
    this._setTextFieldLabel();
  };

  /**
   * Handle click and mousedown events
   * on text field
   * @function _handleTextFieldEvent
   * @param {Event} event - an event
   */
  _handleTextFieldEvent = event => {
    if (this._visible) {
      if (
        event.composedPath()[0] ===
        this.inputField.shadowRoot.querySelector('.textfield__icon')
      ) {
        event.preventDefault();
      }
      event.stopPropagation();
      return;
    }
    this.show();
  };

  render() {
    const inlineWidth = this.width ? `${this.width}` : '';
    const inputComboField = html`
      <eui-text-field
        placeholder="${this.placeholder || 'Write or select...'}"
        ?fullwidth="${!!this.width}"
        ?disabled=${this.disabled}
        @click=${this._handleTextFieldEvent}
        @mousedown=${this._handleTextFieldEvent}
        @input="${this.handleInputChange}"
        @keydown="${this}"
      >
        <eui-icon
          slot="icon"
          name=${this._visible ? 'chevron-up' : 'chevron-down'}
          @click="${this.handleChevronClick}"
        >
        </eui-icon>
      </eui-text-field>
    `;

    return html`
      <div class="dropdown" style=${styleMap({ width: inlineWidth })}>
        ${inputComboField}
        ${!this.data
          ? html`<slot
              @slotchange=${event => this._moveMenuItem(event)}
            ></slot>`
          : nothing}
        <eui-menu
          type=${this.dataType}
          @eui-menu:change=${this}
          @eui-menu:click=${this}
          @eui-menu:hidden=${this}
          select-all=${ifDefined(this.selectAll)}
        >
          ${this.data ? this._makeDropdownOptions() : nothing}
        </eui-menu>
      </div>
    `;
  }
}

definition('eui-combo-box', {
  style,
  props: {
    data: { type: Array },
    dataInnerlabel: {
      type: Array,
      default: [
        ['one', 'item selected'],
        ['other', 'items selected'],
        ['all', 'All items selected'],
      ],
    },
    dataType: { attribute: true, type: String, default: 'single' },
    noResultLabel: {
      attribute: true,
      type: String,
      default: 'No Result Found',
    },
    disabled: { attribute: true, type: Boolean },
    placeholder: { attribute: true, type: String },
    selectAll: { attribute: true, type: String },
    _visible: { type: Boolean },
    width: { attribute: true, type: String },
  },
})(ComboBox);

export { ComboBox };
