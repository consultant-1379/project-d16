import { definition } from '@eui/lit-component';
import { Icon } from '@eui/theme/icon';
import { TextField } from './text-field.js';
import { Tooltip } from './tooltip.js';

var style = ":host(:hover:not([disabled]):not([readonly])) .textfield__icon ::slotted(*) {\n  --icon-color: var(--text, #242424);\n  opacity: 0.5;\n}\n\n:host(:hover:not([disabled]):not([readonly])) .textfield__icon ::slotted(*:hover) {\n  --icon-color: var(--text, #242424);\n  opacity: 1;\n}\n\n:host(.active:not([disabled]):not([readonly])) .textfield__icon ::slotted(*) {\n  --icon-color: var(--text, #242424);\n  opacity: 0.5;\n}\n\ninput {\n  min-width: 160px;\n  width: 100% !important;\n}\n\n.textfield__icon ::slotted(*) {\n  opacity: 0;\n  padding-right: 3px;\n  line-height: 1;\n}\n\n.textfield__icon--no-right-margin {\n  margin-left: -28px;\n}\n";

/**
 * @license
 * COPYRIGHT Ericsson 2022
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 */

class PasswordField extends TextField {
  static get components() {
    return {
      'eui-tooltip': Tooltip,
      'eui-icon': Icon,
    };
  }

  /**
   * call this only once when the shadowRoot is
   * attached and the template is added.
   *
   * @function didUpgrade
   */
  didUpgrade() {
    super.didUpgrade();

    // add tooltip
    this.tooltip = this.createElement('eui-tooltip');
    this.tooltip.setAttribute('position', 'bottom-end');
    this.tooltip.slot = 'icon';

    // Block tooltip's cursor css, cannot override due to nested slots
    if (!this.disabled && !this.readonly) {
      this.tooltip.setAttribute('action', '');
    }

    // add the eye icon
    this.eyeIcon = this.createElement('eui-icon');
    this.eyeIcon.addEventListener('click', () => {
      if (!this.disabled && !this.readonly && !this.unmaskDisabled) {
        this.unmask = !this.unmask;
      }
    });
    this.tooltip.appendChild(this.eyeIcon);

    if (!this.unmaskDisabled) {
      this.appendChild(this.tooltip);
    } else {
      this.unmask = false;
    }

    // set the text field as a password field
    this.inputField = this.shadowRoot.querySelector('input');
    this._updateMaskState();

    this.addEventListener('focus', () => {
      this.classList.add('active');
    });
  }

  /**
   * Lifecycle callback executed each time the components props are updated
   *
   * @method didChangeProps
   * @param {Object} changedProps - the previous values of the components changed props
   *
   * @protected
   */
  didChangeProps(changedProps) {
    super.didChangeProps(changedProps);
    if (changedProps.has('unmask')) {
      if (this.unmaskDisabled) {
        this.unmask = false;
      }
      this._updateMaskState();
    }

    if (changedProps.has('disabled') || changedProps.has('readonly')) {
      if (this.disabled || this.readonly) {
        this.tooltip.removeAttribute('action');
      } else {
        this.tooltip.setAttribute('action', '');
      }
    }

    if (changedProps.has('unmaskDisabled')) {
      if (this.unmaskDisabled) {
        // Does not trigger another prop change
        this.unmask = false;
        this._updateMaskState();
        this.removeChild(this.tooltip);
      } else {
        this.appendChild(this.tooltip);
      }
    }
  }

  /**
   * Handle all events
   * @method handleEvent
   * @param {Event} event
   */
  handleEvent(event) {
    super.handleEvent(event);

    if (event.type === 'blur') {
      this.classList.remove('active');
    }
  }

  /**
   * Updates the icon tooltip state based on mask state
   *
   * @method _updateMaskState
   * @private
   */
  _updateMaskState() {
    this.inputField.type = this.unmask ? 'text' : 'password';
    this.eyeIcon.setAttribute('name', this.unmask ? 'eye-solid' : 'eye');
    this.tooltip.setAttribute(
      'message',
      this.unmask ? 'Hide password' : 'Show password',
    );
  }
}

/**
 * @property {Boolean} autocomplete - true, browser automatically completes
 * the input values based on values that the user has entered before
 * @property {Boolean} autofocus - true, password-field should automatically
 * get focus when the page loads
 * @property {Boolean} disabled - true, disables the password field
 * @property {Boolean} fullwidth - true, sets the password field to
 * take the full width of the parent container
 * @property {Number} maxlength - sets the maximum allowed length for the password field
 * @property {String} name - sets the name of the password field (used in a form)
 * @property {String} pattern - regular expression for validating input
 * @property {String} placeholder - sets the placeholder text to appear in the
 * password field when it is empty
 * @property {Boolean} readonly - true sets the password field readonly
 * @property {Boolean} required - true, sets the password field must be
 * filled out before submitting the form
 * @property {String} unmask - true, unmasks the password field
 * @property {String} successMessage - success message to display when input value is valid
 * @property {String} validationMessage - message to display when input value is invalid
 * @property {Boolean} unmaskDisabled - true, disables the unmask functionality
 */
definition('eui-password-field', {
  style,
  props: {
    unmask: { attribute: true, type: Boolean },
    unmaskDisabled: { attribute: true, type: Boolean },
  },
})(PasswordField);

// TODO: This must be removed as it is not good OOD. We are extending the Textfield
// so we should not remove props. Instead we should have a base Textfield
// without prefix, suffix and size.
// Other solution is to allow prefix, suffix and size in the Password component.

// Remove unnecessary props inherited from parent class
delete PasswordField._propDefs.prefix;
delete PasswordField._propDefs.suffix;
delete PasswordField._propDefs.size;

export { PasswordField };
