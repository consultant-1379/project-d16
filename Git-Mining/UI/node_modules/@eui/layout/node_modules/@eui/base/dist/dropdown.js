import { definition, LitComponent, nothing, html, ifDefined, styleMap } from '@eui/lit-component';
import { Icon } from '@eui/theme/icon';
import { Button } from './button.js';
import { Menu } from './menu.js';
import { MenuItem } from './menu-item.js';
import './checkbox.js';

var style = ":host {\n  font-family: var(--font-main, 'Ericsson Hilda', 'Helvetica');\n  display: inline-block;\n}\n\n.dropdown {\n  display: inline-block;\n  position: relative;\n  width:fit-content;\n  line-height: initial;\n}\n\n.menu--hidden {\n  display:none;\n}\n\nlabel {\n  margin: 0;\n  width: 100%;\n}\n\n.more {\n  cursor: pointer;\n  display: flex;\n  padding-left: var(--space-base, 8px);\n}\n\n";

var dropdownTypes = {
  SINGLE: 'single',
  MULTI: 'multi',
  CLICK: 'click',
};

/**
 * @license
 * COPYRIGHT Ericsson 2022
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 */

/**
 * @property {Array} data - data to configure the tree
 * @property {Array} dataInnerlabel - label of dropdown button on selecting
 * checkbox menu item when data type is multi
 * @property {String} dataType - define if dropdown contains actions,
 * single select or multi select
 * @property {Boolean} disabled - disabled the dropdown button
 * @property {String} label - sets the label of dropdown button
 * @property {Boolean} more - if true, replaces dropdown button with more Icon
 * @property {String} selectAll - Set the label of the select all option.
 * Setting to null removes the select all option when data type is multi.
 * @property {String} width - allows to set fixed width for dropdown component
 */
class Dropdown extends LitComponent {
  static get components() {
    return {
      'eui-button': Button,
      'eui-icon': Icon,
      'eui-menu': Menu,
      'eui-menu-item': MenuItem,
    };
  }

  /**
   * dropdown constructor.
   */
  constructor() {
    super();
    this.position = {};
    this.hide = this.hide.bind(this);
  }

  /**
   * Handle eui-menu:click event and the events bubbled from window, mouse, keyboard and document.
   *
   * @function handleEvent
   * @param {Event} event - an event
   */
  handleEvent(event) {
    if (event.code === 'PageUp' || event.code === 'PageDown') {
      // blocks keyboard scrolling of menu
      event.preventDefault();
    } else if (event.code === 'Tab') {
      // TODO long term could this be part of menu keyboard functionality + bubble hidden event??
      this.hide();
    } else if (event.type === 'eui-menu:click') {
      event.stopPropagation();
      if (this.dataType === 'single') {
        // Important when selecting same item twice, no change event received
        this.hide();
      } else if (this.dataType === 'click') {
        this.hide();
        this.bubble('eui-dropdown:change', event.detail);
      }
      this.bubble('eui-dropdown:click', event.detail);
    } else if (event.type === 'eui-menu:change') {
      event.stopPropagation();
      if (this.dataType === 'single') {
        this.hide();
      }
      this._handleMultipleDropdowns();
      this.bubble('eui-dropdown:change', event.detail);
    } else if (event.key === 'Escape') ; else if (event.type === 'mousedown') {
      event.stopImmediatePropagation();
      if (!event.composedPath().includes(this)) {
        this.hide();
      }
    } else if (event.type === 'eui-menu:hidden') {
      event.preventDefault();
      this.hide();
    }
  }

  /**
   * handle different types of dropdown
   * @function _handleMultipleDropdowns
   * @private
   */
  _handleMultipleDropdowns = () => {
    if (this.dataType === dropdownTypes.SINGLE) {
      this._setDropdownLabel();
    } else if (this.dataType === dropdownTypes.MULTI) {
      this._setDropdownLabel();
    }
    this._syncDropdownDataProp();
  };

  /**
   * sync the data prop with respect to selected state of the menu-items
   * @function _syncDropdownDataProp
   * @private
   */
  _syncDropdownDataProp() {
    if (this.data) {
      const selectedItems = this.menu.menuItems.filter(item => item.selected);
      if (this.dataType === dropdownTypes.SINGLE && selectedItems.length > 0) {
        this.data.forEach(element => {
          element.checked = element.label === selectedItems[0].label;
        });
      } else if (
        this.dataType === dropdownTypes.MULTI &&
        selectedItems.length > 0
      ) {
        const selectedItemsLabel = new Set(
          selectedItems.map(item => item.label),
        );
        this.data.forEach(element => {
          element.checked = selectedItemsLabel.has(element.label);
        });
      } else {
        this.data.forEach(element => {
          element.checked = false;
        });
      }
      this.data = [...this.data];
    }
  }

  /**
   * Lifecycle callback executed when the component is connected to the DOM
   *
   * @method didConnect
   *
   */
  didConnect() {
    this._dynamicLabel = this.label;
    this._visible = false;
    this.suffixes = new Map(this.dataInnerlabel);
  }

  /**
   * Lifecycle callback executed when the component is disconnected from the DOM
   *
   * remove any document event listeners added that may not have had the opportunity to be removed
   *
   * @function didDisconnect
   */
  didDisconnect() {
    document.removeEventListener('mousedown', this);
  }

  /**
   * Lifecycle hook to hook into the point where the component is upgraded.
   * This is a good time to start observing the menu for changes to it's items.
   *
   * @function didUpgrade
   */
  didUpgrade() {
    if (this.data) {
      this._setDropdownLabel();
    }
    this.menu = this.shadowRoot.querySelector('eui-menu');
    // Enforce correct dataType
    this.dataType = ['single', 'multi', 'click'].includes(this.dataType)
      ? this.dataType
      : 'click';
  }

  /**
   * lifecycle hook to hook into changes to props.
   *
   * @function didChangeProps
   * @param {Object} changedProps - map containing changed props
   */
  didChangeProps(changedProps) {
    // always check the value of data.
    if (this.data || changedProps.has('label')) {
      this._setDropdownLabel();
    }
    // Any unsupported value revert back to default
    if (changedProps.has('dataType')) {
      this.dataType = ['single', 'multi', 'click'].includes(this.dataType)
        ? this.dataType
        : 'click';
    }
    if (changedProps.has('dataInnerlabel')) {
      // TODO what if at least 1 key is missing?
      this.suffixes = new Map(this.dataInnerlabel);
      this._setDropdownLabel();
    }
    if (changedProps.has('disabled')) {
      if (this.disabled && this._visible === true) {
        this.hide();
      }
    }
  }

  /**
   * set the dynamic inner label of dropdown button based on the
   * number of selected menuItems
   * @function _setDropdownLabel
   * @private
   */
  _setDropdownLabel() {
    const dataItemsSelected =
      this.data && this.data.filter(item => item.checked);
    const menuItemsSelected = this.value;
    const totalMenuItems = this.menu && this.menu.menuItems;
    this._dynamicLabel = this.label;
    if (this.dataType === dropdownTypes.SINGLE) {
      if (dataItemsSelected && dataItemsSelected.length > 0) {
        this._dynamicLabel = dataItemsSelected[0].label;
      } else if (menuItemsSelected && menuItemsSelected.length > 0) {
        this._dynamicLabel = menuItemsSelected[0].label;
      }
    } else if (this.dataType === dropdownTypes.MULTI) {
      if (dataItemsSelected) {
        this._handleDataInnerLabel(dataItemsSelected.length);
      } else if (menuItemsSelected) {
        this._handleDataInnerLabel(
          menuItemsSelected.length,
          totalMenuItems.length,
        );
      }
    }
  }

  /**
   * Method that returns true if the zoom is active on a touch device
   * For desktop browsers this will always return false
   * @function isTouchZoomActive
   * @return {boolean}
   */
  isTouchZoomActive() {
    // windows.innerWidth and innerHeight varies with zoom on touch devices
    const { documentElement } = document;
    const _isZoomActive =
      documentElement.clientHeight / window.innerHeight > 1 &&
      documentElement.clientWidth / window.innerWidth > 1;
    return _isZoomActive;
  }

  /**
   * set the position of the menu when the zoom is inactive
   * @function _setMenuPosition
   * @private
   */
  _setMenuPosition() {
    const { x, y, height, width } = this.getBoundingClientRect();
    this.menu.position = {
      x,
      y: y + height,
      height,
      width,
    };
  }

  /**
   * Method for calculating the position of an element
   * in relation to the document when zoom is active on touch devices
   * Use when trying to determine the position of an element when the browser
   * on a touch device is zoomed.When zoomed document and viewport do not match
   * on touch devices, using _setMenuPosition() sets position in relation to viewport
   * This is problematic when dynamically updating css style/position of element as
   * these are applied in relation to the document.
   * https://stackoverflow.com/questions/5598743/finding-elements-position-relative-to-the-document
   *
   * @function _setMenuPositionOnZoom
   * @private
   */
  _setMenuPositionOnZoom() {
    const box = this.getBoundingClientRect();
    const { body, documentElement: docEl } = document;
    const scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
    const scrollLeft =
      window.pageXOffset || docEl.scrollLeft || body.scrollLeft;
    const clientTop = docEl.clientTop || body.clientTop || 0;
    const clientLeft = docEl.clientLeft || body.clientLeft || 0;
    const top = box.top + scrollTop - clientTop;
    const left = box.left + scrollLeft - clientLeft;
    this.menu.position = {
      x: left,
      y: top + box.height,
      height: box.height,
      width: box.width,
    };
  }

  /**
   * make dropdown menu visible. Add event listener (mousedown) to the document to detect
   * if the user clicks outside of the menu.
   *
   * @method show
   * @public
   */
  show = () => {
    if (this.disabled) {
      return;
    }
    // eslint-disable-next-line no-unused-expressions
    this.isTouchZoomActive()
      ? this._setMenuPositionOnZoom()
      : this._setMenuPosition();
    if (!this._visible) {
      this._visible = true;
      document.addEventListener('mousedown', this);
    }
    const dropdownButton = this.shadowRoot.querySelector('eui-button');
    if (dropdownButton) {
      const chevronIcon = dropdownButton.buttonIcon;
      chevronIcon?.setAttribute(
        'style',
        'transform:rotate(-180deg);transition:all 0.3s ease;',
      );
    }
    this.menu.show = true;
    this.menu.style.minWidth = `${this.offsetWidth}px`;
  };

  /**
   * make dropdown menu hidden. Remove event listener (mousedown) from the
   * document when the menu is no longer visible.
   *
   * @method hide
   * @param {Boolean} setButtonFocus - true = set the button focus, false = do not set button focus
   * @public
   */
  hide(setButtonFocus = true) {
    if (this._visible) {
      const dropdownButton = this.shadowRoot.querySelector('eui-button');
      if (dropdownButton) {
        if (setButtonFocus) {
          dropdownButton.focus();
        }
        const chevronIcon = dropdownButton.buttonIcon;
        chevronIcon?.setAttribute('style', 'transition:all 0.3s ease;');
      }
      // Needed for toggling, event paths this should be already false
      this.menu.show = false;
      this._visible = false;
      document.removeEventListener('mousedown', this);
    }
  }

  /**
   * toggle the dropdown Menu
   * @method toggleDropdownMenu
   * @public
   */
  toggleDropdownMenu = event => {
    event.stopPropagation();
    if (this.disabled) {
      return;
    }
    if (this._visible) {
      this.hide(false);
    } else {
      this.show();
    }
  };

  /**
   * set dynamic Innerlabel on dropdown menu based on the number of menu items selected
   * @method _handleDataInnerLabel
   * @private
   */
  _handleDataInnerLabel = (
    selectedItemsLength,
    totalItemsLength = this.data.length,
  ) => {
    if (selectedItemsLength > 0) {
      let prefix = `${selectedItemsLength} `;
      let rule = 'other';
      if (selectedItemsLength === totalItemsLength) {
        rule = 'all';
        prefix = '';
      } else if (selectedItemsLength === 1) {
        rule = 'one';
      }
      this._dynamicLabel = `${prefix}${this.suffixes.get(rule)}`;
    }
  };

  /**
   * Get the value of the dropdown. depending on the data-type this
   * function returns either an Array.
   * data-type = 'multi/single' returns an array.
   *
   * @property value
   * @returns {Array/String}
   * @public
   */
  get value() {
    if (this.menu) {
      return this.menu.value;
    }
    return [];
  }

  /**
   * create icons within menu items
   *
   * @method _makeIconsOptions
   * @param {object[]} iconOpts - an array of icon definitions.
   * @param {string} iconOpts[].name - the name of the icon.
   * @param {string} [iconOpts[].position] - the position of the icon (left/right).
   * @param {string} [iconOpts[].color] - the color of the icon.
   * @private
   */
  _makeIconsOptions(iconOpts) {
    if (!Array.isArray(iconOpts)) {
      return nothing;
    }

    return iconOpts.map(({ name, position = 'left', color }) => {
      if (name == null) {
        return nothing;
      }

      return html`<eui-icon
        name="${name}"
        slot="${position}"
        color="${ifDefined(color)}"
      ></eui-icon>`;
    });
  }

  /**
   * create dropdown menu items
   * @method _makeDropdownOptions
   * @private
   */
  _makeDropdownOptions() {
    return this.data.map(({ disabled, label, value, checked, icons }) => {
      const parseValue = dataValue => {
        let parsedValue;

        switch (typeof dataValue) {
          case 'string':
            parsedValue = dataValue;
            break;
          case 'number':
          case 'boolean':
            parsedValue = `${dataValue}`;
            break;
        }
        return parsedValue;
      };

      let menuValue = parseValue(value);
      let menuLabel = parseValue(label);

      // fallbacks
      if (!menuValue && !menuLabel) {
        // No valid item
        return nothing;
      }

      // use value or label if the other one is undefined
      if (!menuValue) {
        menuValue = menuLabel;
      } else if (!menuLabel) {
        menuLabel = menuValue;
      }

      return html`<eui-menu-item
        label=${menuLabel}
        value=${menuValue}
        ?selected=${checked}
        ?disabled=${disabled}
        >${icons ? this._makeIconsOptions(icons) : nothing}</eui-menu-item
      >`;
    });
  }

  _moveMenuItem = event => {
    if (event.target.assignedElements().length > 0) {
      this.menu.appendChild(event.target.assignedNodes()[0]);
    }
    this._setDropdownLabel();
  };

  /**
   * Render the <eui-dropdown> component. This function is called each time a
   * prop changes.
   *
   * @method render
   */
  render() {
    const inlineWidth = this.width ? `${this.width}` : '';
    // 'click' -->  menu component type=null
    const dataType = ['single', 'multi'].includes(this.dataType)
      ? this.dataType
      : null;
    const dropdownButton = this.more
      ? html`
          <eui-icon
            class="more"
            name="more"
            @click="${this.toggleDropdownMenu}"
            ?disabled=${this.disabled}
          >
          </eui-icon>
        `
      : html`
          <eui-button
            tabindex="0"
            @click="${this.toggleDropdownMenu}"
            ?disabled=${this.disabled}
            ?primary=${this.primary}
            icon="chevron-down"
            reverse
            align-edge
            style=${styleMap({ width: inlineWidth })}
            >${this._dynamicLabel}</eui-button
          >
        `;
    return html`
      <div
        class="dropdown"
        style=${styleMap({ width: inlineWidth })}
        @eui-menu:hidden=${this}
      >
        ${dropdownButton}
        ${!this.data
          ? html`<slot
              @slotchange=${event => this._moveMenuItem(event)}
            ></slot>`
          : nothing}
        <eui-menu
          type=${ifDefined(dataType)}
          @eui-menu:click=${this}
          select-all=${ifDefined(this.selectAll)}
          @eui-menu:change=${this}
          @keydown=${this}
        >
          ${this.data ? this._makeDropdownOptions() : nothing}
        </eui-menu>
      </div>
    `;
  }
}

definition('eui-dropdown', {
  style,
  props: {
    data: { type: Array },
    dataInnerlabel: {
      type: Array,
      default: [
        ['one', 'item selected'],
        ['other', 'items selected'],
        ['all', 'All items selected'],
      ],
    },
    dataType: { attribute: true, type: String, default: 'click' },
    disabled: { attribute: true, type: Boolean },
    primary: { attribute: true, type: Boolean },
    label: { attribute: true, type: String, required: true },
    _dynamicLabel: { type: String },
    _visible: { type: Boolean },
    more: { attribute: true, type: Boolean },
    selectAll: { attribute: true, type: String },
    width: { attribute: true, type: String },
  },
})(Dropdown);

export { Dropdown };
