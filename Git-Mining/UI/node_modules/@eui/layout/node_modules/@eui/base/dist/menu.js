import { definition, LitComponent, html, nothing } from '@eui/lit-component';
import { MenuItem } from './menu-item.js';
import './checkbox.js';

var style = ":host {\n  position: fixed;\n  z-index: 1500;\n  margin: var(--space-small, 4px) 0 0;\n  width: fit-content;\n  display: none;\n}\n\n:host([show]) {\n  display: block;\n}\n\n.menu {\n  background: var(--menu-background, #FFF);\n  border: solid 1px var(--menu-border, #878787);\n  text-align: left;\n  max-height: 228px;\n  overflow-y: auto;\n  overflow-x: hidden;\n  display: block;\n  min-width: 60px;\n  outline: none;\n}\n\neui-menu-item:focus {\n  outline: none;\n}\n\n*::-webkit-scrollbar {\n  width: 8px;\n  height: 8px;\n  background: transparent;\n}\n*::-webkit-scrollbar-corner {\n  background: transparent;\n}\n*::-webkit-scrollbar-thumb {\n  background-color: var(--scrollbar-thumb, rgb(177, 177, 177));\n}\n\n* { /* Firefox */\n  scrollbar-color: var(--scrollbar-thumb, rgb(177, 177, 177)) transparent;\n  scrollbar-width: thin;\n}\n\nhr {\n  margin: 0;\n  border-style: none;\n  border-top: 1px solid var(--menu-hr, #878787);\n  border-bottom: 0;\n}\n\n.menu ::slotted(hr) {\n  margin: 0;\n  border-style: none;\n  border-top: 1px solid var(--menu-hr, #878787);\n  border-bottom: 0;\n}\n\n.menu ::slotted(*:focus) {\n  outline: none\n}\n\n.menu ::slotted(*:not(hr):not(eui-menu-item)) {\n  padding: var(--space-base, 8px) var(--space-base, 8px) 7px;\n  display: block;\n  cursor: pointer;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  box-sizing: border-box;\n}\n\ndiv.empty {\n  padding: var(--space-base, 8px) var(--space-base, 8px) 7px;\n}\n\n.hidden,\n.menu ::slotted(eui-menu-item.hidden),\n.menu eui-menu-item.hidden,\n.menu .empty.hidden {\n  display: none;\n}\n";

/* eslint no-console:0 */

/**
 * @property {Object} position - x,y coordinates of the top left of the menu
 * @property {Boolean} show - show/hide the menu
 * @property {String} type - type of menu [null|'single'|'multi']
 * 1. action (type = null)
 * 2. single select (type= 'single')
 * 3. multiple select (type = 'multi')
 */
class Menu extends LitComponent {
  static get components() {
    return {
      'eui-menu-item': MenuItem,
    };
  }

  constructor() {
    super();
    this._contextMenuStyle = this._contextMenuStyle.bind(this);
    this._menuItemIndex = this._menuItemIndex.bind(this);
    this._setFocus = this._setFocus.bind(this);
    this._updateMenuItemPaddingLeft =
      this._updateMenuItemPaddingLeft.bind(this);
    this._updateMenuItemPaddingRight =
      this._updateMenuItemPaddingRight.bind(this);
    this._handleSlotChange = this._handleSlotChange.bind(this);
    this._closeMenuWhenClickedOutside =
      this._closeMenuWhenClickedOutside.bind(this);
    this._handleKeyboard = this._handleKeyboard.bind(this);

    this.ARROW_UP_KEY = 'ArrowUp';
    this.ARROW_DOWN_KEY = 'ArrowDown';
    this.ESCAPE_KEY = 'Escape';
    this.ENTER_KEY = 'Enter';
    this.SPACE_KEY = ' ';
  }

  /**
   * Set the internal menu class as a global for easy access
   */
  didUpgrade() {
    this.menu = this.shadowRoot.querySelector('.menu');
  }

  /**
   * Set the padding on each menuItem added to this menu.
   *
   * @function _updateMenuItemPaddingLeft
   * @param {[...menuItem]} menuItems - Array of MenuItems
   */
  _updateMenuItemPaddingLeft(menuItems) {
    if (menuItems && menuItems.length > 0) {
      const menuItemsWithItemsOnLeft = menuItems.map(
        menuItem => menuItem.leftIcons,
      );
      this._maxPaddingLeft = menuItemsWithItemsOnLeft.reduce((a, b) =>
        Math.max(a, b),
      );
      menuItems.forEach(menuItem => {
        menuItem._paddingLeft = this._maxPaddingLeft;
      });
    }
  }

  /**
   * Set the padding on each menuItem added to this menu.
   *
   * @function _updateMenuItemPaddingRight
   * @param {[...menuItem]} menuItems - Array of MenuItems
   */
  _updateMenuItemPaddingRight(menuItems) {
    if (menuItems && menuItems.length > 0) {
      const menuItemsWithItemsOnRight = menuItems.map(
        menuItem => menuItem.rightIcons,
      );
      this._maxPaddingRight = menuItemsWithItemsOnRight.reduce((a, b) =>
        Math.max(a, b),
      );
      menuItems.forEach(menuItem => {
        menuItem._paddingRight = this._maxPaddingRight;
      });
    }
  }

  /**
   * Handle all the events bubbled from children, keyboard and document.
   *
   * @function handleEvent
   * @param {Event} event - an event
   */
  handleEvent(event) {
    switch (event.type) {
      case 'keydown':
        this._handleKeyboard(event);
        break;

      case 'eui-menuItem:click':
        this._handleMenuItemClick(event);
        break;

      case 'eui-menuItem:change':
        this._handleMenuItemChange(event);
        break;

      case 'mousedown':
      case 'wheel':
      case 'resize':
      case 'touchend':
      case 'scroll':
      case 'touchmove':
        this._closeMenuWhenClickedOutside(event);
        break;

      case 'slotchange':
        this._handleSlotChange();
        break;
    }
  }

  /**
   * Handle eui-menuItem:click event
   *
   * @function _handleMenuItemClick
   * @param {Event} event - eui-menuItem:click event
   */
  _handleMenuItemClick = event => {
    if (this.type === 'multi') {
      this.bubble('eui-menu:click', { menuItems: this.value });
    } else {
      // action or single
      this.bubble('eui-menu:click', { menuItems: [event.target] });
      this.show = false;
    }
  };

  /**
   * Handle all keyboard control keys.
   * @function _handleKeyboard
   * @param {Event} event - keyboard key event
   */
  _handleKeyboard(event) {
    const activeElement = this._activeElement();
    const menuItemIndex = this._menuItemIndex(activeElement);
    switch (event.key) {
      case this.ARROW_UP_KEY:
        event.preventDefault();
        this._setFocus(menuItemIndex - 1, 'up');
        this._setScrollBarHeight(this.focusedChild);
        break;

      case this.ARROW_DOWN_KEY: {
        event.preventDefault();
        if (menuItemIndex < this.filteredMenuItems.length - 1) {
          this._setFocus(menuItemIndex + 1, 'down');
          this._setScrollBarHeight(this.focusedChild);
        }
        break;
      }

      case this.ESCAPE_KEY:
        event.preventDefault();
        // eslint-disable-next-line no-case-declarations
        const emittedEvent = this.bubble(
          'eui-menu:hidden',
          {},
          { cancelable: true },
        );
        if (!emittedEvent.defaultPrevented) {
          this.show = false;
        }
        break;
    }
  }

  /**
   * Handle the response to change event from select all item when indeterminate
   *
   * @function _selectAllIndeterminateChange
   * @param {Element} selectAllEl
   * @private
   */
  _selectAllIndeterminateChange = selectAllEl => {
    let clearSelection = false;
    const items = this.menuItems;
    items.forEach(menuItem => {
      if (!menuItem.disabled && menuItem.selected) {
        clearSelection = true;
        menuItem.setSelectedSilently(false);
      }
    });
    if (clearSelection) {
      // Just need to check for any selected + disabled items
      const numSelected = this.value.length;
      if (numSelected === 0) {
        selectAllEl.setSelectedSilently(false);
      } else {
        // Ensure state is correct as both selected and indeterminate could exist
        selectAllEl.setSelectedSilently(false, true);
      }
    } else {
      this._setMenuItemState(true);
      // Just check for any unselected disabled items
      if (items.length === this.value.length) {
        selectAllEl.setSelectedSilently(true);
      }
    }
  };

  /**
   * Handle the eui-menuItem:click event.
   *
   * Action menu
   * --------------------------------------------
   * bubble eui-menu:click and close menu.
   *
   * Single select menu
   * --------------------------------------------
   * filter get all menu items,
   * deselect other menu items,
   * bubble eui-menu:change and hide the menu.
   *
   * Multi select menu
   * --------------------------------------------
   * filter all selected menu items,
   * bubble eui-menu:click
   * bubble eui-menu:change
   *
   * @function _handleMenuItemChange
   * @param {Event} event
   * @private
   */
  _handleMenuItemChange = event => {
    switch (this.type) {
      case 'single':
        // Won't hit if item selected 2nd time, no change event received
        if (event.target.selected) {
          this._deselectOtherMenuItems(event.target, this.menuItems);
          // At this point target and value getter will be equal, getter has more overhead than accessing target
          this.bubble('eui-menu:change', { menuItems: [event.target] });
          this.show = false;
        } else if (this.value.length === 0) {
          // Hit when menu item selection prop change is unselected without clicking, programmatically clearing selection
          this.bubble('eui-menu:change', { menuItems: [event.target] });
        }
        // else hit when data prop changes at next level, can cause menu item selection prop to change due to lit rendering
        break;

      case 'multi':
        if (event.target.id === 'select-all') {
          const selectAllEl = event.target;
          if (selectAllEl.indeterminate) {
            this._selectAllIndeterminateChange(selectAllEl);
          } else if (selectAllEl.selected) {
            this._setMenuItemState(true);
            // If disabled + unselected exist, correct select all to indeterminate state
            if (this.menuItems.length !== this.value.length) {
              selectAllEl.setSelectedSilently(false, true);
            }
          } else {
            this._setMenuItemState(false);
            // Just need to check for any remaining selected + disabled items
            const numSelected = this.value.length;
            if (numSelected > 0) {
              event.target.setSelectedSilently(false, true);
            }
          }
        } else if (this.selectAll) {
          this._setSelectAllState();
        }
        this.bubble('eui-menu:change', { menuItems: this.value });
        break;

      default:
        // Bubbles when selection prop is changed on action menuitem or user keyboard action, no clicking
        // TODO is click right event to bubble?
        this.bubble('eui-menu:click', { menuItems: [event.target] });
        this.show = false;
    }
  };

  /**
   * Set the state of a menuItem when by clicking on selectAll menuItem
   *
   * @function _setMenuItemState
   * @private
   * @param {selected} Boolean - sets the selected state of the menuItem
   */
  _setMenuItemState(selected) {
    this.menuItems.forEach(menuItem => {
      if (!menuItem.disabled) {
        menuItem.setSelectedSilently(selected);
      }
    });
  }

  /**
   * slot changed event triggered when a new menuItem is added to the menu.
   * set the state of the "select all" menu-item if it is enabled.
   *
   * @function _handleSlotChange
   * @private
   */
  _handleSlotChange() {
    const menuItems = this.allMenuItems;
    menuItems.forEach(menuItem => {
      menuItem._type = this.type;
      menuItem._paddingLeft = this._maxPaddingLeft;
      menuItem._paddingRight = this._maxPaddingRight;
      menuItem.setAttribute('tabindex', '0');
    });
    if (this.selectAll && this.type === 'multi') {
      this._setSelectAllState();
    }
  }

  /**
   * Set the state of the "select all" menu item, if it is enabled.
   *
   * @function _setSelectAllState
   * @private
   */
  _setSelectAllState = () => {
    const selectAllMenuItem = this.shadowRoot.querySelector('#select-all');
    // Store getter values to avoid unnecessary computation on next call. Dom unchanged.
    const numMenuItems = this.menuItems.length;
    const numSelected = this.value.length;
    if (numMenuItems === numSelected) {
      selectAllMenuItem.setSelectedSilently(true);
    } else if (numSelected > 0 && numMenuItems > numSelected) {
      selectAllMenuItem.setSelectedSilently(false, true);
    } else {
      selectAllMenuItem.setSelectedSilently(false);
    }
  };

  /**
   * Close the menu if either the mousedown | wheel | resize event is
   * triggered when the mouse is outside the menu.
   *
   * @function _closeMenuWhenClickedOutside
   * @param {MouseEvent} event mousedown | wheel | resize
   */
  _closeMenuWhenClickedOutside(event) {
    if (!event.composedPath().includes(this)) {
      const emittedEvent = this.bubble(
        'eui-menu:hidden',
        {},
        { cancelable: true },
      );
      if (!emittedEvent.defaultPrevented) {
        this.show = false;
      }
    }
  }

  /**
   * Get the selected value of the menu.
   * @returns [eui-menu-item]
   */
  get value() {
    return this.menuItems.filter(child => child.selected);
  }

  /**
   * Get the menu items added to the menu
   * @returns [eui-menu-item]
   */
  get menuItems() {
    return [...this.children].filter(item => item.nodeName === 'EUI-MENU-ITEM');
  }

  /**
   * Get all the menu items. This includes menu items added to support the menu. For
   * instance the "select all" menu item is added outside the slotted content and as
   * such should be added to the entire list of menu items.
   * @returns [eui-menu-item]
   */
  get allMenuItems() {
    // get any menu-items added outside the slot
    const extraMenuItems = [...this.menu.children].filter(
      item => item.nodeName === 'EUI-MENU-ITEM',
    );
    return [...extraMenuItems, ...this.menuItems];
  }

  /**
   * Get all the filtered menu items. These are the menu items
   * that does not contain '.hidden' class.
   * '.hidden' class is added to hide the items while
   * filtering search results. Fo example, Combobox.
   * @returns [eui-menu-item]
   */
  get filteredMenuItems() {
    return this.allMenuItems.filter(item => !item.classList.contains('hidden'));
  }

  /**
   * Get the menu item which is currently focused.
   *
   * @function _activeElement
   * @private
   */
  _activeElement = () => this.filteredMenuItems[this.focusedChild];

  /**
   * Get the index of the active element in the child list.
   *
   * @function _menuItemIndex
   * @param {Element} activeElement - current active element, element with focus.
   * @private
   */
  _menuItemIndex(activeElement) {
    const focusedChildElementIndex =
      this.filteredMenuItems.indexOf(activeElement);

    if (focusedChildElementIndex === -1) {
      return -1;
    }
    return focusedChildElementIndex;
  }

  /**
   * Set focus on the item with index.
   *
   * @function _setFocus
   * @param {Integer} index - index of the item to set focus on
   * @private
   */
  _setFocus(index, direction) {
    if (index < 0) {
      index = 0;
    }
    // Store getter values to avoid unnecessary computation on next call. Dom unchanged.
    const visibleItems = this.filteredMenuItems;
    if (index === visibleItems.length) {
      return;
    }
    if (visibleItems[index].disabled) {
      if (index === visibleItems.length - 1) {
        index += direction === 'down' ? -1 : 1;
      } else if (index === 0) {
        this.menu.scrollTop = 0;
        index += 1;
      } else {
        index += direction === 'down' ? 1 : -1;
      }
      if (index === -1) {
        return;
      }
      this._setFocus(index);
    } else {
      this.focusedChild = index;

      if (index === 0) {
        this.menu.scrollTop = 0;
      }
      const highlightedMenuItem = visibleItems[index];
      this._unHighlightAllMenuItems();
      highlightedMenuItem.highlight();
      highlightedMenuItem.focus();
    }
  }

  /**
   * set the height of the scroll bar
   * @function _setScrollBarHeight
   * @param {Integer} index - index of the menu item
   * @private
   */
  _setScrollBarHeight = index => {
    // Can be undefined if all items are filtered
    const highlightedMenuItem = this.filteredMenuItems[index];
    if (
      highlightedMenuItem &&
      highlightedMenuItem.offsetHeight + highlightedMenuItem.offsetTop >
        this.menu.offsetHeight
    ) {
      this.menu.scrollTop =
        highlightedMenuItem.offsetTop +
        highlightedMenuItem.clientHeight -
        this.menu.clientHeight;
    }
  };

  /**
   * Un-highlight all menu items.
   * This traverses over all the menu items and sets them to un-highlighted.
   *
   * @function _unHighlightAllMenuItems
   * @private
   */
  _unHighlightAllMenuItems = () => {
    this.allMenuItems.forEach(menuItem => menuItem.unHighlight());
  };

  /**
   * Deselect all menu items, except for the selectedMenuItem.
   *
   * @function _deselectOtherMenuItems
   * @param {Element} selectedMenuItem - selected menu item from the event
   * @param {Array} menuItems - array of all menu items in the menu
   * @private
   */
  _deselectOtherMenuItems(selectedMenuItem, menuItems) {
    if (selectedMenuItem) {
      menuItems.forEach(menuItem => {
        if (menuItem !== selectedMenuItem) {
          menuItem.unHighlight();
          menuItem.setSelectedSilently(false);
        }
      });
    } else {
      this._deselectAllMenuItems(menuItems);
    }
  }

  /**
   * Deselect all menu items.
   *
   * @function _deselectAllMenuItems
   * @param {Array} menuItems - Array of menu Items
   * @private
   */
  _deselectAllMenuItems(menuItems) {
    menuItems.forEach(menuItem => {
      menuItem.unHighlight();
      menuItem.setSelectedSilently(false);
    });
  }

  /**
   * Called when the menu is connected to the DOM.
   * Adds the document listeners if show prop is set to true
   *
   * @function didConnect
   */
  didConnect() {
    this.addEventListener('eui-menuItem:left-item-count-update', () => {
      this._updateMenuItemPaddingLeft(this.allMenuItems);
    });

    this.addEventListener('eui-menuItem:right-item-count-update', () => {
      this._updateMenuItemPaddingRight(this.allMenuItems);
    });
    if (this.show) {
      this._addDocumentListeners();
    }
  }

  /**
   * Called when the menu is disconnected from the DOM.
   * Removes all document listeners.
   *
   * @function didDisconnect
   */
  didDisconnect() {
    this._removeDocumentListeners();
  }

  /**
   * Add the document listeners; "mousedown","wheel",
   * "resize" and "scroll"
   * @function _addDocumentListeners
   * @private
   */
  _addDocumentListeners() {
    document.addEventListener('mousedown', this);
    document.addEventListener('wheel', this);
    window.addEventListener('resize', this);
    document.addEventListener('touchend', this);
    // start of scroll event for iOS
    document.addEventListener('touchmove', this);
    // end of scroll event for iOS
    // and
    // start/end of scroll event for other browsers
    document.addEventListener('scroll', this);
    // On detecting wheel event
    // track the position of Menu component only on Firefox browser
    // eslint-disable-next-line no-undef
    if (navigator.userAgent.indexOf('Firefox') !== -1) {
      this.addEventListener('wheel', this._trackWheelPosition);
    }
  }

  /**
   * Remove the document listeners; "mousedown" and "wheel".
   *
   * @function _removeDocumentListeners
   * @private
   */
  _removeDocumentListeners() {
    document.removeEventListener('mousedown', this);
    document.removeEventListener('wheel', this);
    window.removeEventListener('resize', this);
    document.removeEventListener('touchend', this);
    document.removeEventListener('touchmove', this);
    document.removeEventListener('scroll', this);
    this.removeEventListener('wheel', this._trackWheelPosition);
    this._stopTrackingWheelPosition();
  }

  /**
   * Track wheel position on FireFox
   * @method _trackWheelPosition
   * @private
   */
  _trackWheelPosition = () => {
    let curPosition = null;
    if (!this.trackPositionInterval) {
      if (!this.menuIcon) {
        this.trackPositionInterval = setInterval(() => {
          // event.target gives incorrect node when menu is inside shadowdom.
          // use this.parentElement to get the dimensions of menu component parent
          // https://jira-oss.seli.wh.rnd.internal.ericsson.com/browse/CDS-8799
          curPosition = this.parentElement.getBoundingClientRect();
          if (
            this._parentElementPosition.y !==
            curPosition.top + curPosition.height
          ) {
            this.bubble('eui-menu:hidden', {}, { cancelable: true });
            this.show = false;
          }
        }, 1000 / 24);
      } else {
        this.trackPositionInterval = setInterval(() => {
          curPosition = this.menuIcon.getBoundingClientRect();
          if (this.menuIconPosition.y !== curPosition.y) {
            this.show = false;
          }
        }, 1000 / 24);
      }
    }
  };

  /**
   * Stop tracking wheel position on Firefox
   * @method _stopTrackingWheelPosition
   * @private
   */
  _stopTrackingWheelPosition = () => {
    if (this.trackPositionInterval) {
      clearInterval(this.trackPositionInterval);
      this.trackPositionInterval = null;
    }
  };

  /**
   * Changed props are handled here.
   * The props position, show and type are handled
   *
   * position
   * --------------------------------------------------------------
   * position can be an Event or an Object.
   * If the position is set as an Event (type = contextmenu)
   * we must then extract the x,y coordinates.
   *
   * If the position is set as an Event ( type != contextmenu)
   * we must then extract the x,y,width and height from the
   * event.target bounding client rect. This is the way the
   * position is set for the menu when the menu must behave
   * like it's attached to a component (button, more dropdown etc.)
   *
   * Otherwise an Object of type {x, y, height, width} is used.
   *
   * show
   * --------------------------------------------------------------
   * Show and hide the menu, remove document event listeners and
   * calculate position so the menu is not overflowing the
   * boundaries of the browser window.
   *
   * type
   * --------------------------------------------------------------
   * When the type is changed it must set the new value on all it's
   * children (eui-menu-item's). It deselects all
   * selected items when the type is changed.
   *
   * @function didChangeProps
   * @param {Map} changedProps - changed props
   */
  didChangeProps(changedProps) {
    if (changedProps.has('position')) {
      if (this.position.type === 'contextmenu') {
        const temp = { x: this.position.x, y: this.position.y };
        this.position = { ...temp };
      } else if (this.position.type && this.position.currentTarget) {
        // eslint-disable-next-line object-curly-newline
        this.menuIcon = this.position.currentTarget;
        this.menuIconPosition = this.menuIcon.getBoundingClientRect();
        const { x, y, height, width } =
          this.position.currentTarget.getBoundingClientRect();
        // eslint-disable-next-line object-curly-newline
        this.position = { x, y: y + height, height, width };
      }
    }

    if (changedProps.has('show')) {
      if (this.show) {
        this._parentElementPosition = { ...this.position };
        this._positionMenu();
        this._addDocumentListeners();
        this.menu.focus();
        this.focusedChild = -1;
      } else {
        this._removeDocumentListeners();
        this._unHighlightAllMenuItems();
      }
    }

    if (changedProps.has('type')) {
      // eslint-disable-next-line prefer-destructuring
      const menuItems = this.menuItems;
      if (menuItems.length > 0) {
        menuItems.forEach(menuItem => {
          menuItem._type = this.type;
        });
        this._deselectAllMenuItems(menuItems);
      }
    }
  }

  /**
   * Get the width of the menu
   */
  get menuWidth() {
    return this.offsetWidth;
  }

  /**
   * Get the browser window width
   */
  get browserWidth() {
    return window.innerWidth;
  }

  /**
   * Position Menu based on available space.
   * This ensures the menu will not overflow the browser's
   * window boundaries
   * The function first calculates the "overshoot" value of both sides.
   * The overshoot value is the number of pixels the menu exceeds the boundaries of
   * the browser window.
   *
   * Overshoot on right
   * ------------------------------
   * If the menu overshoots the browser window on the right then this value will be +ve.
   * If the menu does not overshoot the browser window on the right then this value will be -ve.
   *
   * Overshoot on left
   * ------------------------------
   * If the menu overshoots the browser window on the left then this value will be -ve.
   * If the menu does not overshoot the browser window on the left then this value will be +ve.
   *
   * If the menu contains very wide menu items that causes the menu to overshoot on both sides
   * (the menu is wider than the browser window), then this function uses the right overshoot and
   * the left overshoot values to determine which side the menu should open. the side which has the
   * least overshoot value is chosen in order to minimize the amount the menu has to be resized.
   * The menu is resized so it will fit withing the boundaries of the browser window.
   *
   * @function _positionMenu
   * @private
   */
  _positionMenu() {
    this.menu.removeAttribute('style');
    this.menu.style.visibility = 'hidden';
    const buffer = 16;

    if (!this.position) {
      // eslint-disable-next-line object-curly-newline
      const { x, y, height, width } = this.getBoundingClientRect();
      // eslint-disable-next-line object-curly-newline
      this.position = { x, y, height, width };
    }

    let { x = 0, y = 0 } = this.position;
    const { width = 0, height = 0 } = this.position;

    // if this value is +ve it means it's overshooting the window width by that amount
    const rightOvershoot = x + this.menuWidth + buffer - this.browserWidth;

    // if this value is -ve it means it over shoots the window width by that amount
    const leftOvershoot = x + width - buffer - this.menuWidth;

    // determine who overshoots the least. The menu will be positioned on that
    // side and resized to fit the window. Right is the desired position.
    let alignRight = true;

    // if right overshoots, then need to determine if it's better to show menu on the left...
    if (rightOvershoot !== leftOvershoot * -1 && rightOvershoot > 0) {
      alignRight = rightOvershoot < leftOvershoot * -1;
    }

    if (alignRight) {
      // should the menu be resized to fit?
      if (rightOvershoot > 0) {
        this.menu.style.width = `${this.menuWidth - rightOvershoot}px`;
      }
    } else {
      let left = x;

      // should the menu be resized to fit?
      if (leftOvershoot < 0) {
        left = buffer;
        this.menu.style.width = `${x + width - buffer}px`;
      } else {
        left = left - this.menuWidth + width;
      }
      x = left;
    }

    let top = y;

    if (top + this.offsetHeight + 8 > window.innerHeight) {
      top -= this.offsetHeight;
      top -= height + 8;
      y = top;
    }
    this.position = {
      x,
      y,
      height,
      width,
    };
    this.menu.style.visibility = null;
  }

  /**
   * Set the position of the menu.
   *
   * @function _contextMenuStyle
   * @private
   * @returns html style for the position of the menu
   */
  _contextMenuStyle() {
    const styleString = `:host{ top: ${this.position.y}px; left: ${this.position.x}px; position: fixed; }`;
    return html`<style>
      ${styleString}
    </style>`;
  }

  render() {
    return html`
      ${this.position != null ? this._contextMenuStyle() : nothing}
      <div class="menu" tabindex="0" @keydown=${this}>
        ${this.selectAll && this.type === 'multi'
          ? html`<eui-menu-item
                ._type=${this.type}
                id="select-all"
                label=${this.selectAll}
                @eui-menuItem:click=${this}
                @eui-menuItem:change=${this}
              ></eui-menu-item>
              <hr />`
          : nothing}
        <slot
          @slotchange=${this}
          @eui-menuItem:click=${this}
          @eui-menuItem:change=${this}
        ></slot>
      </div>
    `;
  }
}

definition('eui-menu', {
  style,
  props: {
    position: { type: Object },
    selectAll: { attribute: true, type: String },
    show: { attribute: true, type: Boolean },
    type: { attribute: true, type: String },
    _maxPaddingLeft: { type: Number, default: 0 },
    _maxPaddingRight: { type: Number, default: 0 },
  },
})(Menu);

export { Menu };
