import { definition, LitComponent, html, styleMap, classMap, ifDefined, nothing } from '@eui/lit-component';
import { Checkbox } from './checkbox.js';

var style = ":host {\n  display: block;\n  cursor: pointer;\n  user-select: none;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n}\n\n:host([disabled]) {\n  opacity: 0.4;\n  cursor: default;\n  pointer-events: none;\n}\n\n.menu-item-selected slot::slotted(*) {\n  --icon-color: var(--white, #FFF);\n}\n\n.menu-item-selected:hover {\n  background: var(--menu-item-background-selected-hover, #0069c2);\n}\n\n.menu-item-selected:focus {\n  background: var(--menu-item-background-selected-hover, #0069c2);\n}\n\n.menu-item.menu-item-selected.highlight {\n  background: var(--menu-item-background-selected-hover, #0069c2);\n}\n\n.menu-item.highlight {\n  background: var(--menu-item-background-hover, #dcdcdc);\n}\n\n.menu-item-selected {\n  color: var(--white, #FFF);\n  background: var(--menu-item-background-selected, #1174E6);\n}\n\n:host(:not(.menu-item-selected):not([disabled]):hover) {\n  background: var(--menu-item-background-hover, #dcdcdc);\n}\n\n:host([disabled]) slot[name=\"left\"]::slotted(*) {\n  cursor: default;\n}\n\n:host([disabled]) slot[name=\"right\"]::slotted(*) {\n  cursor: default;\n}\n\nspan {\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.menu-item {\n  display: flex;\n  align-items: center;\n  padding: var(--space-base, 8px) var(--space-base, 8px) 7px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.menu-item span {\n  flex: auto;\n}\n\n.bold {\n  font-weight: var(--weight-bold, 700);\n}\n \n\nslot[name=\"left\"]::slotted(eui-icon) {\n  margin-right: var(--space-base, 8px);\n  flex: none;\n}\n\nslot[name=\"left\"]::slotted(*:not(eui-icon)) {\n  margin-right: var(--space-base, 8px);\n  width: 16px;\n  height: 16px;\n  flex: none;\n}\n\nslot[name=\"right\"]::slotted(*) {\n  margin-left: var(--space-base, 8px);\n  flex: none;\n}\n\neui-checkbox {\n  pointer-events: none;\n}\n\n";

/* eslint no-console:0 */
/**
 * @property {Boolean} disabled - disable/enable the menu item
 * @property {Boolean} indeterminate - if true sets indeterminate state in item checkbox. Private.
 * @property {String} label - set the label of the menu item
 * @property {Boolean} selected - selected state of the menu item while
 * @property {String} value - set the value of the menu item
 *
 * in either 'single' or 'multi' selection mode
 */
class MenuItem extends LitComponent {
  static get components() {
    return {
      'eui-checkbox': Checkbox,
    };
  }

  constructor() {
    super();
    this.silent = false;
    this.ENTER_KEY = 'Enter';
    this.SPACE_KEY = ' ';
  }

  /**
   * handle all click events.
   *
   * @function handleEvent
   * @param {Event} event - all click events
   */
  handleEvent(event) {
    if (event.type === 'keydown') {
      if (
        !(event.key === this.ENTER_KEY || event.key === this.SPACE_KEY) ||
        this.disabled
      ) {
        return;
      }

      if (this._type === 'multi' && !this.indeterminate) {
        this.setSelectedSilently(!this.selected);
      } else if (this._type === 'single' && !this.selected) {
        this.setSelectedSilently(true);
      }
      // Bubble event for all interactions
      this.bubble('eui-menuItem:change', { menuItem: this });

      event.preventDefault();
      return;
    }

    if (event.type === 'slotchange') {
      event.stopPropagation();
      const count = event.target.assignedNodes().length;
      event.target.assignedNodes().forEach(element => {
        if (element.size) {
          element.size = '16px'; // ensure all icons are 16px square.
        }
      });
      if (event.target.name === 'left') {
        this.bubble('eui-menuItem:left-item-count-update');
        this.shadowRoot.querySelector('span#label').style.paddingLeft = `${
          (this._paddingLeft - count) * 24
        }px`;
      }
      if (event.target.name === 'right') {
        this.bubble('eui-menuItem:right-item-count-update');
        this.shadowRoot.querySelector('span#label').style.paddingRight = `${
          (this._paddingRight - count) * 24
        }px`;
      }
      return;
    }

    if (event.type === 'click') {
      event.stopPropagation();
      if (this.disabled) {
        return;
      }

      if (this._type === 'multi' && this.indeterminate) {
        // Don't change state, let next level decide, cannot assume state of surroundings
        this.bubble('eui-menuItem:change', { menuItem: this });
      } else if (this._type === 'multi') {
        // Don't piggyback on didChangeProps, too slow and will cause race conditions at next level
        this.setSelectedSilently(!this.selected);
        this.bubble('eui-menuItem:change', { menuItem: this });
      } else if (this._type === 'single' && !this.selected) {
        // Don't piggyback on didChangeProps, too slow and will cause race conditions at next level
        this.setSelectedSilently(true);
        this.bubble('eui-menuItem:change', { menuItem: this });
      }
      // else type action or single clicked already in selected state, do nothing.

      this.bubble('eui-menuItem:click');
    }
  }

  /**
   * Highlight a menu item
   *
   * @function highlight
   * @public
   */
  highlight = () => {
    this._highlight = true;
  };

  /**
   * Un-highlight a menu item
   *
   * @function unHighlight
   * @public
   */
  unHighlight = () => {
    this._highlight = false;
  };

  /**
   * get the number of icons in the left slot.
   * @public
   */
  get leftIcons() {
    // Can be called before shadowRoot exists
    if (!this.shadowRoot) {
      return 0;
    }
    return (
      this.shadowRoot.querySelector('slot[name="left"]')?.assignedNodes()
        .length || 0
    );
  }

  /**
   * get the number of icons in the right slot.
   * @public
   */
  get rightIcons() {
    // Can be called before shadowRoot exists
    if (!this.shadowRoot) {
      return 0;
    }
    return (
      this.shadowRoot.querySelector('slot[name="right"]')?.assignedNodes()
        .length || 0
    );
  }

  /**
   * silently set the selected state of the menu item. This is used when
   * the selected state should be changed without dispatching a eui-menuItem:change event.
   * This is primarily used when doing bulk changes to selected state of menu items.
   *
   * @function setSelectedSilently
   * @param {Boolean} state - selected state of the menu item
   * @param {Boolean} indeterminate - if true sets state to indeterminate
   */
  setSelectedSilently = (state = false, indeterminate = false) => {
    if (indeterminate) {
      if (!this.indeterminate) {
        this.indeterminate = true;
        this.silent = true;
      } else if (this.selected) {
        this.silent = true;
      }
      // Correcting invalid state
      this.selected = false;
    } else {
      if (state !== this.selected || this.indeterminate) {
        this.silent = true;
      }
      this.selected = state;
      this.indeterminate = false;
    }
  };

  /**
   * Changed props are handled here.
   * The selected prop is handled.
   * Once it's changed it will bubble
   * a eui-menuItem:change event if
   * selected = true or if selected=false and it is disabled.
   * It will not bubble a eui-menuItem:change event
   * if the selected state was silently set
   *
   * @function didChangeProps
   * @param {Map} changedProps - changed props
   */
  didChangeProps(changedProps) {
    if (changedProps.has('selected') && !this.silent) {
      this.bubble('eui-menuItem:change', { menuItem: this });
    }
    this.silent = false;
  }

  /**
   * Add a click listener to the host when the
   * menuItem is added to the DOM.
   *
   * @function didConnect
   */
  didConnect() {
    this.addEventListener('click', this);
    this.addEventListener('keydown', this);
  }

  /**
   * remove the click lister from the host when the
   * menuItem is removed from the DOM.
   *
   * @function didDisconnect
   */
  didDisconnect() {
    this.removeEventListener('click', this);
    this.removeEventListener('keydown', this);
  }

  /**
   * Determine the amount of padding needed to align menu items if
   * one or more menu items in the menu have an icon on the left of
   * the menu item label. This assumes all icons add to the left
   * slot are 16px square.
   *
   * @function _leftIconCount
   * @param {Number} padding - the number of icons on the left
   * @returns the number of "paddings" needed.
   */
  _leftIconCount(padding) {
    if (this.shadowRoot.querySelector('slot[name="left"]')) {
      return padding === 0 ? padding : padding - this.leftIcons;
    }
    return padding;
  }

  /**
   * Determine the amount of padding needed to align menu items if
   * one or more menu items in the menu have an icon on the right of
   * the menu item label. This assumes all icons add to the right
   * slot are 16px square.
   *
   * @function _rightIconCount
   * @param {Number} padding - the number of icons on the right
   * @returns the number of "paddings" needed.
   */
  _rightIconCount(padding) {
    if (this.shadowRoot.querySelector('slot[name="right"]')) {
      return padding === 0 ? padding : padding - this.rightIcons;
    }
    return padding;
  }

  /**
   * Template for icons slots and item's label
   *
   * @function menuItemContents
   */
  menuItemContents() {
    const styles = {
      'padding-left': `${this._leftIconCount(this._paddingLeft) * 24}px`,
      'padding-right': `${this._rightIconCount(this._paddingRight) * 24}px`,
    };
    return html`
      <slot name="left" @slotchange=${this}></slot>
      <span id="label" style=${styleMap(styles)}>${this.label}</span>
      <slot name="right" @slotchange=${this}></slot>
    `;
  }

  /**
   * The render function calculates the padding on the left of the label.
   * Padding is needed to align the labels of menu items if one or more
   * menu item in a menu have one or more icons in the left slot.
   */
  render() {
    return html`
      <div
        class=${classMap({
          'menu-item': true,
          'menu-item-selected': this.selected && this._type !== 'multi',
          highlight: this._highlight,
        })}
      >
        ${this._type === 'multi'
          ? html`<eui-checkbox
              ?checked=${ifDefined(this.selected)}
              ?indeterminate=${ifDefined(this.indeterminate)}
              name=${ifDefined(this.label)}
            ></eui-checkbox>`
          : nothing}
        ${this.menuItemContents()}
      </div>
    `;
  }
}

definition('eui-menu-item', {
  style,
  props: {
    disabled: { attribute: true, type: Boolean },
    indeterminate: { type: Boolean },
    label: { attribute: true, type: String },
    selected: { attribute: true, type: Boolean },
    value: { attribute: true, type: String },
    _paddingLeft: { type: Number, default: 0 },
    _paddingRight: { type: Number, default: 0 },
    _highlight: { type: Boolean },
    _type: {},
  },
})(MenuItem);

export { MenuItem };
