import { definition, LitComponent, html, classMap } from '@eui/lit-component';

var style = ":host {\n  font-family: var(--font-main, 'Ericsson Hilda', 'Helvetica');\n  display: inline;\n}\n\n:host([action]) .message {\n  background-color: var(--tooltip-background-action, #1174e6);\n  color: var(--white, #fff);\n}\n\n:host([action]) .message.top::after,\n:host([action]) .message.top-end::after {\n  border-top-color: var(--tooltip-background-action, #1174e6);\n}\n\n:host([action]) .message.right::after {\n  border-right-color: var(--tooltip-background-action, #1174e6);\n}\n\n:host([action]) .message.bottom::after,\n:host([action]) .message.bottom-end::after {\n  border-bottom-color: var(--tooltip-background-action, #1174e6);\n}\n\n:host([action]) .message.left::after {\n  border-left-color: var(--tooltip-background-action, #1174e6);\n}\n\n:host([action]) .tooltip {\n  cursor: pointer;\n}\n\n.tooltip {\n  position: relative;\n  cursor: default;\n  display: inline;\n}\n\n.tooltip.dotted {\n  border-bottom: 1px dotted var(--text, #242424);\n}\n\n.tooltip.pointer {\n  cursor: pointer;\n}\n\n.message {\n  background-color: var(--tooltip-background, #4e4e4e);\n  color: var(--tooltip-text, #f2f2f2);\n  opacity: 0;\n  visibility: hidden;\n  font-size: 12px;\n  padding: 7px;\n  line-height: 1.5em;\n  white-space: nowrap;\n  position: fixed;\n  z-index: 100;\n  box-shadow: 0 2px 4px 0 rgba(0,0,0,.1);\n}\n\n.complex_message {\n  white-space: normal;\n}\n\n.message.visible {\n  position: absolute;\n}\n\n.message.hidden, .tooltip:hover .message.hidden {\n  visibility: hidden;\n}\n\n.message.visible, .tooltip:hover .message.visible {\n  opacity: 1;\n  visibility: visible;\n}\n\n.tooltip.show .message {\n  cursor: default;\n  visibility: visible;\n  opacity: 1;\n  transition: opacity 0.18s ease-in-out 0.18s;\n}\n\n.message:hover {\n  opacity: 0;\n}\n\n.message.top {\n  margin-bottom: var(--space-base, 8px);\n}\n\n.message.top.visible {\n  left: 50%;\n  margin-left: -19px;\n  bottom: 100%;\n}\n\n.message.top::after {\n  content: ' ';\n  position: absolute;\n  top: 100%;\n  left: 0;\n  margin-left: 14px;\n  border: 5px solid transparent;\n  border-top-color: var(--tooltip-background, #4e4e4e);\n}\n\n.message.top-end {\n  margin-bottom: var(--space-base, 8px);\n}\n\n.message.top-end.visible {\n  right: 50%;\n  margin-right: -19px;\n  bottom: 100%;\n}\n\n.message.top-end::after {\n  content: ' ';\n  position: absolute;\n  top: 100%;\n  right: 0;\n  margin-right: 14px;\n  border: 5px solid transparent;\n  border-top-color: var(--tooltip-background, #4e4e4e);\n}\n\n.message.right {\n  margin-left: var(--space-base, 8px);\n}\n\n.message.right.visible {\n  left: 100%;\n  top: 50%;\n  margin-top: -14px;\n}\n\n.message.right::after {\n  content: ' ';\n  position: absolute;\n  top: 0;\n  right: 100%;\n  margin-top: 9px;\n  border: 5px solid transparent;\n  border-right-color: var(--tooltip-background, #4e4e4e);\n}\n\n.message.bottom {\n  margin-top: var(--space-base, 8px);\n}\n\n.message.bottom.visible {\n  left: 50%;\n  margin-left: -19px;\n  top: 100%;\n}\n\n.message.bottom::after {\n  content: ' ';\n  position: absolute;\n  top: -1px;\n  left: 13px;\n  margin-top: -10px;\n  border: 6px solid transparent;\n  border-bottom-color: var(--tooltip-background, #4e4e4e);\n}\n\n.message.bottom-end {\n  margin-top: var(--space-base, 8px);\n}\n\n.message.bottom-end.visible {\n  right: 50%;\n  margin-right: -19px;\n  top: 100%;\n}\n\n.message.bottom-end::after {\n  content: ' ';\n  position: absolute;\n  top: -1px;\n  right: 13px;\n  margin-top: -10px;\n  border: 6px solid transparent;\n  border-bottom-color: var(--tooltip-background, #4e4e4e);\n}\n\n.message.left {\n  margin-right: var(--space-base, 8px);\n}\n\n.message.left.visible {\n  right: 100%;\n  top: 50%;\n  margin-top: -14px;\n}\n\n.message.left::after {\n  content: ' ';\n  position: absolute;\n  top: 0;\n  left: 100%;\n  margin-top: 9px;\n  border: 5px solid transparent;\n  border-left-color: var(--tooltip-background, #4e4e4e);\n}\n";

const TOOLTIP_Y_SHIFT = 5;
const TOOLTIP_X_SHIFT = 19;
const TOOLTIP_X_PADDING = 5;
const TOOLTIP_Y_PADDING = 5;

const positionMatcher = {
  'bottom-end': {
    check(componentRect, tooltipRect) {
      return (
        window.innerHeight >
          componentRect.top +
            componentRect.height +
            tooltipRect.height +
            TOOLTIP_Y_PADDING &&
        componentRect.left +
          componentRect.width / 2 -
          TOOLTIP_X_SHIFT -
          tooltipRect.width >
          0
      );
    },
    next: 'bottom',
  },
  bottom: {
    check(componentRect, tooltipRect) {
      return (
        window.innerHeight >
          componentRect.top +
            componentRect.height +
            tooltipRect.height +
            TOOLTIP_Y_PADDING &&
        window.innerWidth >
          componentRect.left +
            componentRect.width / 2 -
            TOOLTIP_X_SHIFT +
            tooltipRect.width
      );
    },
    next: 'right',
  },
  right: {
    check(componentRect, tooltipRect) {
      return (
        window.innerWidth >
          componentRect.left +
            componentRect.width +
            tooltipRect.width +
            TOOLTIP_Y_SHIFT &&
        window.innerHeight >
          componentRect.top +
            componentRect.height / 2 +
            tooltipRect.height -
            TOOLTIP_X_PADDING
      );
    },
    next: 'left',
  },
  left: {
    check(componentRect, tooltipRect) {
      return (
        componentRect.left - TOOLTIP_Y_SHIFT - tooltipRect.width > 0 &&
        window.innerHeight >
          componentRect.top +
            componentRect.height / 2 +
            tooltipRect.height +
            TOOLTIP_X_PADDING
      );
    },
    next: 'top-end',
  },
  'top-end': {
    check(componentRect, tooltipRect) {
      return (
        componentRect.top - tooltipRect.height - TOOLTIP_Y_PADDING > 0 &&
        componentRect.left +
          componentRect.width / 2 -
          tooltipRect.width +
          TOOLTIP_X_SHIFT >
          0
      );
    },
    next: 'top',
  },
  top: {
    check(componentRect, tooltipRect) {
      return (
        componentRect.top - tooltipRect.height - TOOLTIP_Y_PADDING > 0 &&
        window.innerWidth >
          componentRect.left +
            componentRect.width / 2 +
            tooltipRect.width +
            TOOLTIP_X_SHIFT
      );
    },
    next: 'bottom-end',
  },
};

/**
 * Calculates a client rect of an element including parents clipping
 *
 * @param element
 * @typedef {Object} ClientRect - creates a new type named 'ClientRect'
 * @property {number} bottom - bottom position of the client rect
 * @property {number} height - height of client rect
 * @property {number} left - left position of the client rect
 * @property {number} right - right position of the client rect
 * @property {number} top - top position of the client rect
 * @property {number} width - width of the client rect
 * @property {boolean} isClipped - is the client rect clipped
 * @return {ClientRect}
 */
function getClippedBoundingRect(element) {
  const initialRect = element.getBoundingClientRect();
  const clippedRect = {
    bottom: initialRect.bottom,
    height: initialRect.height,
    left: initialRect.left,
    right: initialRect.right,
    top: initialRect.top,
    width: initialRect.width,
  };
  let parent = element;
  let parentRect;
  let clippedWidth;
  let clippedHeight;
  let clippedX;
  let clippedY;

  do {
    // Break out if any parent element is using fixed or absolute css
    // as properties of next level are not representative
    // TODO need a better way of determining when to skip as it should not know anything about
    //  external libs, offending css is in the :host
    if (parent.tagName === 'EUI-DIALOG') break;
    if (parent.tagName === 'EUI-TILE' && parent.maximize) break;
    if (parent.parentElement) {
      parent = parent.parentElement;
    } else if (parent.parentNode && parent.parentNode.host) {
      parent = parent.parentNode.host;
    } else {
      break;
    }

    parentRect = parent.getBoundingClientRect();

    // skip inline elements
    if (parentRect.width >= 1 && parentRect.height >= 1) {
      clippedWidth =
        clippedRect.width +
        clippedRect.left -
        parentRect.left -
        parentRect.width;
      clippedHeight =
        clippedRect.height +
        clippedRect.top -
        parentRect.top -
        parentRect.height;
      clippedX = parentRect.left - clippedRect.left;
      clippedY = parentRect.top - clippedRect.top;

      if (clippedWidth > 0) {
        clippedRect.width -= clippedWidth;
      }

      if (clippedHeight > 0) {
        clippedRect.height -= clippedHeight;
      }

      if (clippedX > 0) {
        clippedRect.width -= clippedX;
        clippedRect.left += clippedX;
      }

      if (clippedY > 0) {
        clippedRect.height -= clippedY;
        clippedRect.top += clippedY;
      }
    }
  } while (parent);

  clippedRect.isClipped =
    initialRect.width !== clippedRect.width ||
    initialRect.height !== clippedRect.height ||
    initialRect.left !== clippedRect.left ||
    initialRect.top !== clippedRect.top;

  return clippedRect;
}

/**
 * @license
 * COPYRIGHT Ericsson 2022
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 */

const DEFAULT_POSITION = 'bottom';

/**
 * @property {Boolean} dotted - sets the hovered item to be underlined dotted
 * @property {String} message - message displayed by the tooltip
 * @property {String} position - sets the position of the tooltip
 * @property {String} visible - defines display mode of the tooltip, can be (null|'always'|'never')
 * @property {Number} delay - sets the delay time when the tooltip should be visible,
 * if not set will be visible after 500ms, time unit is millisecond
 * @property {Boolean} action - sets the tooltip background to blue and
 * cursor to pointer for elements that perform an action when clicked
 */
class Tooltip extends LitComponent {
  /**
   * Returns if visible attribute is set to a meaning value
   *
   * @field
   * @returns {boolean}
   */
  get hasVisible() {
    return this.visible === 'always' || this.visible === 'never';
  }

  /**
   * Go through possible tooltip positions to find any
   * that is not interfering with window borders
   *
   * @method
   * @param componentRect {ClientRect} tooltip orientation element
   * @param tooltip {HTMLElement} tooltip message element
   */
  autoPosition(componentRect, tooltip) {
    let { position } = this;
    const initialPosition = position;
    const tooltipRect = tooltip.getBoundingClientRect();

    do {
      if (positionMatcher[position].check(componentRect, tooltipRect)) {
        this._safePosition = position;
        break;
      }

      if (initialPosition === positionMatcher[position].next) {
        break;
      }

      position = positionMatcher[position].next;
    } while (position !== initialPosition);

    this.updatePosition(position, componentRect, tooltip, tooltipRect);
  }

  /**
   * Calculates left and right positions of the tooltip message on the screen
   * Additional constants are from tooltip messages arrow shift
   *
   * @method
   * @param position {string} position for which we are calculating
   * @param componentRect {Object} calculations relative bound rect
   * @param tooltip {HTMLElement} tooltip message element
   * @param tooltipRect {Object} bound rect of the tooltip
   */
  updatePosition(position, componentRect, tooltip, tooltipRect) {
    // If parent is using translate css these two values will not be identical
    // Parent is now position 0 in document and css applied from this point for all children
    // Must translate back live properties to keep tooltip aligned with correct element
    const offsetTopCorrection = tooltipRect.top - tooltip.offsetTop; // Warning offset is a rounded value.
    const offsetLeftCorrection = tooltipRect.left - tooltip.offsetLeft;

    switch (position) {
      case 'top':
        tooltip.style.top = `${
          componentRect.top - tooltipRect.height - 10 - offsetTopCorrection
        }px`;
        tooltip.style.left = `${
          componentRect.left +
          componentRect.width / 2 -
          19 -
          offsetLeftCorrection
        }px`;
        break;
      case 'top-end':
        tooltip.style.top = `${
          componentRect.top - tooltipRect.height - 10 - offsetTopCorrection
        }px`;
        tooltip.style.left = `${
          componentRect.left +
          componentRect.width / 2 -
          tooltipRect.width +
          19 -
          offsetLeftCorrection
        }px`;
        break;
      case 'right':
        tooltip.style.top = `${
          componentRect.top +
          componentRect.height / 2 -
          14 -
          offsetTopCorrection
        }px`;
        tooltip.style.left = `${
          componentRect.left + componentRect.width + 5 - offsetLeftCorrection
        }px`;
        break;
      case 'bottom-end':
        tooltip.style.top = `${
          componentRect.top + componentRect.height + 2 - offsetTopCorrection
        }px`;
        tooltip.style.left = `${
          componentRect.left +
          componentRect.width / 2 -
          tooltipRect.width +
          19 -
          offsetLeftCorrection
        }px`;
        break;
      case 'bottom':
        tooltip.style.top = `${
          componentRect.top + componentRect.height + 2 - offsetTopCorrection
        }px`;
        tooltip.style.left = `${
          componentRect.left +
          componentRect.width / 2 -
          19 -
          offsetLeftCorrection
        }px`;
        break;
      case 'left':
        tooltip.style.top = `${
          componentRect.top +
          componentRect.height / 2 -
          14 -
          offsetTopCorrection
        }px`;
        tooltip.style.left = `${
          componentRect.left - tooltipRect.width - 12 - offsetLeftCorrection
        }px`;
        break;
      default:
        this.updatePosition(
          DEFAULT_POSITION,
          componentRect,
          tooltip,
          tooltipRect,
        );
        /* eslint-disable-next-line no-console */
        console.error(`not supported position ${position} in tooltip`);
    }
  }

  /**
   * lifecycle hook
   *
   * @method didUpgrade
   *
   */
  didUpgrade() {
    this.tooltipWrapper = this.shadowRoot.querySelector('#tooltip-wrapper');
    this.tooltip = this.shadowRoot.querySelector('#tooltip');
    if (!this.hasVisible) {
      this.makeHoverable();
    }
  }

  /**
   * Will remove hooks from the element disabling the normal popup behaviour
   *
   * @method
   */
  makeStatic() {
    this.tooltipWrapper.removeEventListener('mouseenter', this.showTooltip);
    this.tooltipWrapper.removeEventListener('mouseleave', this.hideTooltip);
    document.removeEventListener('wheel', this.hideTooltip);
    this.tooltip.removeAttribute('style');
  }

  /**
   * Will add hooks from the element enabling the normal popup behaviour
   *
   * @method
   */
  makeHoverable() {
    // clear old event listeners
    this.makeStatic();

    this.generateHooks(this.tooltipWrapper, this.tooltip);

    this.tooltipWrapper.addEventListener('mouseenter', this.showTooltip);

    this.tooltipWrapper.addEventListener('mouseleave', this.hideTooltip);
  }

  /**
   * Generate hide/show tooltip hook functions to be used in DOM listeners
   * @private
   * @param tooltipWrapper {HTMLElement} Element to track hover
   * @param tooltip {HTMLElement} Tooltip message element
   */
  generateHooks(tooltipWrapper, tooltip) {
    this.hideTooltip = () => {
      document.removeEventListener('wheel', this.hideTooltip);
      tooltipWrapper.classList.remove('show');
      if (this.showTooltipTimeout) {
        clearTimeout(this.showTooltipTimeout);
        delete this.showTooltipTimeout;
      }
    };

    this.showTooltip = () => {
      if (!this.showTooltipTimeout) {
        this.showTooltipTimeout = setTimeout(() => {
          const componentRect = this.getHostComponentRect();

          if (this.smart && !componentRect.isClipped) {
            return;
          }

          this.autoPosition(componentRect, tooltip);
          tooltipWrapper.classList.add('show');
          delete this.showTooltipTimeout;
        }, this.delay);
      }

      document.addEventListener('wheel', this.hideTooltip);
    };
  }

  /**
   * Get the first tooltip inner element or in other case returns a slot wrapping element
   *
   * @function getHostComponentRect
   * @typedef {Object} ClientRect - creates a new type named 'ClientRect'
   * @property {number} bottom - bottom position of the client rect
   * @property {number} height - height of client rect
   * @property {number} left - left position of the client rect
   * @property {number} right - right position of the client rect
   * @property {number} top - top position of the client rect
   * @property {number} width - width of the client rect
   * @property {boolean} isClipped - is the client rect clipped
   * @return {ClientRect}
   */
  getHostComponentRect() {
    const slotElement = this.shadowRoot.getElementById('content-slot');
    const assignedElements = slotElement
      .assignedNodes()
      .filter(node => node instanceof HTMLElement);

    if (assignedElements.length === 1) {
      return getClippedBoundingRect(assignedElements[0]);
    }

    return getClippedBoundingRect(this);
  }

  /**
   * @method didDisconnect
   * @description lifecycle hook triggers before component will be disconnected
   */
  didDisconnect() {
    document.removeEventListener('wheel', this.hideTooltip);
  }

  /**
   * Hook into the lifecycle callback to trigger the toggle event when the
   * on prop is changed.
   *
   * @function didChangeProps
   * @param {Map} changedProps - previous values of the changed props
   */
  didChangeProps(changedProps) {
    if (this.tooltip && changedProps.has('visible')) {
      if (this.hasVisible) {
        this.makeStatic();
      } else {
        this.makeHoverable();
      }
    }
  }

  /**
   * Render the tooltip component. This function is called each time a
   * prop changes.
   */
  render() {
    const message = () => {
      if (!this.message || this.message.trim() === '') {
        return html`<div
          id="tooltip"
          class=${classMap({
            message: true,
            [this._safePosition || this.position]: true,
            visible: this.visible === 'always',
            hidden: this.visible === 'never',
            complex_message: !this.message,
          })}
        >
          <slot name="message"></slot>
        </div>`;
      }
      return html`<div
        id="tooltip"
        class=${classMap({
          message: true,
          [this._safePosition || this.position]: true,
          visible: this.visible === 'always',
          hidden: this.visible === 'never',
          complex_message: !this.message,
        })}
      >
        ${this.message}
      </div>`;
    };

    return html` <span
      id="tooltip-wrapper"
      class=${classMap({ tooltip: true, dotted: this.dotted })}
    >
      <slot id="content-slot"></slot>
      ${message()}
    </span>`;
  }
}

definition('eui-tooltip', {
  style,
  props: {
    dotted: { attribute: true, type: Boolean },
    message: { attribute: true, type: String, default: '' },
    position: { attribute: true, type: String, default: DEFAULT_POSITION },
    _safePosition: { type: String },
    visible: { attribute: true, type: String },
    delay: { attribute: true, type: Number, default: 500 },
    smart: { attribute: true, type: Boolean },
    action: { attribute: true, type: Boolean },
  },
})(Tooltip);

export { Tooltip };
