import { definition, LitComponent, nothing, html } from '@eui/lit-component';
import { Icon } from '@eui/theme/icon';
import { MenuItem } from './menu-item.js';
import { Menu } from './menu.js';
import './checkbox.js';

var style = ":host {\n  display: inline-block;\n  box-sizing: border-box;\n}\n\n:host(.hide-more-crumbs) .menuCrumbsHolder {\n  display: none;\n}\n\n:host(.hide-trail-crumbs) .trailCrumbsHolder {\n  display: none;\n}\n\n.menuCrumbsHolder,\n.breadcrumb,\n.crumbsHolder {\n  display: flex;\n  align-items: center;\n}\n\nol {\n  list-style: none;\n  display: flex;\n  padding: 0;\n  margin: 0;\n}\n\n:host(.single-crumb) ol {\n  display: grid;\n}\nli {\n  display: inline-flex;\n  align-items: center;\n}\nli a {\n  text-decoration: none;\n  color: var(--gray-text,#6A6A6A);\n  font-size: var(--btn-font-size, 14px);\n  font-weight: 400;\n  cursor: pointer;\n  margin-right: var(--space-base, 8px);\n  border: 1px solid transparent;\n  line-height: 1;\n  margin-top: 4px;\n}\n\n.parentCrumb {\n  white-space: nowrap;\n}\n\nli a:hover {\n  border-bottom: 1px solid var(--gray-text, #6a6a6a);;\n}\n\nol li.current-page {\n  flex: 1;\n  min-width: 0;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\nol li.current-page span {\n  font-size: 18px;\n  font-weight: var(--weight-medium, 500);\n  color: var(--btn-secondary-active,#242424);\n  min-width: 0;\n  white-space: nowrap;\n  display: inline-block;\n  border: 1px solid transparent;\n}\n\n:host(.single-crumb) li.current-page span {\n  display: inline;\n}\n\n.icon {\n  margin-right: var(--space-base, 8px);\n  --icon-color: var(--gray-text, #6A6A6A);\n}\n\n.ellipsis {\n  cursor: pointer;\n}\n\n.breadcrumb-menu {\n  line-height: 1.25;\n}";

/**
 * @license
 * COPYRIGHT Ericsson 2022
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 */

/**
 * @property {object} data - supplies menu data to breadcrumb
 */
class Breadcrumb extends LitComponent {
  static get components() {
    return {
      'eui-menu': Menu,
      'eui-menu-item': MenuItem,
      'eui-icon': Icon,
    };
  }

  /**
   * breadcrumb constructor.
   */
  constructor() {
    super();
    this._crumbsData = null;
    this._handleWindowResize = this._handleWindowResize.bind(this);
    this._handleResize = this._handleResize.bind(this);
    this._isBreadCrumbResized = this._isBreadCrumbResized.bind(this);
    this.initWidth = document.documentElement.clientWidth;
    this._removedTrailCrumbNodes = [];
  }

  /**
   * This method gets executed whenever a crumb link or menu item gets clicked
   * It bubbles a 'eui-breadcrumb:changed' event up with the activeAppPath as event detail
   *
   * @method _emitBreadcrumbChangedEvent
   * @param {String} activeAppPath - the path of the active crumb
   * @private
   */
  _emitBreadcrumbChangedEvent(activeAppPath) {
    this.bubble('eui-breadcrumb:change', { activeAppPath });
  }

  /**
   * This method takes generates updates the breadcrumb data
   * depending on the element that has been clicked on.
   *
   * @method _updateBreadcrumbData
   * @param {Object} targetElement - the target element that has been clicked on
   * @private
   */
  _updateBreadcrumbData(targetElement) {
    const activeAppPath = targetElement.getAttribute('data-path');
    const appNames = activeAppPath.split('/');
    const data = {
      path: activeAppPath,
      elements: {},
    };
    const { elements } = data;
    appNames.forEach(appName => {
      appName = this.getNonContextualPath(appName);

      elements[appName] = {
        label: this.data.elements[appName].label,
      };
    });

    this._emitBreadcrumbChangedEvent(activeAppPath);

    this.data = data;
  }

  /**
   * This method handles the click event emitted
   * by the crumb elements
   *
   * @method handleEvent
   * @param {Event} event - event from the component
   * @public
   */
  handleEvent(event) {
    event.stopPropagation();
    if (event.type === 'click') {
      this._updateBreadcrumbData(event.currentTarget);
    }
  }

  /**
   * This method handles all the resize events and throttles them
   * by handling the resize every 200ms.
   *
   * @method _handleWindowResize
   * @private
   * @returns {function} throttleHandler - function the throttles the resize events
   */
  _handleWindowResize() {
    let lastCallTime = 0;
    const delay = 200;
    const throttleHandler = () => {
      const currentCallTime = new Date().getTime();
      if (currentCallTime - lastCallTime < delay) {
        return;
      }
      lastCallTime = currentCallTime;
      this._handleResize();
    };
    return throttleHandler;
  }

  /**
   * This method pops the top element from the menu
   * by updating the internal _crumbsData object
   *
   * @method _popCrumbFromMenu
   * @private
   */
  _popCrumbFromMenu() {
    const parentCrumbData = this._crumbsData.moreCrumbsData.pop();
    this._crumbsData.trailCrumbsData.push(parentCrumbData);
    this.shadowRoot
      .querySelector('.breadcrumb')
      .prepend(this._removedTrailCrumbNodes[0]);
    if (this._crumbsData.moreCrumbsData.length > 0) {
      const trailCrumbData = this._crumbsData.moreCrumbsData.shift();
      this._crumbsData.trailCrumbsData.unshift(trailCrumbData);
      this.crumbsHolder.prepend(this._removedTrailCrumbNodes[1]);
    }
    this.populateMenu();
  }

  /**
   * This method checks if there is enough space
   * to add the trailing crumb back in from the menu
   *
   * @method _canTrailingCrumbBeAdded
   * @private
   * @returns {boolean} true/false - trailing crumb can be added / trailing crumb cannot be added
   */
  _canTrailingCrumbBeAdded() {
    const { moreCrumbsData } = this._crumbsData;
    if (moreCrumbsData < 1) {
      return false;
    }
    const canCrumbBeAdded =
      this.parentElement.offsetWidth - this.offsetWidth >=
      moreCrumbsData[0].crumbWidth +
        moreCrumbsData[moreCrumbsData.length - 1].crumbWidth;
    return canCrumbBeAdded;
  }

  /**
   * This method pushes the trailcrumb into the menu
   * by updating the internal _crumbsData object
   *
   * @method _pushCrumbIntoMenu
   * @private
   */
  _pushCrumbIntoMenu() {
    if (this._crumbsData.trailCrumbsData.length > 0) {
      const parentCrumbData = this._crumbsData.trailCrumbsData.pop();
      this._crumbsData.moreCrumbsData.push(parentCrumbData);
      if (this._crumbsData.trailCrumbsData.length > 0) {
        const trailCrumbData = this._crumbsData.trailCrumbsData.pop();
        this._crumbsData.moreCrumbsData.unshift(trailCrumbData);
      }
    }
    this.populateMenu();
  }

  /**
   * This method checks if the active crumb is getting truncated
   *
   * @method _isActiveCrumbTruncated
   * @private
   * @returns {boolean} true/false - active crumb is truncated / active crumb is not truncated
   */
  _isActiveCrumbTruncated() {
    if (this._crumbsData.nrCrumbs === 2) {
      const currentPageDimensions = this.currentPage.getBoundingClientRect();
      return (
        currentPageDimensions.left >= 0 &&
        currentPageDimensions.right >=
          (window.innerWidth || document.documentElement.clientWidth)
      );
    }
    return this.currentPage.clientWidth < this.currentPage.scrollWidth;
  }

  /**
   * This method generates new data and updates the component
   * data when clicking on a crumb in the menu
   *
   * @method _handleMenuClick
   * @param {String} activeAppPath - The path of the active crumb
   * @private
   */
  _handleMenuClick(activeAppPath) {
    const appNames = activeAppPath.split('/');
    const data = {
      path: activeAppPath,
      elements: {},
    };
    const { elements } = data;
    appNames.forEach(appName => {
      elements[appName] = {
        label: this.data.elements[appName].label,
      };
    });

    this._emitBreadcrumbChangedEvent(activeAppPath);

    this.data = data;
  }

  /**
   * This method determines if there is no trailcrumbs (and an active crumb)
   * Then it adds a class to handle ellipse on the active crumb text
   *
   * @method _fixEllipsisForActiveCrumb
   * @private
   */
  _fixEllipsisForActiveCrumb() {
    const trailCrumbCount = this._crumbsData.trailCrumbsData.length;
    const arrayIDs = [];
    this._crumbsData.trailCrumbsData.forEach(crumb => {
      arrayIDs.push(crumb.crumbId);
    });
    const visibleCrumbs = this._getVisibleCrumbs();
    visibleCrumbs.forEach(crumb => {
      const crumbID = crumb.getAttribute('data-id');
      if (!arrayIDs.includes(crumbID)) {
        crumb.remove();
      }
    });

    if (!trailCrumbCount && this._crumbsData.activeCrumbData) {
      this.classList.add('single-crumb');
    } else {
      this.classList.remove('single-crumb');
    }
  }

  /**
   * This method handles the resize behaviour
   * when resizing outwards
   *
   * @method _handleResizeOut
   * @private
   */
  _handleResizeOut() {
    // What needs to be done if there are 3 crumbs
    if (this._crumbsData.nrCrumbs > 1 && this._crumbsData.nrCrumbs < 4) {
      if (
        this._crumbsData.nrCrumbs === 2 &&
        this._getVisibleCrumbs().length < 1
      ) {
        if (this._removedTrailCrumbNodes.length > 0) {
          this.classList.add('hide-more-crumbs');
          this.shadowRoot
            .querySelector('.breadcrumb')
            .prepend(this._removedTrailCrumbNodes[0]);
        }
        return;
      }
      if (this._removedTrailCrumbNodes.length < 1) {
        return;
      }

      const visibleCrumbs = this._getVisibleCrumbs();
      if (visibleCrumbs.length > 0) {
        if (this._crumbsData.moreCrumbsData.length === 0) {
          this.classList.add('hide-more-crumbs');
        }
      }

      if (!this._canTrailingCrumbBeAdded()) {
        return;
      }

      this._popCrumbFromMenu();
      return;
    }

    const visibleCrumbs = this._getVisibleCrumbs();
    if (visibleCrumbs.length === 2 && !this._isActiveCrumbTruncated()) {
      return;
    }

    if (!this._canTrailingCrumbBeAdded()) {
      return;
    }
    this._popCrumbFromMenu();
  }

  /**
   * This method handles the resize behaviour
   * when resizing inwards
   *
   * @method _handleResizeIn
   * @private
   */
  _handleResizeIn() {
    // What needs to be done if there are 3 crumbs
    if (this._crumbsData.nrCrumbs > 1 && this._crumbsData.nrCrumbs < 4) {
      const visibleCrumbs = this._getVisibleCrumbs();
      if (visibleCrumbs.length > 0 && this._isActiveCrumbTruncated()) {
        this.classList.remove('hide-more-crumbs');
        if (visibleCrumbs[0]) visibleCrumbs[0].remove();
        if (visibleCrumbs[1]) visibleCrumbs[1].remove();
        this._removedTrailCrumbNodes = [...visibleCrumbs];
        this._pushCrumbIntoMenu();
      }
      return;
    }

    if (!this._isActiveCrumbTruncated()) {
      return;
    }

    const visibleCrumbs = this._getVisibleCrumbs();
    this._removedTrailCrumbNodes = [...visibleCrumbs];
    visibleCrumbs.forEach(crumb => crumb.remove());
    this._pushCrumbIntoMenu();
  }

  /**
   * This method creates an object in the format
   * necessary to be passed into the menu as to
   * create a menu item.
   *
   * @method _getMenuCrumb
   * @param {Object} el - the crumb element used to create menu item
   * @private
   */
  _getMenuCrumb(el) {
    return {
      value: this.data.elements[el.crumbId].label,
      action: () => {
        let dataPath = null;
        this._crumbsData.moreCrumbsData.some(el2 => {
          const flag = el2.crumbId === el.crumbId;
          if (flag) {
            dataPath = el2.crumbPath;
          }
          return flag;
        });
        this._handleMenuClick(dataPath);
      },
    };
  }

  /**
   * This method checks if the resize event is because of
   * a resize inwards
   *
   * @method _isBreadCrumbResizedIn
   * @private
   * @returns {boolean} true/false - is breadcrumb being resized inwards
   */
  _isBreadCrumbResizedIn() {
    const activeCrumbSpan = this.currentPage.querySelector('span');
    return this.currentPage.clientWidth < activeCrumbSpan.offsetWidth;
  }

  /**
   * This method uses the internal _crumbsData to build
   * the data object necessary for the menu component
   * to render the correct menu items
   *
   * @method _getMenuCrumbs
   * @private
   * @return {Array/null} Array containing the Menu item data / null if there is no data
   */
  _getMenuCrumbs() {
    const visibleCrumbs = this._getVisibleCrumbs();
    if (
      visibleCrumbs.length === 0 &&
      this._crumbsData.trailCrumbsData.length > 0
    ) {
      this._crumbsData.trailCrumbsData.forEach(element => {
        if (element.crumbId === this._crumbsData.parentCrumb.crumbId) {
          this._crumbsData.moreCrumbsData.push(element);
        } else {
          this._crumbsData.moreCrumbsData.unshift(element);
        }
      });
    }
    const data = this._crumbsData.moreCrumbsData;

    if (data.length < 1) {
      this.classList.add('hide-more-crumbs');
      const parentCrumb = this.shadowRoot.querySelector(
        'li:not(.current-page)',
      );
      if (parentCrumb) {
        const firstCrumbID = parentCrumb.getAttribute('data-id');
        const parentID = this._crumbsData.parentCrumb.crumbId;
        if (this._crumbsData.nrCrumbs > 1 && parentID !== firstCrumbID) {
          this.shadowRoot
            .querySelector('.breadcrumb')
            .prepend(this._removedTrailCrumbNodes[0]);
        }
        if (this._crumbsData.activeCrumbData.crumbId === firstCrumbID) {
          parentCrumb.remove();
        }
      }
      return null;
    }
    this.classList.remove('hide-more-crumbs');

    const menuData = data.map(el => this._getMenuCrumb(el));
    return menuData;
  }

  /**
   * This method handles the resize event
   * It determines whether to trigger a resize in or out
   *
   * @method _handleResize
   * @private
   */
  _handleResize() {
    if (!this.data) {
      return;
    }

    const { clientWidth } = document.documentElement;
    if (clientWidth === this.initWidth) {
      if (this._isBreadCrumbResizedIn()) {
        this._handleResizeIn();
      } else {
        this._handleResizeOut();
      }
      return;
    }

    if (clientWidth > this.initWidth) {
      this._handleResizeOut();
    } else {
      this._handleResizeIn();
    }

    this.initWidth = clientWidth;
  }

  /**
   * This method checks if the breadcrumb is getting resized
   *
   * @method _isBreadCrumbResized
   * @private
   * @returns {boolean} true/false - is breadcrumb being resized
   */
  _isBreadCrumbResized() {
    const activeCrumbSpan = this.currentPage.querySelector('span');
    return this.currentPage.clientWidth !== activeCrumbSpan.offsetWidth;
  }

  /**
   * This method updates the internal _crumbsData with the visible trailcrumbs
   *
   * @method _updateCrumbsData
   * @private
   */
  _updateCrumbsData() {
    this._fixEllipsisForActiveCrumb();
    const trailCrumbs = this.shadowRoot.querySelectorAll(
      'li:not(.current-page)',
    );
    trailCrumbs.forEach(trailCrumb => {
      this._crumbsData.trailCrumbsData.some(crumbData => {
        const flag = crumbData.crumbId === trailCrumb.dataset.id;
        if (flag) {
          crumbData.crumbWidth = trailCrumb.offsetWidth;
        }
        return flag;
      });
    });

    this._crumbsData.activeCrumbData.crumbWidth = this.currentPage.offsetWidth;
  }

  /**
   * This method returns all crumbs visible that are not the current page
   *
   * @method _getVisibleCrumbs
   * @private
   * @returns {Array|Boolean} - returns array of crumbs visible
   */
  _getVisibleCrumbs() {
    if (!this.crumbsHolder) {
      return false;
    }
    const visibleCrumbs = this.shadowRoot.querySelectorAll(
      'li:not(.current-page)',
    );
    return visibleCrumbs;
  }

  /**
   * Get app path that has non contextual information
   * @param {String} path app path which may contain contextual information
   */
  getNonContextualPath(path) {
    // There are two ways of routing need to be taken care of in contextual breadcrumb:
    // https://euisdk.seli.wh.rnd.internal.ericsson.com/euisdkdocs/#docs?chapter=app_routing
    if (path.includes('?')) {
      path = path.substring(0, path.indexOf('?'));
    } else if (path.includes('!')) {
      path = path.substring(0, path.indexOf('!'));
    }
    return path;
  }

  /**
   * This method returns the crumbs in a standard
   * presentation to be used throughout this component
   *
   * @method _getCrumbData
   * @param {Array} crumbs - Array of crumb Id's
   * @private
   * @returns {object} crumb object containing a crumbId and path
   */
  _getCrumbData(crumbs) {
    const appPath = this.getNonContextualPath(crumbs[crumbs.length - 1]);
    const crumbPath =
      this.data.elements[appPath].contextualPath || crumbs.join('/');
    const crumbId = appPath;
    crumbs.pop();
    return { crumbPath, crumbId };
  }

  /**
   * This method returns the parent crumb in a standard
   * presentation to be used throughout this component
   *
   * @method _getCrumbData
   * @param {Array} crumb - Array of crumb Id's
   * @private
   * @returns {object} parent crumb object containing a crumbId and path
   */
  _getParentData(crumb) {
    const appPath = this.getNonContextualPath(crumb);
    const crumbPath = this.data.elements[appPath].contextualPath || appPath;
    const crumbId = appPath;
    return { crumbPath, crumbId };
  }

  /**
   * This method creates and returns the markup for the active crumb
   * by using the internal _crumbsData
   *
   * @method _buildActiveCrumb
   * @private
   */
  _buildActiveCrumb() {
    if (!this.data) {
      return nothing;
    }
    const data = this._crumbsData;
    const { activeCrumbData } = data;
    if (!activeCrumbData) {
      return nothing;
    }

    const activeLinkLabel = this.data.elements[activeCrumbData.crumbId].label;
    return html`<span aria-current="page">${activeLinkLabel}</span>`;
  }

  /**
   * This method creates and returns the markup for the trailing crumb(s)
   * by using the internal _crumbsData
   *
   * @method _buildTrailCrumbs
   * @private
   */
  _buildTrailCrumbs() {
    if (!this.data) {
      return nothing;
    }
    const data = this._crumbsData;
    const { nrCrumbs } = data;

    if (nrCrumbs < 3) {
      // fix for lit-html trouble
      const trailingCrumb = this._getVisibleCrumbs();
      if (trailingCrumb.length > 0) {
        trailingCrumb.forEach(crumb => {
          if (
            crumb.getAttribute('data-id') ===
            this._crumbsData.parentCrumb.crumbId
          ) {
            this._removedTrailCrumbNodes.push(crumb);
          }
          crumb.remove();
        });
      }
      if (nrCrumbs === 1) this._removedTrailCrumbNodes = [];
    }

    return this._crumbsData.trailCrumbsData.map(crumbData => {
      const { crumbPath, crumbId } = crumbData;
      if (crumbId === this._crumbsData.parentCrumb.crumbId) {
        return nothing;
      }
      const crumbLabel = this.data.elements[crumbId].label;
      return this._generateCrumb(crumbId, crumbPath, crumbLabel);
    });
  }

  /**
   * generates parent crumb
   * @function _parentCrumb
   * @private
   */
  _parentCrumb() {
    if (this._crumbsData) {
      if (this._crumbsData.parentCrumb.crumbId && this.data) {
        const crumbLabel =
          this.data.elements[this._crumbsData.parentCrumb.crumbId].label;
        const parentCrumb = this._generateCrumb(
          this._crumbsData.parentCrumb.crumbId,
          this._crumbsData.parentCrumb.crumbPath,
          crumbLabel,
          true,
        );
        return parentCrumb;
      }
    }
    return nothing;
  }

  /**
   * generates crumb
   * @function _generateCrumb
   * @private
   * @param {String} crumbId - ID of crumb to generate
   * @param {String} crumbPath - Path of crumb to generate
   * @param {String} crumbLabel - Label of crumb to generate
   * @param {Boolean} parentCrumb - If true sets the class of the link for parent crumb
   */
  _generateCrumb(crumbId, crumbPath, crumbLabel, parentCrumb) {
    const link = parentCrumb
      ? html`<a @click="${this}" data-path="${crumbPath}" class="parentCrumb"
          >${crumbLabel}</a
        >`
      : html`<a @click="${this}" data-path="${crumbPath}">${crumbLabel}</a>`;
    return html` <li data-id="${crumbId}">
      ${link}
      <eui-icon name="chevron-right" class="icon"></eui-icon>
    </li>`;
  }

  /**
   * This method generates the internal _crumbsData from the component data.
   *
   * @method _getBreadcrumbsData
   * @private
   */
  _getBreadcrumbsData() {
    if (!this.data) {
      return nothing;
    }

    const { path } = this.data;
    const crumbs = path.split('/');
    const nrCrumbs = crumbs.length;

    // Get active crumb data
    const activeCrumbData = this._getCrumbData(crumbs);

    // Get trail crumbs and more crumbs data
    const trailCrumbsData = [];
    let moreCrumbsData = [];
    let parentCrumb = {};
    if (nrCrumbs > 3) {
      trailCrumbsData.push(this._getCrumbData(crumbs));
      moreCrumbsData = [...crumbs].map(() => this._getCrumbData(crumbs));
      parentCrumb = moreCrumbsData.pop();
      trailCrumbsData.push(parentCrumb);
    } else if (nrCrumbs > 1 && nrCrumbs < 4) {
      parentCrumb = this._getParentData(crumbs[0]);
      while (crumbs.length > 0) {
        trailCrumbsData.unshift(this._getCrumbData(crumbs));
      }
    }

    // creates the object to populate _crumbsData with
    const tmpData = {
      nrCrumbs,
      activeCrumbData,
      trailCrumbsData,
      moreCrumbsData,
      parentCrumb,
    };

    this._crumbsData = { ...tmpData };
    return tmpData;
  }

  /**
   * Lifecycle callback executed when the component is connected to the DOM
   * This is a good place to add the resize event listener
   *
   * @method didConnect
   *
   */
  didConnect() {
    window.addEventListener('resize', this._handleWindowResize(), {
      passive: true,
    });
  }

  /**
   * Renders the breadcrumb component. This function is called each time a
   * prop changes.
   *
   * @method render
   */
  render() {
    this._getBreadcrumbsData();
    return html`
      <div class="breadcrumb">
        ${this._parentCrumb()}
        <div class="menuCrumbsHolder"></div>
        <ol class="crumbsHolder">
          ${this._buildTrailCrumbs()}
          <li class="current-page">${this._buildActiveCrumb()}</li>
        </ol>
      </div>
    `;
  }

  /**
   * method which toggles the menu when the
   * ellipsis icon is clicked
   * @method toggleMenu
   * @param {Event} event - event from the ellipsis icon being clicked
   * @private
   */
  toggleMenu(event) {
    event.preventDefault();
    this.menu.position = event;
    this.menu.show = true;
  }

  /**
   * method which populate the breadcrumb menu.
   * if there is previous menu-items in the menu
   * these are first removed before more added
   *
   * @method populateMenu
   * @private
   */
  populateMenu() {
    this.menu.data = this._getMenuCrumbs();
    const menuItems = this.menu.querySelectorAll('eui-menu-item');
    if (menuItems.length > 0) {
      menuItems.forEach(item => {
        item.remove();
      });
    }
    if (this.menu.data) {
      this.menu.data.reverse();
      this.menu.data.forEach(item => {
        const menuItem = this.createElement('eui-menu-item');
        menuItem.label = item.value;
        menuItem.addEventListener('eui-menuItem:click', item.action);
        this.menu.append(menuItem);
      });
    }
  }

  /**
   * Lifecycle callback executed when the component is rendered to the DOM
   *
   * @method didRender
   * @private
   */
  didRender() {
    if (!this.data) {
      return;
    }

    if (!this.crumbsHolder) {
      this.crumbsHolder = this.shadowRoot.querySelector('.crumbsHolder');
    }

    if (!this.currentPage) {
      this.currentPage = this.crumbsHolder.querySelector('.current-page');
    }

    // checking if the menu doesn't exist
    if (!this.menu) {
      this.menuCrumbsHolder =
        this.shadowRoot.querySelector('.menuCrumbsHolder');
      const ellipsisIcon = this.createElement('eui-icon');
      this.menu = this.createElement('eui-menu');
      this.menu.classList.add('breadcrumb-menu');
      ellipsisIcon.name = 'ellipsis';
      ellipsisIcon.classList.add('icon');
      ellipsisIcon.classList.add('ellipsis');
      ellipsisIcon.addEventListener('click', event => {
        event.stopPropagation();
        this.toggleMenu(event);
      });
      this.menuCrumbsHolder.append(ellipsisIcon);
      this.menuCrumbsHolder.append(this.menu);
      const chevronIcon = this.createElement('eui-icon');
      chevronIcon.name = 'chevron-right';
      chevronIcon.classList.add('icon');
      this.menuCrumbsHolder.append(chevronIcon);
    }

    this._updateCrumbsData();

    if (this._isBreadCrumbResized()) {
      this._handleResize();
    }

    // if 3 crumbs try resizing again
    if (this._crumbsData.nrCrumbs === 3 || this._crumbsData.nrCrumbs === 2) {
      this._handleResize();
    }

    this._fixEllipsisForActiveCrumb();
    this.populateMenu();
  }

  /**
   * Lifecycle hook to hook into the point where the component has been deleted from the DOM.
   * This is a good point to remove the resize event listener.
   *
   * @function didDisconnect
   */
  didDisconnect() {
    window.removeEventListener('resize', this._handleWindowResize(), {
      passive: true,
    });
  }
}

definition('eui-breadcrumb', {
  style,
  props: {
    data: { type: Object },
  },
})(Breadcrumb);

export { Breadcrumb };
