import { definition, LitComponent, html } from '@eui/lit-component';
import { Icon } from '@eui/theme/icon';
import { TextField } from './text-field.js';

/**
 * @file Module to create Calendar component.
 */

/**
 * Class representing an accordion.
 */
class Calendar {

  /**
   * Setup properties.
   * @param {HTMLElement} element - The DOM element to append the component.
   */
  constructor(element) {
    this.dom = {
      calendar: element,
      year: element.querySelector('.year'),
      month: element.querySelector('.month'),
      days: [],
      prevYear: element.querySelector('.head i:nth-child(4)'),
      prevMonth: element.querySelector('.head i:nth-child(1)'),
      nextMonth: element.querySelector('.head i:nth-child(3)'),
      nextYear: element.querySelector('.head i:nth-child(6)'),
      todayBtn: element.querySelector('.set-current-day'),
      body: element.querySelector('table.body')
    };

    this.eng = {
      months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October',
        'November', 'December'],
      days: ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su']
    };

    this.listeners = {
      clickToday: () => this._setToday(),
      clickPrevYear: () => this._setPrevYear(),
      clickPrevMonth: () => this._setPrevMonth(),
      clickNextMonth: () => this._setNextMonth(),
      clickNextYear:() => this._setNextYear()
    };

    this.calendar = {
      year: '',
      month: '',
      days: []
    };
  }

  /**
   * Create component.
   * @public
   */
  init() {
    this._createCalendarBody();
    this.setDataCalendar(new Date());
    this._addEventListeners();
  }

  /**
   * Destroy component.
   * @public
   */
  destroy() {
    this._removeEventListeners();
  }

  /**
   * Add event listeners.
   * @private
   */
  _addEventListeners() {
    this.dom.prevYear.addEventListener('click', this.listeners.clickPrevYear, false);
    this.dom.prevMonth.addEventListener('click', this.listeners.clickPrevMonth, false);
    this.dom.nextMonth.addEventListener('click', this.listeners.clickNextMonth, false);
    this.dom.nextYear.addEventListener('click', this.listeners.clickNextYear, false);

    if (this.dom.todayBtn){
      this.dom.todayBtn.addEventListener('click', this.listeners.clickToday, false);
    }
  }

  /**
   * Remove event listeners.
   * @private
   */
  _removeEventListeners() {
    this.dom.prevYear.removeEventListener('click', this.listeners.clickPrevYear, false);
    this.dom.prevMonth.removeEventListener('click', this.listeners.clickPrevMonth, false);
    this.dom.nextMonth.removeEventListener('click', this.listeners.clickNextMonth, false);
    this.dom.nextYear.removeEventListener('click', this.listeners.clickNextYear, false);

    if (this.dom.todayBtn){
      this.dom.todayBtn.removeEventListener('click', this.listeners.clickToday, false);
    }
  }

  /**
   * Select current day in calendar.
   * @private
   */
  _setToday() {
    this.setDataCalendar(new Date());
  }

  /**
   * Modify year property and call method to update calendar element.
   * @private
   */
  _setPrevYear() {
    const year = parseInt(this.calendar.year, 10) - 1;
    const monthNum = this.eng.months.indexOf(this.calendar.month);

    this.setDataCalendar(new Date(year, monthNum, '1'));
    this.removeAllSelectedDays();
    this.disableUnselectableDays();
  }

  /**
   * Modify month property and call method to update calendar element.
   * @private
   */
  _setPrevMonth() {
    let year = this.calendar.year;
    let monthNum = this.eng.months.indexOf(this.calendar.month);

    // decrement month
    if (monthNum === 0) {
      monthNum = 11;
      year = parseInt(this.calendar.year, 10) - 1;
    } else {
      monthNum -= 1;
    }

    this.setDataCalendar(new Date(year, monthNum, '1'));
    this.removeAllSelectedDays();
    this.disableUnselectableDays();
  }

  /**
   * Modify month property and call method to update calendar element.
   * @private
   */
  _setNextMonth() {
    let year = this.calendar.year;
    let monthNum = this.eng.months.indexOf(this.calendar.month);

    // increment month
    if (monthNum === 11) {
      monthNum = 0;
      year = parseInt(this.calendar.year, 10) + 1;
    } else {
      monthNum += 1;
    }

    this.setDataCalendar(new Date(year, monthNum, '1'));
    this.removeAllSelectedDays();
    this.disableUnselectableDays();
  }

  /**
   * Modify year property and call method to update calendar element.
   * @private
   */
  _setNextYear() {
    const year = parseInt(this.calendar.year, 10) + 1;
    const monthNum = this.eng.months.indexOf(this.calendar.month);

    this.setDataCalendar(new Date(year, monthNum, '1'));
    this.removeAllSelectedDays();
    this.disableUnselectableDays();
  }

  /**
   * Creates the necessary table elements.
   * @private
   */
  _createCalendarBody() {
    // table head
    const thead = document.createElement('thead');
    const trHead = document.createElement('tr');

    for (let d = 0; d < 7; d += 1) {
      const th = document.createElement('th');
      th.innerHTML = this.eng.days[d];
      trHead.appendChild(th);
    }
    thead.appendChild(trHead);
    this.dom.body.appendChild(thead);

    // table body
    const tbody = document.createElement('tbody');


    const numTD = 7;
    // 7 days / week

    const numTR = 6;
    // 6 weeks / month

    let j = 0;
    for (; j < numTR; j += 1) {
      const tr = document.createElement('tr');
      for (let i = 0; i < numTD; i += 1) {
        const td = document.createElement('td');
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    this.dom.body.appendChild(tbody);

    // update the constructor value 'days'
    this.dom.days = this.dom.calendar.querySelectorAll('td');
  }

  /**
   * Fills in the DOM content with this.calendar information.
   * @private
   */
  _setDOMCalendar() {
    const today = this.formatJsDate(new Date()).split('-');
    this.dom.month.innerText = this.calendar.month;
    this.dom.year.innerText = this.calendar.year;
    Array.from(this.dom.days).forEach((dayDOM, i) => {
      const dayValue = this.calendar.days[i];
      if (dayValue !== 0) {
        dayDOM.innerText = dayValue;
        dayDOM.classList.remove('dummy');
        if (+today[0] === +this.calendar.year &&
          +today[1] === this.eng.months.indexOf(this.calendar.month) + 1 &&
          +today[2] === this.calendar.days[i]) {
          dayDOM.innerHTML = '<span class="today">' + dayValue + '</span>';
        }
      } else {
        dayDOM.innerText = '';
        dayDOM.classList.add('dummy');
      }
    });
  }

  /**
   * Fills in this.calendar information and calls a method to update DOM element.
   * @public
   * @param {Date} date
   */
  setDataCalendar(date) {
    const dArray = this.formatJsDate(date).split('-');
    const jsDate = new Date(dArray[0], dArray[1] - 1, 1);
    const lastDayMonth = new Date(dArray[0], dArray[1], 0);
    const daysInMonthNum = lastDayMonth.getDate();
    const dayOfWeekNum = jsDate.getDay();
    // const lastDayOfWeekNum = lastDayMonth.getUTCDay();
    this.calendar.year = dArray[0];
    this.calendar.month = this.eng.months[dArray[1] - 1];

    // create 0's at the head
    const headZeroes = Array.apply(null, {
      length: (dayOfWeekNum + 6) % 7
    }).map(Number.prototype.valueOf, 0);

    // create day numbers != 0
    const numbersInRow = Array.apply(null, {
      length: daysInMonthNum + 1
    }).map(Number.call, Number);
    numbersInRow.shift();

    // create 0's at the tail
    const numZeroes = 42 - (headZeroes.length + numbersInRow.length);
    const tailZeroes = Array.apply(null, Array(numZeroes)).map(Number.prototype.valueOf, 0);

    // concat all the days and add to calendar
    this.calendar.days = headZeroes.concat(numbersInRow, tailZeroes);

    // Updates the values of the DOM with the current calendar data
    this._setDOMCalendar();
  }

  /**
   * Given a JS Date Object return a string in YYYY-MM-DD format.
   * Previously yyyymmdd()
   * @public
   * @param {Date} jsDate - JS Date Object (created with constructor new Date()).
   * @return {string} - Date in format YYYY-MM-DD.
   */
  formatJsDate(jsDate) {
    const mm = jsDate.getMonth() + 1;
    const dd = jsDate.getDate();
    return [jsDate.getFullYear(),
      (mm > 9 ? '' : '0') + mm,
      (dd > 9 ? '' : '0') + dd
    ].join('-');
  }

  /**
   * Given an Object return a string in YYYY-MM-DD format.
   * @public
   * @param {Object} date
   * @param {string} date.year
   * @param {string} date.month
   * @param {string} date.day
   * @return {string} - Date in format YYYY-MM-DD.
   */
  formatDate(date) {
    return (
      date.year + '-' +
      this._getMonthNum(date.month) + '-' +
      this._getDayNum(date.day)
    );
  }

  /**
   * Returns month number with leading zero.
   * @private
   * @param {string} month
   * @return {string}
   */
  _getMonthNum(month) {
    const n = this.eng.months.indexOf(month) + 1;
    return n < 10 ? '0' + n : n;
  }

  /**
   * Returns day of month number with leading zero.
   * @private
   * @param {string} day
   * @return {string}
   */
  _getDayNum(day) {
    return day < 10 ? '0' + day : day;
  }

  /**
   * Unselect all days.
   * @public
   */
  removeAllSelectedDays() {
    Array.from(this.dom.days).forEach((day) => {
      day.classList.remove('selected');
    });
  }

  /**
   * Unselect all days.
   * @public
   * @param {String} maxDate - Maximum date in format YYYY-MM-DD
   */
  setMaximumDate(maxDate){
    const max = maxDate.split('-');
    this.max = {
      day: +max[2],
      month: +max[1],
      year: +max[0]
    };
  }

  /**
   * Unselect all days.
   * @public
   * @param {String} minDate - Minimum date in format YYYY-MM-DD
   */
  setMinimumDate(minDate){
    const min = minDate.split('-');
    this.min = {
      day: +min[2],
      month: +min[1],
      year: +min[0]
    };
  }

  _disableMaximumUnselectableDays(){
    if (!this.max) {
      return;
    }

    Array.from(this.dom.days).forEach(day => {
      if((+this.calendar.year > this.max.year ) ||
        (+this.calendar.year === this.max.year  && +this._getMonthNum(this.calendar.month) > this.max.month) ||
        (+this.calendar.year === this.max.year  && +this._getMonthNum(this.calendar.month) === this.max.month
          && +day.innerText > this.max.day)){
        day.classList.add('disabled');
      }
    });
  }

  _disableMinimumUnselectableDays(){
    if (!this.min) {
      return;
    }

    Array.from(this.dom.days).forEach(day => {
      if((+this.calendar.year < this.min.year ) ||
        (+this.calendar.year === this.min.year  && +this._getMonthNum(this.calendar.month) < this.min.month) ||
        (+this.calendar.year === this.min.year  && +this._getMonthNum(this.calendar.month) === this.min.month
          && +day.innerText < this.min.day)){
        day.classList.add('disabled');
      }
    });
  }

  _clearRestrictionDates(){
    Array.from(this.dom.days).forEach(day => {
      day.classList.remove('disabled');
    });
  }

  disableUnselectableDays(){
    if (this.dom.days) {
      this._clearRestrictionDates();
      this._disableMaximumUnselectableDays();
      this._disableMinimumUnselectableDays();
    }
  }

}

/**
 * @file Module to create Datepicker component.
 * @requires Calendar
 */

/**
 * Class representing an datepicker.
 */
class Datepicker$1 {

  /**
   * Setup properties.
   * @param {HTMLElement} element - The DOM element to append the component.
   */
  constructor(element) {
    this.dom = {
      datepicker: element,
      calendar: element.querySelector('.calendar'),
      button: element.querySelector('.btn, .suffix'),
      input: element.querySelector('input[type="text"]'),
      days: null,
      hiddenInput: element.querySelector('input[type="hidden"]')
    };
    this.listeners = {
      clickOutside: (evt) => this._hideIfClickedOutside(evt),
      clickDay: (evt) => this._selectDay(evt),
      clickButton: () => this._toggleCalendar(),
      clickInput: () => this._showCalendar(),
      onFocus: () => this._showCalendar(),
      changeInput: () => this._onInputChange(),
      keyupInput: (evt) => this._onInputKeyup(evt),
      resetForm: () => this._onResetForm()
    };

    this.calendar = null;
    this.selectedDate = null;
  }

  /**
   * Create component.
   * @public
   */
  init() {
    this.calendar = new Calendar(this.dom.calendar);
    this.calendar.init();
    this.dom.days = this.dom.calendar.querySelectorAll('td');

    // set minimum date limit
    if (this.dom.input.min) {
      this.setMinimumDate(this.dom.input.min);
    }

    // set maximum date limit
    if (this.dom.input.max) {
      this.setMaximumDate(this.dom.input.max);
    }

    // in case of predefined date, validate it
    if (this.dom.input.value && this._isValidDate(this.dom.input.value) && this._isInRange(this.dom.input.value)) {
      this._setSelectedDate();
    } else {
      this.dom.input.value = '';
    }

    this._addEventListeners();
  }

  /**
   * Destroy component.
   * @public
   */
  destroy() {
    this._removeEventListeners();
  }

  /**
   * Add event listeners.
   * @private
   */
  _addEventListeners() {
    this.dom.button.addEventListener('click', this.listeners.clickButton, false);
    Array.from(this.dom.days).forEach(day => {
      day.addEventListener('click', this.listeners.clickDay, false);
    });
    this.dom.input.addEventListener('click', this.listeners.clickInput, false);

    this.dom.input.addEventListener('change', this.listeners.changeInput);
    this.dom.input.addEventListener('keyup', this.listeners.keyupInput);

    this.dom.input.addEventListener('focus', this.listeners.onFocus, false);
    document.addEventListener('click', this.listeners.clickOutside, false);

    if (this.dom.input.form) {
      this.dom.input.form.addEventListener('reset', this.listeners.resetForm);
    }
  }

  /**
   * Remove event listeners.
   * @private
   */
  _removeEventListeners() {
    this.dom.button.removeEventListener('click', this.listeners.clickButton, false);
    Array.from(this.dom.days).forEach(day => {
      day.removeEventListener('click', this.listeners.clickDay, false);
    });

    this.dom.input.removeEventListener('change', this.listeners.changeInput);
    this.dom.input.removeEventListener('keyup', this.listeners.keyupInput);

    document.removeEventListener('click', this.listeners.clickOutside, false);

    if (this.dom.input.form) {
      this.dom.input.form.removeEventListener('reset', this.listeners.resetForm);
    }
  }

  /**
   * Check if date is valid.
   * @private
   * @param {string} dateString
   * @return {boolean} - True if date is valid.
   */
  _isValidDate(dateString) {
    const regEx = /^\d{4}-\d{2}-\d{2}$/;
    // Invalid format
    if (!dateString.match(regEx)) {
      return false;
    }
    const d = new Date(dateString);
    // Invalid date (or this could be epoch), https://stackoverflow.com/a/1353711/4634380
    if (isNaN(d.getTime())) {
      return false;
    }
    return d.toISOString().slice(0, 10) === dateString;
  }

  /**
   * Check if date is in min - max limit.
   * @private
   * @param {string} dateString
   * @return {boolean} - True if date is within range.
   */
  _isInRange(dateString) {
    let result = true;

    if (this.calendar.min && (new Date(dateString) < new Date(this.dom.input.min))) {
      result = false;
    }

    if (this.calendar.max && (new Date(dateString) > new Date(this.dom.input.max))) {
      result = false;
    }

    return result;
  }

  /**
   * Check input date
   * if valid date, update calendar and highlight with CSS;
   * if invalid date, correct date format.
   * @private
   */
  _handleDateChange() {
    const typedInput = this.dom.input.value;
    if (typedInput.length === 10) {
      if (this._isValidDate(typedInput)) {
        this.calendar.setDataCalendar(new Date(typedInput));
        const dateArray = typedInput.split('-');
        this.selectedDate = {
          year: dateArray[0],
          month: dateArray[1],
          day: dateArray[2]
        };
        this._setSelectedDateCSS();
      } else {
        this._correctDateFormat();
      }
    }
  }

  /**
   * Handle input change event (works on blur)
   * if valid date, update calendar and highlight with CSS;
   * if invalid date, correct date format.
   * @private
   */
  _onInputChange() {
    const inputValue = this.dom.input.value;

    // If clear input, remove selected date and styles
    if (!inputValue) {
      this._clearSelectedDate();
      this.dom.hiddenInput.value = null;
      return;
    }

    // If date in input is valid and in the range, set new selected date and styles
    if (this._isValidDate(this.dom.input.value) && this._isInRange(this.dom.input.value)) {
      this._setSelectedDate();
    } else {
      // Otherwise, change to existing selected date
      this.dom.input.value = this.selectedDate ?
        `${this.selectedDate.year}-${this.selectedDate.month}-${this.selectedDate.day}` : '';
    }
  }

  /**
   * Handle keyup event
   * @private
   */
  _onInputKeyup(evt) {
    if (evt.key === 'Escape'){
      this._hideCalendar();
    } else if (this.dom.input.value.length === 10) {

      /*
       * Entered 10 characters -> validate input,
       * if correct change it, otherwise do nothing
       * because it will be set to proper state on blur (onInputChange will work)
       */
      if (this._isValidDate(this.dom.input.value) && this._isInRange(this.dom.input.value)) {
        this._setSelectedDate();
      }
    } else if (this.dom.input.value.length === 0) {

      /*
       * To reproduce this case
       * 1. open empty input
       * 2. type in valid date (becomes selected)
       * 3. remove date by hitting backspace button
       * This is not caught by change event because value doesnt change (empty -> empty),
       * but we need to reset selected date on step 2.
       */
      this._clearSelectedDate();
    }
  }

  _onResetForm() {
    this.dom.hiddenInput.value = null;
  }

  /**
   * Set selected date
   * @private
   */
  _setSelectedDate() {
    this.calendar.setDataCalendar(new Date(this.dom.input.value));
    const dateArray = this.dom.input.value.split('-');
    this.selectedDate = {
      year: dateArray[0],
      month: dateArray[1],
      day: dateArray[2]
    };
    this._setSelectedDateCSS();
  }

  /**
   * Clear selected date
   * @private
   */
  _clearSelectedDate() {
    this.selectedDate = null;
    this.calendar.removeAllSelectedDays();
  }

  /**
   * Set date to today when detecting an invalid date format.
   * @private
   */
  _correctDateFormat() {
    const today = new Date();
    const todayYYYYMMDD = this.calendar.formatJsDate(today).split('-');
    this.dom.input.value = todayYYYYMMDD.join('-');
    this.selectedDate = {
      year: todayYYYYMMDD[0],
      month: todayYYYYMMDD[1],
      day: todayYYYYMMDD[2]
    };
    this.calendar.setDataCalendar(new Date(today));
    this.calendar.removeAllSelectedDays();
    this._setSelectedDateCSS();
  }

  /**
   * Highlight selected date with CSS.
   * @private
   */
  _setSelectedDateCSS() {
    this.calendar.removeAllSelectedDays();

    // convert to number to remove leading zero if exists
    let selectedDay = this.selectedDate ?
      +this.selectedDate.day :
      (new Date(this.dom.input.value)).getDate();

    // convert to string for equality check
    selectedDay = selectedDay.toString();

    Array.from(this.dom.days).some(day => {
      if (day.innerText === selectedDay) {
        day.classList.add('selected');
        return true;
      }
    });
  }

  /**
   * Select clicked day in calendar.
   * @private
   * @param {Event} evt - Click event
   */
  _selectDay(evt) {
    if (!evt.target.classList.contains('dummy')) {
      this.calendar.removeAllSelectedDays();
      this.selectedDate = {
        year: this.calendar.calendar.year,
        month: this.calendar.calendar.month,
        day: evt.target.innerText
      };
      const formattedDate = this.calendar.formatDate(this.selectedDate);
      this.dom.input.value = this.dom.hiddenInput.value = formattedDate;
      if (evt.target.tagName === 'TD') {
        evt.target.classList.add('selected');
      } else {
        evt.target.parentNode.classList.add('selected');
      }
      this.dom.input.dispatchEvent(new Event('change'));
      this._hideCalendar();
    }
  }

  /**
   * Hide calendar.
   * @private
   */
  _hideCalendar() {
    this.dom.calendar.classList.add('closed');
  }

  /**
   * Show calendar.
   * @private
   */
  _showCalendar() {
    this.calendar.disableUnselectableDays();
    this.dom.calendar.classList.remove('closed');
  }

  /**
   * Toggle calendar visibility and validate selected date.
   * @private
   */
  _toggleCalendar() {
    if (this.dom.calendar.classList.contains('closed')) {
      this._showCalendar();
    } else {
      this._hideCalendar();
    }

    const inputValue = this.dom.input.value;
    // not empty input
    if (inputValue) {
      if (this._isValidDate(inputValue) && this._isInRange(inputValue)) {
        this.calendar.setDataCalendar(new Date(inputValue));
        this._setSelectedDateCSS();
      }
    }
  }

  /**
   * Hide calendar when click outside datepicker.
   * @private
   * @param {Event} evt - Click event.
   * @param {HTMLElement} evt.target - Clicked element.
   */
  _hideIfClickedOutside({target}) {
    if (!this.dom.datepicker.contains(target)) {
      this._hideCalendar();
    }
  }

  setMaximumDate(maxDate){
    this.calendar.setMaximumDate(maxDate);
  }

  setMinimumDate(minDate){
    this.calendar.setMinimumDate(minDate);
  }


}

var style = ":host {\n  color: var(--calendar-text-color, #242424);\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n}\n\n.calendar {\n  z-index: 99;\n  width: 260px;\n  padding: var(--space-base, 8px);\n  background: var(--calendar-background, #fff);\n  border: 1px solid var(--calendar-border-color, #878787);\n  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.1);\n  box-sizing: border-box;\n}\n.calendar.opened {\n  display: block;\n}\n.calendar.closed {\n  display: none;\n}\n.calendar .head {\n  padding: var(--space-base, 8px) 0;\n  font-size: 16px;\n  font-weight: var(--weight-bold, 700);\n  text-align: center;\n  text-transform: capitalize;\n  line-height: 1.5;\n  display: flex;\n}\n.calendar .head i {\n  opacity: 0.7;\n  flex: 1;\n}\n.calendar .head i:hover {\n  opacity: 1;\n  cursor: pointer;\n}\n.calendar .head i:nth-child(1),\n.calendar .head i:nth-child(2) {\n  float: left;\n}\n.calendar .head i:nth-child(5),\n.calendar .head i:nth-child(6) {\n  float: right;\n}\n.calendar table.body {\n  width: 100%;\n  table-layout: fixed;\n  padding: 0 var(--space-base, 8px);\n}\n.calendar table.body thead tr {\n  color: var(--calendar-thead-color, #6a6a6a);\n  font-size: 12px;\n  text-align: center;\n  text-transform: uppercase;\n  line-height: 1.5;\n}\n.calendar table.body tbody tr {\n  text-align: center;\n  line-height: 28px;\n}\n.calendar table.body tbody tr td.selected {\n  color: var(--calendar-selected-color, #fff);\n  background: var(--calendar-selected-background, #1174e6);\n}\n.calendar table.body tbody tr td.selected:hover {\n  background: var(--calendar-selected-background-hover, #0069c2);\n}\n.calendar table.body tbody tr td.selected .today {\n  border-bottom-color: var(--calendar-selected-color, #fff);\n}\n.calendar table.body tbody tr td.dummy:hover {\n  background: none;\n  cursor: default;\n}\n.calendar table.body tbody tr td .today {\n  border-bottom: solid 2px var(--calendar-selected-background, #1174e6);\n  font-size: 1.1em;\n  font-weight: var(--weight-bold, 700);\n  padding: 1px 4px;\n}\n.calendar table.body tbody tr td.disabled {\n  opacity: .4;\n  pointer-events: none;\n  cursor: default;\n}\n.calendar table.body tbody tr td:hover {\n  background: var(--calendar-unselected-background-hover, #dcdcdc);\n  cursor: pointer;\n}\n.datepicker {\n  position: relative;\n  display: inline-block;\n}\n.datepicker .input-group {\n  margin-bottom: 0;\n}\n.datepicker .calendar {\n  margin-top: 4px;\n}\n\n.calendar-icon {\n  display: block;\n  margin: auto;\n}\n";

/**
 * @license
 * COPYRIGHT Ericsson 2022
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 */

/**
 * CustomDatepicker is used to customize the internals of the Datepicker supplied by EDS.
 *
 * @class CustomDatepicker
 * @extends EDSDatepicker
 */
class CustomDatepicker extends Datepicker$1 {
  constructor(element) {
    super(element);
    this.dom.input = element.querySelector('eui-text-field[type="text"]');
    this.dom.hiddenInput = element.querySelector('input[type="hidden"]');
  }

  /**
   * Handler for clicking outside the component. The calendar should be hidden if the
   * user clicks outside the component
   *
   * @override _hideIfClickedOutside
   * @param {Event} event
   */
  _hideIfClickedOutside(event) {
    const path = event.path || (event.composedPath && event.composedPath());
    if (path && !path.includes(this.dom.datepicker)) {
      this._hideCalendar();
    }
  }

  /**
   * Wrapper around eds datepicker _correctDateFormat method, trigger extra change event
   */
  _correctDateFormat() {
    super._correctDateFormat();
    this.dom.input.dispatchEvent(new Event('change'));
  }

  /**
   * Check if calendar is open or not
   */
  _isCalendarOpen() {
    return !this.dom.calendar.classList.contains('closed');
  }

  /**
   * Wrapper around eds datepicker setMinimumDate method
   * Updates min variable in eds datepicker
   *
   * @method _setMinimumDate
   * @param {String} minDate
   */
  _setMinimumDate(minDate) {
    this.dom.input.min = minDate;
    super.setMinimumDate(minDate);
  }

  /**
   * Wrapper around eds datepicker setMaximumDate method
   * Updates max variable in eds datepicker
   *
   * @method _setMaximumDate
   * @param {String} maxDate
   */
  _setMaximumDate(maxDate) {
    this.dom.input.max = maxDate;
    super.setMaximumDate(maxDate);
  }
}

/**
 * @property {String} date - date to set in format YYYY-MM-DD
 * @property {String} min - minimum date to set in format YYYY-MM-DD
 * @property {String} max - maximum date to set in format YYYY-MM-DD
 */
class Datepicker extends LitComponent {
  static get components() {
    return {
      'eui-text-field': TextField,
      'eui-icon': Icon,
    };
  }

  /**
   * lifecycle hook
   *
   * @method didUpgrade
   *
   */
  didUpgrade() {
    if (!this.datepicker) {
      this.datepicker = new CustomDatepicker(
        this.shadowRoot.querySelector('.datepicker'),
      );

      this.datepicker._showCalendar = () => {
        if (this.min || this.max) {
          this.datepicker.calendar.disableUnselectableDays();
        }
        this.shadowRoot.querySelector('.calendar').classList.remove('closed');
        this._positionCalender();
        this._addDocumentListeners();
      };

      this.datepicker._hideCalendar = () => {
        this.shadowRoot.querySelector('.calendar').classList.add('closed');
        this._removeDocumentListeners();
      };

      this.datepicker.init();
    }

    if (this.min || this.max) {
      this._setBoundaryDates();
    }
    this.datepicker.dom.input.value = this.date;
    this.datepicker._handleDateChange();
  }

  /**
   * Lifecycle hook didDisConnect
   * Clean event listeners
   */
  didDisConnect() {
    this._removeDocumentListeners();
  }

  /**
   * lifecycle hook
   *
   * @method didChangeProps
   * @param {Map} changedProps - previous values of the props
   */
  didChangeProps(changedProps) {
    if (changedProps.has('date')) {
      if (this._checkDateValue(this.date) || this.date === '') {
        this.datepicker.dom.input.value = this.date;
        if (this.date === '') {
          this.datepicker._clearSelectedDate();
        } else {
          this.datepicker._handleDateChange();
        }
      } else {
        this.date = changedProps.get('date');
      }
    }
    if (changedProps.has('min')) {
      if (this.datepicker._isValidDate(this.min)) {
        this.datepicker._setMinimumDate(this.min);
        this._updateOpenCalendar();
      } else {
        this.min = changedProps.get('min');
      }
    }
    if (changedProps.has('max')) {
      if (this.datepicker._isValidDate(this.max)) {
        this.datepicker._setMaximumDate(this.max);
        this._updateOpenCalendar();
      } else {
        this.max = changedProps.get('max');
      }
    }
  }

  /**
   * Adjust the position of calender widget
   */
  _positionCalender() {
    // get the calender
    const calendar = this.shadowRoot.querySelector('.calendar');
    calendar.style.visibility = 'hidden';

    // get the textField
    const textField = this.shadowRoot.querySelector('eui-text-field');
    const { x, y, height, width } = textField.getBoundingClientRect();
    const position = {
      x,
      y: y + height,
      height,
      width,
    };

    let left = position.x;
    let top = position.y;
    if (left + calendar.offsetWidth + 8 > window.innerWidth) {
      left -= calendar.offsetWidth;
      if (position.width) {
        left += position.width;
      }
      position.x = left;
    }

    if (top + calendar.offsetHeight + 8 > window.innerHeight) {
      top -= calendar.offsetHeight;
      if (position.height) {
        top -= position.height + 8;
      }
      position.y = top;
    }

    calendar.style.position = 'fixed';
    calendar.style.top = `${position.y}px`;
    calendar.style.left = `${position.x}px`;
    calendar.style.visibility = null;
  }

  /**
   * Add the document listeners; "mousedown" and "wheel".
   *
   * @function _addDocumentListeners
   * @private
   */
  _addDocumentListeners() {
    document.addEventListener('mousedown', this);
    document.addEventListener('wheel', this);
    window.addEventListener('resize', this);
  }

  /**
   * Remove the document listeners; "mousedown" and "wheel".
   *
   * @function _removeDocumentListeners
   * @private
   */
  _removeDocumentListeners() {
    document.removeEventListener('mousedown', this);
    document.removeEventListener('wheel', this);
    window.removeEventListener('resize', this);
  }

  /**
   * Checks the format of min and max dates set by developer
   * If these dates are in a valid format, it set's the minimum and
   * maximum dates allowed in the calendar
   *
   * @function _setBoundaryDates
   * @private
   */
  _setBoundaryDates() {
    if (this.min && this.datepicker._isValidDate(this.min)) {
      this.datepicker._setMinimumDate(this.min);
    }
    if (this.max && this.datepicker._isValidDate(this.max)) {
      this.datepicker._setMaximumDate(this.max);
    }
  }

  /**
   * handles change/input events
   *
   * @method handleEvent
   * @param {Object} event
   */
  handleEvent(event) {
    event.stopPropagation();
    const { type: eventType } = event;

    if (
      eventType === 'mousedown' ||
      eventType === 'wheel' ||
      eventType === 'resize'
    ) {
      if (!event.composedPath().includes(this)) {
        this.datepicker._hideCalendar();
      }
    }

    if (eventType === 'change') {
      const { value } = event.target;
      if (this._checkDateValue(value) || value === '') {
        this.date = value;
        this.bubble('eui-datepicker:change', { date: this.date });
      }
    }

    if (eventType === 'keydown') {
      if (event.key === 'Tab' && this.datepicker._isCalendarOpen()) {
        this.datepicker._hideCalendar();
      }
    }
  }

  /**
   * Checks if value entered is a valid date and within the range allowed
   *
   * @method _checkDateValue
   * @param {String} value
   * @private
   */
  _checkDateValue(value) {
    return (
      this.datepicker._isValidDate(value) && this.datepicker._isInRange(value)
    );
  }

  /**
   * If the calendar is open, it calls disableUnselectableDays() so that the current range allowed
   * is displayed - called in didChangeProps if min or max prop has been updated
   *
   * @method _updateOpenCalendar
   * @private
   */
  _updateOpenCalendar() {
    if (this.datepicker._isCalendarOpen()) {
      this.datepicker.calendar.disableUnselectableDays();
    }
  }

  /**
   * public setter function for 'min' prop - will result in call to didChangeProps function
   *
   * @method setMinimumDate
   * @param {String} minDate - should be in format 'YYYY-MM-DD'
   */
  setMinimumDate(minDate) {
    this.min = minDate;
  }

  /**
   * public setter function for 'max' prop - will result in call to didChangeProps function
   *
   * @method setMaximumDate
   * @param {String} maxDate - should be in format 'YYYY-MM-DD'
   */
  setMaximumDate(maxDate) {
    this.max = maxDate;
  }

  /**
   * Render the datepicker component. This function is called each time a
   * prop changes.
   */
  render() {
    return html`
      <div class="datepicker" @keydown=${this}>
        <eui-text-field
          type="text"
          placeholder="YYYY-MM-DD"
          name="datepicker"
          maxlength="10"
          class="with-icon"
          @change=${this}
        >
          <eui-icon
            slot="icon"
            style="display: block; margin: auto"
            class="btn clickable calendar-icon"
            name="calendar"
          ></eui-icon>
        </eui-text-field>
        <div class="calendar closed">
          <div class="head">
            <i>
              <eui-icon name="chevron-left" size="16px"></eui-icon>
            </i>
            <span class="month"></span>
            <i>
              <eui-icon name="chevron-right" size="16px"></eui-icon>
            </i>
            <i>
              <eui-icon name="chevron-left" size="16px"></eui-icon>
            </i>
            <span class="year"></span>
            <i>
              <eui-icon name="chevron-right" size="16px"></eui-icon>
            </i>
          </div>
          <table class="body"></table>
        </div>
        <input type="hidden" name="selectedDay" value="" />
      </div>
    `;
  }
}

definition('eui-datepicker', {
  style,
  props: {
    date: { attribute: true, type: String, default: '' },
    min: { attribute: true, type: String },
    max: { attribute: true, type: String },
  },
})(Datepicker);

export { Datepicker };
