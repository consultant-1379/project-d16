import { definition, LitComponent, html, live } from '@eui/lit-component';

/**
 * @file Module to create Range slider component.
 */

/**
 * Class representing a range slider.
 */
class RangeSlider {

  /**
   * Setup range slider properties.
   * @param {HTMLElement} input - input field.
   */
  constructor(input, props = {}) {

    // user has passed a CSS3 selector string

    if (typeof input === 'string') {
      input = document.querySelector(input);
    }

    this.settings = {
      multiple: input.hasAttribute('multiple'),
      thresholds: input.classList.contains('thresholds'),
      min: Number(input.min) || 0,
      max: Number(input.max) || 100,
      step: Number(input.step) || 1,
      readonly: input.readOnly,
      units: props.units || null,

      classes: {
        input: 'ranger-input',
        container: 'ranger-container',
        lower: 'ranger-lower',
        progress: 'ranger-progress',
        handle: 'ranger-handle',
        tooltip: 'ranger-tooltip',
        track: 'ranger-track',
        multiple: 'ranger-multiple',
        limits: 'range-limits',
        limit: 'range-limit',
        readonly: 'ranger-readonly',
        thresholds: 'ranger-thresholds',
        units: 'ranger-units'
      }
    };

    this.dom = {
      input: input
    };

    this.listeners = {
      down: (evt) => this._down(evt),
      touchstart: (evt) => this._touchStart(evt),
      move: (evt) => this._move(evt),
      up: () => this._up(),
      update: () => this.update(),
      change: () => this._change(),
      reset: () => this._reset(),
      keyUp: (evt) => this._keyActions(evt),
      keyDown: (evt) => {
        if (evt.key === 'ArrowUp' || evt.key === 'ArrowDown'){
          evt.preventDefault();
        }
      }
    };

    this.listeners.scroll = this._throttle(this.listeners.update, 100);
    this.listeners.resize = this._throttle(this.listeners.update, 50);

    this.touch = false;

    this.init();
    this.onInit();
  }

  /**
   * Initialize range slider.
   * @public
   */
  init() {
    if (!this.dom.input.ranger) {

      this.dom.input.ranger = this;

      if (this.settings.multiple) {
        if (this.dom.input.getAttribute('values')) {
          this.dom.input.values = this.dom.input.getAttribute('values').split(',');

          this.dom.input.removeAttribute('values');
        } else {
          this.dom.input.values = [this.settings.min, this.settings.max];
        }
      } else {
        if (!this.dom.input.value) {
          this.dom.input.value = this.settings.max;
        }
      }

      this._render();
    }
  }

  /**
   * Generate custom range slider markup.
   * @private
   */
  _render() {
    const o = this.settings;
    const c = o.classes;

    const container = this._createElement('div', c.container);
    const track = this._createElement('div', c.track);
    const progress = this._createElement('div', c.progress);

    let handle = this._createElement('div', c.handle);
    let tooltip = this._createElement('div', c.tooltip);

    const limitsContainer = this._createElement('div', c.limits);
    const limits = [this._createElement('div', c.limit), this._createElement('div', c.limit)];

    if (o.readonly) {
      container.classList.add(c.readonly);
    }
    if (o.multiple) {
      handle = [this._createElement('div', c.handle), this._createElement('div', c.handle)];
      tooltip = [
        this._createElement('div', c.tooltip),
        this._createElement('div', c.tooltip),
        this._createElement('div', c.tooltip)
      ];

      handle.forEach((node, i) => {
        node.index = i;
        node.tabIndex = 0;
        progress.appendChild(node);
        node.appendChild(tooltip[i]);
      });

      progress.appendChild(tooltip[2]);

      container.classList.add(c.multiple);
      this.dom.input.tabIndex = -1;

      handle[0].classList.add('rsh-min');
      handle[1].classList.add('rsh-max');

      if(o.thresholds){
        const lower = this._createElement('div', c.lower);
        track.appendChild(lower);
        this.dom.lower = lower;
        container.classList.add(c.thresholds);
      }
    } else {
      progress.appendChild(handle);
      handle.appendChild(tooltip);
    }

    track.appendChild(progress);

    limits[0].textContent = this.settings.min;
    limits[1].textContent = this.settings.max;

    if (this.settings.units) {
      const units = [
        this._createElement('div', c.units),
        this._createElement('div', c.units)
      ];
      units[0].textContent = this.settings.units;
      units[1].textContent = this.settings.units;
      limits[0].appendChild(units[0]);
      limits[1].appendChild(units[1]);
    }

    limits.forEach((node, i) => {
      limitsContainer.appendChild(limits[i]);
    });

    track.appendChild(limitsContainer);

    this.dom = { ...this.dom, container, track, progress, handle, tooltip };

    container.appendChild(track);

    if (o.size) {
      container.style['width'] = !isNaN(o.size) ? `${o.size}%` : o.size;
    }

    this.dom.input.parentNode.insertBefore(container, this.dom.input);

    if (this.dom.input.disabled){
      container.classList.add('disabled');
    }

    container.insertBefore(this.dom.input, track);
    this.dom.input.classList.add(c.input);
    if (!this.settings.readonly) {
      this._addEventListeners();
    }
    this.update();
  }

  /**
   * Reset range slider value.
   * @private
   */
  _reset() {

    /*
     * executes after the form has been reset
     * solution from https://stackoverflow.com/a/10319514/4634380
     */
    setTimeout(() => {
      this._setValue(this.dom.input.value);
    }, 0);
  }

  /**
   * Turn position of slider to value.
   * @private
   * @param {Event} evt - Field event.
   */
  _setValueFromPosition(evt) {
    const min = parseFloat(this.settings.min);
    const max = parseFloat(this.settings.max);
    const step = parseFloat(this.settings.step);
    const rect = this.rects;
    const axis = this.touch ? evt.touches[0]['clientX'] : evt['clientX'];
    const pos = axis - this.rects.container['left'];
    const size = rect.container['width'];

    // get the position of the cursor over the bar as a percentage

    const position = pos / size * 100;

    // work out the value from the position

    let value = position * (max - min) / 100 + min;

    // apply granularity (step)

    value = Math.ceil(value / step) * step;

    const index = this.activeHandle.index;

    /*
     * Only update the value if it's different. This allows the onChange event
     * to be fired only on a step and not all the time.
     */
    if (this.settings.multiple) {
      this._setValueMultiple(evt, value, index);
    } else {
      this._setValueSingle(evt, value, index);
    }

    this.dom.input.focus();
  }

  _setValueMultiple(evt, value, index) {
    if (index === 0) {
      value = Math.min(value, this.dom.input.values[1]);
    } else {
      value = Math.max(value, this.dom.input.values[0]);
    }

    if (evt.type === 'mousedown' ||
      (index === 0) && parseFloat(value) !== parseFloat(this.dom.input.values[1]) ||
      (index === 1) && parseFloat(value) !== parseFloat(this.dom.input.values[0]) ) {
      this._setValue(value, index);
    }
  }

  _setValueSingle(evt, value, index) {
    if (evt.type === 'mousedown' || parseFloat(value) !== parseFloat(this.dom.input.value)) {
      this._setValue(value, index);
    }
  }

  /**
   * Update single slider on change.
   * @private
   */
  _change() {
    if (!this.settings.multiple) {
      this.update();
    }
  }

  /**
   * Touch action.
   * @private
   * @param {Event} evt - Field event.
   */
  _touchStart(evt) {
    this._down(evt);
  }

  /**
   * Mousedown / touchstart action.
   * @private
   * @param {Event} evt - Field event.
   */
  _down(evt) {
    evt.preventDefault();

    // show the tip now so we can get the dimensions later

    this.dom.container.classList.add('dragging');
    this._recalculate();
    this.activeHandle = this._getHandle(evt);
    this.activeHandle.classList.add('active');
    this._setValueFromPosition(evt);

    if (this.touch) {
      document.addEventListener('touchmove', this.listeners.move, false);
      document.addEventListener('touchend', this.listeners.up, false);
      document.addEventListener('touchcancel', this.listeners.up, false);
    } else {
      document.addEventListener('mousemove', this.listeners.move, false);
      document.addEventListener('mouseup', this.listeners.up, false);
    }
  }

  /**
   * Mousemove / touchmove action.
   * @private
   * @param {Event} evt - Field event.
   */
  _move(evt) {
    this._setValueFromPosition(evt);
    this.dom.input.dispatchEvent(new Event('input'));
  }

  /**
   * Mouseup / touchend action.
   * @private
   */
  _up() {
    this.dom.container.classList.remove('dragging');

    this.activeHandle.classList.remove('active');
    this.activeHandle = false;

    document.removeEventListener('mousemove', this.listeners.move);
    document.removeEventListener('mouseup', this.listeners.up);
    document.removeEventListener('touchmove', this.listeners.move);
    document.removeEventListener('touchend', this.listeners.up);
    document.removeEventListener('touchcancel', this.listeners.up);

    this.dom.input.dispatchEvent(new Event('change'));
  }

  /**
   * Recache the dimensions.
   * @private
   */
  _recalculate() {
    let handle = [];

    if (this.settings.multiple) {
      this.dom.handle.forEach((node, i) => {
        handle[i] = node.getBoundingClientRect();
      });
    } else {
      handle = this.dom.handle.getBoundingClientRect();
    }

    this.rects = {
      handle: handle,
      container: this.dom.container.getBoundingClientRect()
    };
  }

  /**
   * Update range slider.
   * @public
   */
  update() {
    this._recalculate();

    this.accuracy = 0;

    // detect float

    if (this.dom.input.step.includes('.')) {
      this.accuracy = (this.dom.input.step.split('.')[1] || []).length;
    }

    if (this.settings.multiple) {
      this.dom.input.values.forEach((val, i) => {
        this._setValue(val, i);
      });
    } else {
      this._setValue();
    }
  }

  /**
   * Set new range slider value.
   * @private
   * @param {Number} value - new value.
   * @param {Number} index - slider index.
   */
  _setValue(value, index) {
    const nodes = this.dom;
    const min = parseFloat(this.settings.min);
    const max = parseFloat(this.settings.max);

    if (this.settings.multiple && index === undefined) {
      return false;
    }

    if (value === undefined) {
      value = this.dom.input.value;
    }

    value = parseFloat(value);

    value = value.toFixed(this.accuracy);

    if (value < min) {
      value = min.toFixed(this.accuracy);
    } else if (value > max) {
      value = max.toFixed(this.accuracy);
    }

    // update the value

    if (this.settings.multiple) {
      const values = this.dom.input.values;
      values[index] = value;

      // update the node so we can get the width / height

      nodes.tooltip[index].textContent = value;

      // check if tips are intersecting...

      const intersecting = this._tipsIntersecting();

      if (intersecting) {

        /*
         * Format the combined tooltip.
         * Only show single value if they both match, otherwise show both seperated by a hyphen
         */

        nodes.tooltip[2].textContent = values[0] === values[1] ? values[0] : `${values[0]} - ${values[1]}`;
      }

      // ... and set the className where appropriate

      nodes.container.classList.toggle('combined-tooltip', intersecting);
    } else {
      this.dom.input.value = value;
      nodes.tooltip.textContent = value;
    }

    // set bar size

    this._setPosition(value, index);

    this.onChange();
  }

  /**
   * Set the bar size / position based on the value.
   * @private
   */
  _setPosition() {
    let width;

    if (this.settings.multiple) {
      const start = this._getPosition(this.dom.input.values[0]);
      const end = this._getPosition(this.dom.input.values[1]);

      if(this.settings.thresholds) {
        this.dom.lower.style['width'] = `${start}%`;
      }
      // set the start point of the bar

      this.dom.progress.style['left'] = `${start}%`;

      width = end - start;
    } else {
      width = this._getPosition();
    }

    // set the end point of the bar

    this.dom.progress.style['width'] = `${width}%`;
  }

  /**
   * Calculate offset of slider value.
   * @private
   */
  _getOffset(){
    const trackWidth = this.dom.track.offsetWidth;
    const tooltip = this.dom.tooltip;

    if(!this.settings.multiple){
      const tooltipPadding = parseInt(window.getComputedStyle(tooltip, null).getPropertyValue('padding-left'), 10);

      const rightOffset = Math.round(trackWidth - (this._getPosition() + (tooltip.offsetWidth / 2) - tooltipPadding));
      const leftOffset = Math.round(this._getPosition() - ((tooltip.offsetWidth / 2) - tooltipPadding));

      this._setOffset(this.dom.tooltip, rightOffset, leftOffset);
    } else {

      const inpValues = this.dom.input.values;
      const rangeSize = this._getPosition(inpValues[1]) - this._getPosition(inpValues[0]);
      const tooltipPadding = parseInt(window.getComputedStyle(tooltip[2], null).getPropertyValue('padding-left'), 10);

      const rTrOffset = Math.round(trackWidth - (this._getPosition(inpValues[1]) +
                        (tooltip[1].offsetWidth / 2) - tooltipPadding));

      const lTrOffset = Math.round(this._getPosition(inpValues[0]) - ((tooltip[0].offsetWidth / 2) - tooltipPadding));

      this._setOffset([tooltip[0], tooltip[1]], rTrOffset, lTrOffset);


      const mdRightOffset = Math.round(trackWidth - (this._getPosition(inpValues[0]) +
                            ((tooltip[2].offsetWidth + rangeSize) / 2) - tooltipPadding));

      const mdLeftOffset = Math.round(this._getPosition(inpValues[1]) -
                           (((tooltip[2].offsetWidth + rangeSize) / 2) - tooltipPadding));

      this._setOffset(tooltip[2], mdRightOffset, mdLeftOffset);
    }
  }

  /**
   * Set the offset to element.
   * @private
   * @param {HTMLElement} target - handle element.
   * @param {Number} rightOffset - offset from right.
   * @param {Number} leftOffset - offset from left.
   */
  _setOffset(target, rightOffset, leftOffset){
    const isArray = target instanceof Array;
    const left = isArray ? target[0] : target;
    const right = isArray ? target[1] : target;

    if (rightOffset < 0 || leftOffset < 0){
      if (rightOffset < 0){
        right.style['margin-right'] = Math.abs(rightOffset) + 'px';
      }

      if (leftOffset < 0){
        left.style['margin-right'] = '-' + Math.abs(leftOffset) + 'px';
      }
    } else {
      right.style['margin-right'] = 0;
      left.style['margin-right'] = 0;
    }
  }

  /**
   * Get the position of handle from the value.
   * @private
   * @param {Number} value - current input value.
   * @return {Number} - position of handle element.
   */
  _getPosition(value = this.dom.input.value) {
    const min = parseFloat(this.settings.min);
    const max = parseFloat(this.settings.max);

    return ((value - min) / (max - min)) * 100;
  }

  /**
   * Check whether the tooltips are colliding.
   * @private
   * @return {Boolean} - Tips intersecting or not.
   */
  _tipsIntersecting() {
    const nodes = this.dom.tooltip;
    const a = nodes[0].getBoundingClientRect();
    const b = nodes[1].getBoundingClientRect();

    return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);
  }

  /**
   * Get the correct handle on mousedown / touchstart.
   * @private
   * @param {Event} evt - Field event.
   */
  _getHandle(evt) {
    if (!this.settings.multiple) {
      return this.dom.handle;
    }

    const r = this.rects;
    const distA = Math.abs(evt['clientX'] - r.handle[0]['left']);
    const distB = Math.abs(evt['clientX'] - (r.handle[1]['left'] + 2));
    const handle = evt.target.closest(`.${this.settings.classes.handle}`);

    if (handle) {
      return handle;
    } else {
      if (distA > distB) {
        return this.dom.handle[1];
      } else {
        return this.dom.handle[0];
      }
    }
  }

  /**
   * Destroy range slider and associated events.
   * @public
   */
  destroy() {
    if (this.dom.input.ranger) {

      // remove all event listeners

      this._removeEventListeners();

      // remove the className from the input

      this.dom.input.classList.remove(this.settings.classes.input);

      // kill all nodes

      this.dom.container.parentNode.replaceChild(this.dom.input, this.dom.container);

      // remove the reference from the input

      delete (this.dom.input.ranger);
    }
  }

  /**
   * Callback on change.
   * @public
   */
  onInit() {
    if (this._isFunction(this.settings.onInit)) {
      this.settings.onInit.call(this, this.dom.input.value);
    }
  }

  /**
   * Callback on change.
   * @public
   */
  onChange() {
    if (this._isFunction(this.settings.onChange)) {
      this.settings.onChange.call(this, this.dom.input.value);
    }

    this._getOffset();
  }

  /**
   * Callback on end.
   *_onEnd() {
   * if (this._isFunction(this.settings.onEnd)) {
   *  this.settings.onEnd.call(this, this.dom.input.value);
   * }
   *}
   */


  /**
   * Slider keyboard actions
   * @param {Event} evt - Field event
   * @private
   */
  _keyActions(evt) {
    if (document.activeElement === this.dom.input){
      if (!this.settings.multiple) {
        this.update();
      }
    } else {

      const currMin = parseInt(this.dom.input.values[0], 10);
      const currMax = parseInt(this.dom.input.values[1], 10);

      if (document.activeElement.classList.contains('rsh-min')){
        this._handleMin(currMin, currMax, evt);
        this.update();
      }

      if (document.activeElement.classList.contains('rsh-max')){
        this._handleMax(currMin, currMax, evt);
        this.update();
      }

    }
  }

  _handleMin(currMin, currMax, evt) {
    if (evt.key === 'ArrowRight' || evt.key === 'ArrowUp'){
      if (currMin < currMax){
        this.dom.input.values[0] = currMin + this.settings.step;
      }
    }

    if (evt.key === 'ArrowLeft' || evt.key === 'ArrowDown'){
      if (currMin >= this.settings.min){
        this.dom.input.values[0] = currMin - this.settings.step;
      }
    }
  }

  _handleMax(currMin, currMax, evt) {
    if (evt.key === 'ArrowRight' || evt.key === 'ArrowUp'){
      if (currMax <= this.settings.max){
        this.dom.input.values[1] = currMax + this.settings.step;
      }
    }

    if (evt.key === 'ArrowLeft' || evt.key === 'ArrowDown'){
      if (currMax > currMin){
        this.dom.input.values[1] = currMax - this.settings.step;
      }
    }
  }

  /**
   * Add event listeners.
   * @private
   */
  _addEventListeners() {
    // throttle the scroll callback for performance

    document.addEventListener('scroll', this.listeners.scroll, false);

    if (this.settings.multiple){
      this.dom.handle.forEach((node) => {
        node.addEventListener('keydown', this.listeners.keyDown, false);
        node.addEventListener('keyup', this.listeners.keyUp, false);
      });
    } else {
      this.dom.input.addEventListener('keyup', this.listeners.keyUp, false);
    }

    // throttle the resize callback for performance

    window.addEventListener('resize', this.listeners.resize, false);

    // detect native change event

    this.dom.input.addEventListener('change', this.listeners.change, false);

    if (this.touch) {
      this.dom.container.addEventListener('touchstart', this.listeners.touchstart, false);
    } else {
      this.dom.container.addEventListener('mousedown', this.listeners.down);
    }

    // detect form reset

    if (this.dom.input.form) {
      this.dom.input.form.addEventListener('reset', this.listeners.reset, false);
    }
  }

  /**
   * Remove event listeners.
   * @private
   */
  _removeEventListeners() {

    if (this.touch) {
      this.dom.container.removeEventListener('touchstart', this.listeners.touchstart);
    } else {
      this.dom.container.removeEventListener('mousedown', this.listeners.down);
    }

    if (this.settings.multiple){
      this.dom.handle.forEach((node) => {
        node.removeEventListener('keyup', this.listeners.keyUp, false);
      });
    } else {
      this.dom.input.removeEventListener('keyup', this.listeners.keyUp, false);
    }
    // remove scroll listener

    document.removeEventListener('scroll', this.listeners.scroll);

    // remove resize listener

    window.removeEventListener('resize', this.listeners.resize);

    // remove input listener

    this.dom.input.removeEventListener('change', this.listeners.change);

    // remove form listener

    if (this.dom.input.form) {
      this.dom.input.form.removeEventListener('reset', this.listeners.reset);
    }

    this.listeners = null;
  }

  /**
   * Create DOM element helper.
   * @private
   * @param {String} type - html element type.
   * @param {Object} obj - object.
   * @return {HTMLElement} el - element helper.
   */
  _createElement(type, obj) {
    const el = document.createElement(type);

    if (typeof obj === 'string') {
      el.classList.add(obj);
    } else if (obj === Object(obj)) {
      for (const prop in obj) {
        if (prop in el) {
          el[prop] = obj[prop];
        } else {
          el.setAttribute(el[prop], obj[prop]);
        }
      }
    }

    return el;
  }

  /**
   * Check if function is really a function.
   * @private
   * @param {Function} func - function.
   * @return {Boolean} - true or false.
   */

  _isFunction(func) {
    return func && typeof func === 'function';
  }

  /**
   * Enhance slider performance.
   * @private
   * @param {Function} fn - function.
   * @param {Number} limit - limit.
   * @param {Object} context - object context.
   */
  _throttle(fn, limit, context) {
    let wait;

    return function () {

      context = context || this;

      if (!wait) {
        fn.apply(context, arguments);
        wait = true;

        return setTimeout(function () {
          wait = false;
        }, limit);
      }
    };
  }
}

var style = ":host {\n  display: inline-block;\n  width: 100%;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  font-family: var(--font-main, \"Ericsson Hilda\", \"Helvetica\", \"sans-serif\");\n}\n\n/* Styles adopting from EDS RangeSlider */\n\n* {\n  box-sizing: border-box;\n}\n\n.ranger-container {\n  cursor: pointer;\n  font-size: 12px;\n  margin: 24px 0 16px;\n  display: inline-block;\n  width: 100%;\n}\n\n.ranger-container:first-child {\n  margin: 16px 0;\n}\n\n.ranger-container.disabled {\n  pointer-events: none;\n  opacity: 0.5;\n}\n\n.ranger-multiple .ranger-handle:nth-child(1) {\n  left: -5px;\n}\n\n.ranger-multiple .ranger-handle:nth-child(2) {\n  right: -5px;\n}\n\n.ranger-container .ranger-input:focus + .ranger-track .ranger-handle {\n  outline: 1px solid var(--purple, #a56ebe);\n  outline-offset: 1px;\n}\n\n.ranger-multiple .ranger-input:focus + .ranger-track .ranger-handle.rsh-min,\n.ranger-multiple .ranger-input:focus + .ranger-track .ranger-handle.rsh-max {\n  outline: none;\n}\n\n.ranger-handle:active,\n.ranger-handle:focus {\n  outline: 1px solid var(--purple, #a56ebe);\n  outline-offset: 1px;\n}\n\n.ranger-input {\n  display: none;\n}\n\n.ranger-track {\n  width: 100%;\n  position: relative;\n}\n\n.ranger-track::before {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 4px;\n  width: 100%;\n  background: var(--rs-background, #d4d4d4);\n}\n\n.ranger-progress {\n  height: 4px;\n  width: 100%;\n  background: var(--rs-elements-background, #242424);\n  position: absolute;\n  left: 0;\n  top: 0;\n  transform-origin: 0 0 0;\n  transition: background ease 0.2s;\n}\n\n.ranger-container:hover .ranger-handle,\n.ranger-container:hover .ranger-progress {\n  background: var(--rs-active-background, #0084f0);\n}\n\n.ranger-track .range-limits {\n  display: flex;\n  justify-content: space-between;\n  position: relative;\n  top: 10px;\n  pointer-events: none;\n}\n\n.ranger-track .range-limit {\n  color: var(--rs-text-color, #6a6a6a);\n}\n\n.ranger-handle {\n  box-sizing: border-box;\n  width: 11px;\n  height: 11px;\n  border-radius: 50%;\n  background-color: var(--rs-elements-background, #242424);\n  position: absolute;\n  top: -4px;\n  right: -5px;\n  transition: background ease 0.2s;\n}\n\n.ranger-handle.active {\n  z-index: 10;\n}\n\n.ranger-tooltip {\n  opacity: 0;\n  position: absolute;\n  bottom: calc(100% + 2px);\n  right: 50%;\n  transform: translate3d(50%, 0, 0);\n  padding: 0 7px;\n  color: var(--rs-tooltip-color, #242424);\n  pointer-events: none;\n  text-align: center;\n}\n\n.ranger-progress .ranger-tooltip {\n  z-index: 11;\n  top: auto;\n  bottom: calc(100% + 6px);\n  white-space: nowrap;\n}\n\n.ranger-handle .ranger-tooltip {\n  opacity: 1;\n}\n\n.combined-tooltip.dragging .ranger-progress .ranger-tooltip {\n  display: block;\n}\n\n.combined-tooltip .ranger-handle .ranger-tooltip {\n  opacity: 1;\n}\n\n.combined-tooltip .ranger-tooltip {\n  opacity: 0;\n}\n";

/**
 * @license
 * COPYRIGHT Ericsson 2022
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 */

class CustomRangeSlider extends RangeSlider {
  constructor(element, documentRoot) {
    super(element);
    this.documentRoot = documentRoot;
  }

  /**
   * Override EDS RangeSlider#_keyActions to check against the correct active element.
   */
  _keyActions(evt) {
    const { activeElement } = this.documentRoot;
    if (!this.settings.multiple) {
      this.update();
    } else {
      const currMin = parseInt(this.dom.input.values[0], 10);
      const currMax = parseInt(this.dom.input.values[1], 10);

      if (activeElement.classList.contains('rsh-min')) {
        if (evt.key === 'ArrowRight' || evt.key === 'ArrowUp') {
          if (currMin < currMax) {
            this.dom.input.values[0] = currMin + this.settings.step;
            this.update();
          }
        }

        if (evt.key === 'ArrowLeft' || evt.key === 'ArrowDown') {
          if (currMin >= this.settings.min) {
            this.dom.input.values[0] = currMin - this.settings.step;
            this.update();
          }
        }
      }

      if (activeElement.classList.contains('rsh-max')) {
        if (evt.key === 'ArrowRight' || evt.key === 'ArrowUp') {
          if (currMax <= this.settings.max) {
            this.dom.input.values[1] = currMax + this.settings.step;
            this.update();
          }
        }

        if (evt.key === 'ArrowLeft' || evt.key === 'ArrowDown') {
          if (currMax > currMin) {
            this.dom.input.values[1] = currMax - this.settings.step;
            this.update();
          }
        }
      }
    }
    this.dom.input.dispatchEvent(new Event('change'));
  }
}

/**
 * @property {number} from - start of the number range
 * @property {number} to - end of the number range
 * @property {number} step - step value to move the slider
 * @property {number} value - initial value of the slider
 * @property {boolean} multiple - type of the slider
 * @property {array} values - min and max values for multiple range slider
 * @property {boolean} disabled - disable slider
 */
class Slider extends LitComponent {
  /**
   * @function didChangeProps
   * @description lifecycle hook trigger when component receives a new prop.
   */
  didChangeProps(changedProps) {
    if (changedProps.has('value') || changedProps.has('values')) {
      if (this.multiple) {
        this.edsSlider.dom.input.values = this.values.split(',');
      } else {
        this.edsSlider.dom.input.value = this.value;
      }

      this.edsSlider.update();
    }
  }

  /**
   * If min, max, step, type changed, need to re-generate EDS slider inside didRender
   * since its settings are collected inside the constructor.
   */
  didRender(changedProps) {
    if (
      changedProps.has('from') ||
      changedProps.has('to') ||
      changedProps.has('step') ||
      changedProps.has('multiple') ||
      changedProps.has('disabled')
    ) {
      if (changedProps.has('multiple')) {
        if (this.multiple) {
          this.values = this.values || [this.from, this.to].join(',');
        } else {
          this.values = null;
        }
      } else {
        this.edsSlider.destroy();
      }

      this.edsSlider = new CustomRangeSlider(
        this.shadowRoot.querySelector('input[type=range]'),
        this.shadowRoot,
      );
      this.edsSlider.init();
    }
  }

  /**
   * Lifecycle hook
   * Initialize EDS RangeSlider
   *
   * @method didUpgrade
   *
   * @private
   */
  didUpgrade() {
    if (!this.edsSlider) {
      this.edsSlider = new CustomRangeSlider(
        this.shadowRoot.querySelector('input[type=range]'),
        this.shadowRoot,
      );

      // Need to update slider when size changed
      this.observer = new ResizeObserver(() => {
        requestAnimationFrame(() => {
          this.edsSlider.update();
        });
      });
      this.observer.observe(this.edsSlider.dom.container);

      // Disable component's right click event
      this.addEventListener('contextmenu', event => {
        event.preventDefault();
      });

      this.edsSlider.init();
    }
  }

  /**
   * Lifecycle hook didDisconnect for cleaning observer
   *
   * @method didDisconnect
   */
  didDisconnect() {
    if (this.observer) {
      this.observer.unobserve(this.edsSlider.dom.container);
    }
  }

  /**
   * Event handler for slider
   * Bubbles component standard customized input/change event
   */
  handleEvent(event) {
    const { type: eventType } = event;

    if (eventType === 'input' || eventType === 'change') {
      event.stopPropagation();
      if (this.multiple) {
        this.values = event.target.values;
      } else {
        this.value = event.target.value;
      }

      const eventValue = this.multiple
        ? { values: this.values }
        : { value: this.value };
      this.bubble(eventType, eventValue);
    }
  }

  /**
   * Render the range input anchor for slider
   */
  render() {
    return this.multiple
      ? html`<input
          type="range"
          class="range"
          step=${this.step}
          min=${this.from}
          max=${this.to}
          ?disabled=${this.disabled}
          ?multiple=${this.multiple}
          values=${live(this.values)}
          @input=${this}
          @change=${this}
        />`
      : html`
          <input
            type="range"
            class="range"
            step=${this.step}
            min=${this.from}
            max=${this.to}
            ?disabled=${this.disabled}
            value=${this.value}
            @input=${this}
            @change=${this}
          />
        `;
  }
}

definition('eui-slider', {
  style,
  props: {
    from: { attribute: true, type: Number, default: 0 },
    to: { attribute: true, type: Number, default: 100 },
    step: { attribute: true, type: Number, default: 1 },
    value: { attribute: true, type: Number, default: 0 },
    multiple: { attribute: true, type: Boolean },
    values: { attribute: true, type: String },
    disabled: { attribute: true, type: Boolean },
  },
})(Slider);

export { Slider };
