const supportsScopedRegistry = !!ShadowRoot.prototype.createElement;

export const CustomElementsMixin = Base =>
  class CustomElements extends Base {
    /**
     * Obtains the component definitions map if specified.
     */
    static get components() {
      return {};
    }

    constructor() {
      super();
      this.registerAll(this.constructor.components);
    }

    /**
     * Getter for the instance of the Custom Element Registry.
     * Override this getter if a new instance of the
     * Custom Element Registry is required for every instance of the component
     * that extends Base.
     */
    get customElementRegistry() {
      return this.constructor.__customElementRegistry;
    }

    /**
     * Setter for the instance of the Custom Element Registry.
     * Override this getter if a new instance of the
     * Custom Element Registry is required for every instance of the component
     * that extends Base.
     */
    set customElementRegistry(customElementRegistry) {
      this.constructor.__customElementRegistry = customElementRegistry;
    }

    /**
     * Register a component
     *
     * @function register
     * @param {Object} klass - class of the component to register
     * @param {String} [name] - name of the component to register
     */
    register(klass, name = klass.is) {
      if (name == null) {
        // eslint-disable-next-line no-console
        console.warn('A name for the custom element MUST be specified');
        return;
      }

      const registeredClass = this.customElementRegistry.get(name);
      if (
        registeredClass &&
        supportsScopedRegistry === false &&
        registeredClass === klass
      ) {
        // eslint-disable-next-line no-console
        console.warn(
          `%c The component ${name} is already defined!\n`,
          'background: orange; color: white',
          `Scoped elements use a polyfill from @webcomponents. In order to use scoped element registry you must import the scoped-custom-element-registry\n to the entry point of your project.\n`,
          `See the E-UI SDK documentation for further details`,
        );
        return;
      }
      if (!registeredClass) {
        try {
          const root = supportsScopedRegistry ? this.shadowRoot : window;
          root.customElements.define(name, klass);
        } catch (error) {
          // eslint-disable-next-line no-console
          console.warn(error.message);
        }
      }
    }

    /**
     * Register multiple components to the registry.
     *
     * @function registerAll
     * @param { Object.<string, Object> } components - name:Module for each component to be registered
     */
    registerAll(components) {
      const names = Object.keys(components);
      names.forEach(name => {
        this.register(components[name], name);
      });
    }

    /**
     * Get the shadowRoot options. This is called from Base when attaching the
     * shadow to the component. This determines if scoped Custom Element Registry
     * is supported.
     * If it is supported, customElements attribute is set in the shadowRoot,
     * otherwise the shadowRoot is unchanged.
     *
     * @function shadowRootOptions
     * @returns {Object} - { customElements: new CustomElementRegistry() } || {}
     */
    shadowRootOptions() {
      if (!this.customElementRegistry) {
        this.customElementRegistry = supportsScopedRegistry
          ? new CustomElementRegistry()
          : customElements;
      }
      return supportsScopedRegistry
        ? { customElements: this.customElementRegistry }
        : {};
    }

    static register(componentName) {
      try {
        window.customElements.define(componentName || this.is, this);
      } catch (error) {
        console.warn(error.message);
      }
    }

    /**
     * Convenience method to perform the imperative creation of elements. If scoped Custom Element Registry
     * is supported, elements are created on the shadowRoot, otherwise they are created on the document.
     *
     * @function createElement
     * @param {String} tagName - name of the element to create.
     * @returns Node
     */
    createElement(tagName) {
      const root = supportsScopedRegistry ? this.shadowRoot : document;
      return root.createElement(tagName);
    }
  };
