/**
 * @license
 * COPYRIGHT Ericsson 2022
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 */
import { registerMixin, hasMixin } from '../utils/exports.js';

export const StoreMixin = Base => {
  const mixinName = 'StoreMixin';
  if (hasMixin(Base, mixinName)) {
    console.warn(`Tried to add existing mixin ${mixinName}`);
    return Base;
  }

  return class Store extends Base {
    static get _mixins() {
      return registerMixin(super._mixins, mixinName);
    }

    // @prop({ attribute: false, type: Object, default: {} })
    // state;

    constructor(options) {
      super(options);
      this.constructor._propDefs = {
        ...this.constructor._propDefs,
        state: { attribute: false, type: Object, default: {} },
      };
      this._stateChanged = this._stateChanged.bind(this);
    }

    /**
     * @protected
     * @function getState
     * @description Get a state value from the Store
     */
    getState(key) {
      if (this.provider !== undefined && this.provider.store !== undefined) {
        return this.provider.store.getState(key);
      }
      return null;
    }

    /**
     * @protected
     * @function dispatch
     * @description Dispatch a state update action, this will be captured by the App Store
     */
    dispatch(action, payload) {
      if (this.provider !== undefined && this.provider.store !== undefined) {
        this.provider.store.dispatch(action, payload);
      }
    }

    /**
     * @protected
     * @function disconnect
     * @description Disconnect the app from the store
     * @param {Array} properties - The properties in the store previously registered
     */
    storeDisconnect(properties) {
      if (this.provider !== undefined && this.provider.store !== undefined) {
        return this.provider.store.disconnect(this, properties);
      }
      return null;
    }

    /**
     * @protected
     * @function connect
     * @description Connect to the store and received update notifications for
     * various state values
     * @param {Array} properties - The properties in the store to request notification changes on
     */
    storeConnect(properties) {
      if (this.provider !== undefined && this.provider.store !== undefined) {
        return this.provider.store.connect(this, properties);
      }
      return null;
    }

    /**
     * @protected
     * @function addActions
     * @description Set up an action listener
     * @param {String} actionName - The action name to listen to, or an array of actions
     * @param {Function} func - The action function (for single action only)
     */
    addActions(actionName, func) {
      if (this.provider !== undefined && this.provider.store !== undefined) {
        if (typeof actionName === 'string') {
          this.provider.store.listen(actionName, func);
        } else {
          actionName.forEach(obj => {
            this.provider.store.listen(obj.name, obj.action);
          });
        }
      }
    }

    /**
     * @protected
     * @function removeActions
     * @description Remove an action listener(s)
     * @param {String} actionName - The action name to listen to, or an array of actions
     * @param {Function} func - The action function (for single action only)
     */
    removeActions(actionName, func) {
      if (this.provider !== undefined && this.provider.store !== undefined) {
        if (typeof actionName === 'string') {
          this.provider.store.unlisten(actionName, func);
        } else {
          actionName.forEach(obj => {
            this.provider.store.unlisten(obj.name, obj.action);
          });
        }
      }
    }

    /**
     * @private
     * @function _stateChanged
     * @description Function executed by the app store for state changes
     * @param {Object} state - The state object with values for the execution
     */
    _stateChanged(state) {
      const current = { ...this.state };
      Object.keys(current).forEach(key => {
        if (state[key] !== undefined) {
          current[key] = state[key];
        }
      });
      this.state = current;
    }
  };
};
