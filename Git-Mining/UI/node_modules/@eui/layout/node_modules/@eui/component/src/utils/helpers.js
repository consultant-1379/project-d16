/**
 * @license
 * COPYRIGHT Ericsson 2022
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 */

/* global ShadyCSS */

const whenComponentsAreDefined = root => {
  try {
    const undefinedComponents = root.querySelectorAll(':not(:defined)');
    const promises = Array.prototype.slice
      .call(undefinedComponents)
      .map(component => customElements.whenDefined(component.localName));

    if (undefinedComponents.length > 0) {
      const timeout = new Promise((resolve, reject) => {
        const id = setTimeout(() => {
          clearTimeout(id);
          const undefComponents = [...undefinedComponents]
            .map(comp => comp.localName)
            .toString();
          reject(
            new Error(
              `timed out after 100 ms with undefined components = [${undefComponents}]`,
            ),
          );
        }, 100);
      });
      promises.push(timeout);
    } else {
      return Promise.all(promises);
    }

    return Promise.all(promises);
  } catch (e) {
    // this fails in firefox because the selector is not valid,
    // so just wait a frame and all components are more likely
    // to be updated at that point.
    return new Promise(resolve => {
      requestAnimationFrame(resolve);
    });
  }
};

/**
 * @description Use to define keys to avoid cluttering object namespace
 */
const sym = description =>
  Symbol(description ? String(description) : undefined);

/**
 * @description Debounce a 0-arg function into the microtask queue.
 * This ensures that the update will be processed on the tail-end of this task,
 * before the next tick / browser repaint.
 * More info on this approach:
 * https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
 * https://javascript.info/event-loop
 *
 * @param {Function} fn
 * @return {Function}
 */
const microtaskDebounce = fn => {
  /**
   * Warning !!!
   * Native API exists for queuing microtasks but test runners are known to mock
   * it with a setTimeout. setTimeouts are not microtasks and do not behave as such.
   * https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask
   */
  let isQueued = false;
  const el = document.createElement('i');
  new MutationObserver(() => {
    isQueued = false;
    fn();
  }).observe(el, { childList: true });
  let i = 0;
  return () => {
    if (!isQueued) {
      isQueued = true;
      el.textContent = `${i}`;
      i += 1;
    }
  };
};

/**
 * @description Warn the developer about improper library usage.
 * @todo: Make only active in dev mode (no-op in production)
 */
const warn = message => {
  console.warn(message);
};

// COMPAT
/**
 * Manually add the correct scoped classnames, if ShadyCSS doesn't
 * seem to be doing its job.
 */
const addClassNames = customElement => {
  customElement.shadowRoot.querySelectorAll('*').forEach(el => {
    el.classList.add(customElement.localName);
    el.classList.add('style-scope');
  });
};

/**
 * ShadyCSS prepareTemplate, but check it's not doubling up
 */
const prepareTemplate = (template, name) => {
  if (document.querySelector(`head > style[scope=${name}]`) == null) {
    ShadyCSS.prepareTemplate(template, name);
  }
};

// DOM EVENTS
const bubble = (context, name, detail = {}, config = {}) => {
  const event = new CustomEvent(name, {
    bubbles: true,
    composed: true,
    ...config,
    detail,
  });
  context.dispatchEvent(event);
  return event;
};

// PROPS
/**
 * Transform dash-case (HTML) into camelCase (JS)
 * @param {string} input
 * @returns {string}
 */
const dashToCamel = input =>
  /* eslint-disable-next-line no-useless-escape */
  input.replace(/\-./g, match => match.substr(1).toUpperCase());

/**
 * Transform camelCase (JS) into dash-case (HTML)
 *
 * @param {string} input
 * @returns {string}
 */
const camelToDash = input =>
  input.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);

const compatUpdated = (shadyPrepared, obj) => {
  if (window.ShadyCSS) {
    // Things which only need to happen on the first render
    if (!shadyPrepared) {
      const template = document.createElement('template');
      template.innerHTML = obj.shadowRoot.innerHTML;
      prepareTemplate(template, obj.localName);
      ShadyCSS.styleElement(obj);
      obj._shadyPrepared = true;
    }
    // Things which need to happen on prop update
    // ShadyCSS.styleSubtree(this);
    if (!ShadyCSS.nativeShadow) {
      obj.shadowRoot.querySelectorAll('style').forEach(el => {
        el.textContent = '';
      });
      addClassNames(obj);
    }
  }
};

const eventHandlers = (obj, add = true) => {
  if (obj) {
    if (add) {
      Object.entries(obj).forEach(([key, value]) => {
        this.addEventListener(key, value);
      });
      return;
    }
    Object.entries(obj).forEach(([key, value]) => {
      this.removeEventListener(key, value);
    });
  }
};

/**
 * @description Gets the global locale override
 * @function getCurrentSystemLocale
 * @returns string or null
 */
function getCurrentSystemLocale() {
  return window.EUI?.locale;
}

export default {
  whenComponentsAreDefined,
  sym,
  microtaskDebounce,
  warn,
  addClassNames,
  prepareTemplate,
  bubble,
  dashToCamel,
  camelToDash,
  compatUpdated,
  eventHandlers,
  getCurrentSystemLocale,
};
