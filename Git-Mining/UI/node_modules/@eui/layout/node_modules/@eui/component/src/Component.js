/**
 * @license
 * COPYRIGHT Ericsson 2022
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 */
import { registerMixin, hasMixin } from './utils/exports.js';
import helpers from './utils/helpers.js';
import { typeMapping } from './utils/propTypes.js';
import Cache from './utils/cache.js';

/**
 * @description Fetches the locale
 * @param {Object} context - the instance of the app/component to be localized
 */
async function fetchLocale(context) {
  let response;
  let localeStrings;
  let parsedResponse;
  const localePath = `${context._localeRoot}${context.locale}.json`;

  const windowFetch = context._getWindow('fetch');
  /**
   * return legend
   * { localeString } - valid json
   * null - failed request, don't try again
   * false - unknown state due to connection issue, allow for retry later if applicable
   */
  try {
    response = await windowFetch(localePath);
    if (response.ok) {
      try {
        parsedResponse = await response.json();
        localeStrings = parsedResponse;
      } catch (error) {
        // invalid json or possible http 200 connection reset event
        console.error(`Unable to parse locale file: ${error}`);
        return null;
      }
    } else {
      // 404 response - file does not exist
      return null;
    }
  } catch (error) {
    console.error(`Issue fetching locale file from server: ${error}`);
    return false;
  }
  return { localeStrings };
}

export default Base => {
  // Define the mixin name, this is required to determine if the mixin has
  // Already been applied
  const mixinName = 'StatefulComponent';
  // Determine if there is an attempt to re-initialize the mixin
  if (hasMixin(Base, mixinName)) {
    console.warn(`Tried to add existing mixin ${mixinName}`);
    return Base;
  }

  return class StatefulComponent extends Base {
    static get _mixins() {
      return registerMixin(super._mixins, mixinName);
    }

    /**
     * Define the components as Custom Elements.
     *
     * @function registerComponents
     * @param { Array } components - array of components
     */
    static registerComponents(components) {
      if (!components) {
        console.warn('No component provided to register');
        return;
      }
      if (!Array.isArray(components)) {
        console.warn('incorrect type provided');
        return;
      }
      components.forEach(component => {
        const { is } = component;
        let { componentClass } = component;
        if (typeof component === 'object' && (!is || !componentClass)) {
          console.warn('Object:component not defined properly');
          return;
        }

        if (!componentClass) {
          // if component class is not specified explicitly, it's the same as component.
          componentClass = component;
        }
        if (!customElements.get(is)) {
          customElements.define(is, componentClass);
        }
      });
    }

    /**
     * Define the component as a Custom Element. The optional customName MUST be a valid
     * custom element and contain at least one dash (-).
     *
     * @function register
     * @param { String } customName - name of the component
     */
    static register(customName) {
      // NotSupportedError thrown if you try to register:
      // 1. same class twice
      // 2. same component name again
      if (customName == null) {
        if (!customElements.get(this.is)) {
          customElements.define(this.is, this);
        }
        // Else trying to replace default class e.g. different version
        // Or registering same component twice
      } else if (!customElements.get(customName)) {
        // Name is not already registered, so safe to proceed...
        if (customName === this.is) {
          // Only hit if using same custom name as default but
          // default not registered yet. Safe to register original class.
          customElements.define(this.is, this);
        } else {
          // You can't register same class reference twice, must mutate to use custom name
          const c = class extends this {};
          c.is = customName;
          customElements.define(customName, c);
        }
      }
    }

    /**
     * @protected
     * @function constructor
     * @description Parse the custom element attributes as props
     */
    constructor() {
      super();

      // PROPS
      this._prevProps = undefined;
      this._justConnected = false;
      this._localeCache = new Cache();
      // Debounce prop updates leading to lifecycle callbacks, so that
      // setting multiple props in sequence (e.g. via a declarative
      // renderer calling setAttribute many times) just triggers one big
      // update, not several partial ones.
      this._lifecycleDebounced = helpers.microtaskDebounce(
        this._executeLifecycle.bind(this),
      );

      this._localeLifecycleDebounced = helpers.microtaskDebounce(
        this._executeLocaleLifecycle.bind(this),
      );

      this._handleGlobalLocaleChange =
        this._handleGlobalLocaleChange.bind(this);

      // Find any props initialize for the component
      if (this.constructor._propDefs) {
        this._findProps();
      }
    }

    _handleGlobalLocaleChange() {
      this.locale = helpers.getCurrentSystemLocale();
    }

    /**
     * @protected
     * @function connectedCallback
     * @description The Default connected callback
     */
    connectedCallback() {
      // DOM EVENTS
      helpers.eventHandlers(this.intercepts);
      this._setAttributes();
      this._justConnected = true;
      this._lifecycleDebounced();

      // add listener for eui-locale-change
      if (this.meta?.url) {
        // system locale overrides any locale assigned
        this.locale = helpers.getCurrentSystemLocale() || this.locale;
        document.addEventListener(
          'eui-locale-change',
          this._handleGlobalLocaleChange,
        );
      }
    }

    /**
     * @protected
     * @function disconnectedCallback
     * @description The Default disconnected callback
     */
    disconnectedCallback() {
      if (this.meta?.url) {
        document.removeEventListener(
          'eui-locale-change',
          this._handleGlobalLocaleChange,
        );
      }
      // DOM EVENTS
      helpers.eventHandlers(this.intercepts, false);
      this.didDisconnect();
    }

    // COMPAT
    /**
     * @description Call this from your renderer once you've rendered to the DOM
     */
    compatElementUpdated() {
      helpers.compatUpdated(this._shadyPrepared, this);
    }

    // DOM EVENTS
    bubble(name, detail = {}, config = {}) {
      return helpers.bubble(this, name, detail, config);
    }

    /**
     * @description Get object with current values of all props in this INSTANCE.
     */
    get props() {
      if (this.constructor._propDefs) {
        // Loop through the component's CONSTRUCTOR props definition
        return Object.keys(this.constructor._propDefs).reduce((memo, key) => {
          memo[key] = this[key];
          return memo;
        }, {});
      }
      return {};
    }

    /**
     * @description Let the browser know which attributes to observe.
     * Part of the Custom Elements v1 spec, the browser will observe all
     * the attributes listed here, triggering attributeChangedCallback any
     * time they are set
     * @return {string[]}
     */
    static get observedAttributes() {
      if (this._propDefs !== undefined) {
        this._observedAttributes = Object.entries(this._propDefs)
          /* eslint-disable-next-line no-unused-vars */
          .filter(([key, value]) => value.attribute === true)
          /* eslint-disable-next-line no-unused-vars */
          .map(([key, value]) => helpers.camelToDash(key));
      }
      return this._observedAttributes;
    }

    /**
     * Loop over each prop defined by the user and set the values for props.
     *
     * @function _setAttributes
     * @private
     */
    _setAttributes() {
      if (this.constructor._propDefs) {
        Object.entries(this.constructor._propDefs).forEach(([key, propDef]) => {
          const defaultValue = propDef.default;

          // Attributes can't be set in the constructor, and must be
          // deferred to the connectedCallback, as per the spec.
          if (
            this[key] === undefined &&
            this.attributes[helpers.camelToDash(key)] === undefined &&
            !propDef.required
          ) {
            switch (propDef.type) {
              case Object:
                this[key] =
                  defaultValue !== undefined ? { ...defaultValue } : null;
                break;

              case Array:
                this[key] =
                  defaultValue !== undefined ? [...defaultValue] : null;
                break;

              default:
                this[key] = defaultValue !== undefined ? defaultValue : null;
            }
          }
        });
      }
    }

    _defineProperty(key, propDef, lifeCycleCB) {
      const { type, required, attribute } = propDef;
      const defaultValue = propDef.default;

      // Use a Symbol to avoid cluttering object namespace
      const valueSymbol = helpers.sym(key);
      const { coerce, serialize } = typeMapping(type);
      const existingValue = this[key];

      // Warn against bad API usage
      if (required && defaultValue !== undefined) {
        helpers.warn(
          `[${this.constructor.is}] Required prop "${key}" should not also have a default set`,
        );
      }
      // Apply custom getters/setters to the property
      // TODO: Could move this to the prototype for efficiency
      Object.defineProperty(this, key, {
        // configurable: false,
        enumerable: true,
        get() {
          return this[valueSymbol];
        },
        set(v) {
          // Make sure the received value is of the expected type
          let value = coerce(v);
          if (value == null) {
            // Was it required?  If so, this shouldn't be happening
            if (required) {
              helpers.warn(
                `[${this.constructor.is}] Required prop "${key}" should not be set to null/undefined`,
              );
            }
            // Use the default value if one was provided
            if (defaultValue !== undefined) {
              value = defaultValue;
            }
          }

          // Trigger lifecycle if value has been changed
          // Objects/Arrays still pass through even if not mutated outside component
          if (this[valueSymbol] !== value) {
            this[valueSymbol] = value;
            if (attribute === true) {
              this._syncPropertyToAttribute(key, value, serialize);
            }

            lifeCycleCB();
          }
        },
      });
      // If element is defined in dom before registering it may already
      // have attributes/props assigned. Sync them.
      if (existingValue != null) {
        this[key] = existingValue;
      }
    }

    /**
     * @description Define the locale setter/getter
     */
    _defineLocaleProperty() {
      // If meta available then locale is enabled
      const { meta } = this;
      if (meta?.url) {
        const index = meta.url.lastIndexOf('/');
        const basePath = meta.url.substring(0, index);
        if (basePath) {
          // fixed for life of component
          this._localeRoot = `${basePath}/locale/`;

          const defaultLocale =
            this._getWindow('navigator').language.toLowerCase();
          this._defineProperty(
            'locale',
            {
              attribute: false,
              type: String,
              default: defaultLocale,
            },
            this._localeLifecycleDebounced,
          );

          // Assign locale if none exists and start pre-fetch
          this.locale = this.locale || defaultLocale;
          this._localeLifecycleDebounced();
        }
      }
    }

    /**
     * Fallback when fetch fails or cached locale is marked as failed
     *
     * @param {String} locale
     * @private
     */
    _localeFallback(locale) {
      if (locale === 'en-us') {
        // i18n failure, fallback to hardcoded strings if any
        this.i18n = null;
      } else {
        // Fallback to default
        // This will queue another localelifecycle
        this.locale = 'en-us';
      }
    }

    /**
     * @description Invoke the locale change lifecycle
     */
    async _executeLocaleLifecycle() {
      const { locale, _localeCache } = this;
      const cachedString = _localeCache.getLocale(locale);

      if (cachedString === null) {
        this._localeFallback(locale);
      } else if (typeof cachedString === 'object') {
        // Strings exist, used cache version
        this.i18n = cachedString;
      } else if (cachedString === false) {
        // request is already pending, ignore
        // There is a micro task in progress waiting for locale fetch to complete
      } else {
        // Mark the locale request as pending in cache
        // microtask about to go into sleep with fetch request
        _localeCache.addLocale(locale, false);

        const data = await fetchLocale(this);
        if (data?.localeStrings) {
          _localeCache.addLocale(locale, data.localeStrings);

          // Due to await need to locale has not changed while waiting
          // Check if still valid
          if (locale === this.locale) {
            this.i18n = data.localeStrings;
          }
        } else {
          // Mark cache so we don't attempt to request again
          if (data === null) {
            // Known 404 or invalid json
            _localeCache.addLocale(locale, null);
          } else {
            // connection issue allow retry later
            _localeCache.removeLocale(locale);
          }

          // Due to await need to locale has not changed while waiting
          // Check if still valid
          if (locale === this.locale) {
            this._localeFallback(locale);
          }
        }
      }
    }

    /**
     * @private
     * @description Find an props for the component
     */
    _findProps() {
      this._defineLocaleProperty();
      // List of reserved props, if someone has them in definition ignore.
      const reservedProps = ['locale', 'is', '_localeRoot'];

      // Loop over each prop defined by the user
      Object.entries(this.constructor._propDefs).forEach(([key, propDef]) => {
        if (reservedProps.indexOf(key) !== -1) return;
        this._defineProperty(key, propDef, this._lifecycleDebounced);
      });
    }

    /**
     * LIFECYCLE HOOKS
     * The component has been connected to the DOM (even with the polyfill,
     * which happens asynchronously).
     * Unlike in the constructor, all props are accessible, so this is a
     * good place to set initial internal state values (or reset them, if
     * this component could be connected multiple times).
     * Also good time to create any subscribers (remember to destroy them
     * later), or bubble any events.
     *
     * Call order:
     * connectedCallback() -> didConnect() -> didChangeProps()
     *
     * @function didConnect
     */
    didConnect() {}

    /**
     * Lifecycle hook
     * Option to set internal state based on newly received external props.
     * Also a good place to do things like send off ajax requests in
     * response to changing props.
     * Make sure to compare prev/current values to be sure it's actually changed.
     *
     *
     * @function didChangeProps
     * @param {Map} changedProps - Keys are the names of changed properties;
     * Values are the corresponding previous values.
     */
    /* eslint-disable-next-line no-unused-vars */
    didChangeProps(changedProps) {}

    // TODO: this function should be re-written so the user doesn't need
    // to call super.shouldRender(prev); componentShouldRender is doing more
    // than just providing a hook.
    /**
     * Lifecycle hook
     * Determine whether the props have changed enough to need a re-render
     * Defaults to using a shallow === check, so won't pick up deep changes
     * in objects (for example).  Use the immutable pattern to avoid this.
     * this.someProp = { ...this.someProp, foo: 'new' }
     * You could also override this to perform a different checking logic
     * in a component, if you need.
     *
     * @function shouldRender
     * @param {Map} changedProps - Keys are the names of changed properties;
     * Values are the corresponding previous values.
     * @return {boolean} True to trigger a re-render
     */
    shouldRender(changedProps) {
      const flag = [...changedProps].some(
        ([key, value]) => value !== this[key],
      );
      return flag;
    }

    /**
     * Lifecycle hook
     * Option to do any preparation needed for a render.
     * Do not set internal state here.
     *
     *
     * @function willRender
     * @param {Map} changedProps - Keys are the names of changed properties;
     * Values are the corresponding previous values.
     */
    /* eslint-disable-next-line no-unused-vars */
    willRender(changedProps) {}

    /**
     * Lifecycle hook
     * Renderers should hook into this.
     *
     *
     * @function executeRender
     */
    executeRender() {}

    /**
     * Lifecycle hook
     * Implement this hook in your component if you are interested
     * to know when the component is upgraded.
     * Renderers should call this only once when the shadowRoot is
     * attached and the template is added.
     *
     * Executes only once in the component lifecycle.
     * Initial render has taken place and changes flushed to the DOM.
     * All props are accessible and the shadowRoot is available.
     * This hook gives the ability to check the presence of slotted children.
     *
     * If the component listens for slotchange events on a slot, then this
     * is the place to get their initial state. In Safari browser the
     * component is mutated before the shadowRoot is added which means
     * the slotchange won't fire on first render.
     *
     *
     * @function didUpgrade
     */
    didUpgrade() {}

    /**
     * Lifecycle hook
     * Rendering has taken place and changes flushed to the DOM, so an
     * opportunity to carry out any imperative updates that may be needed.
     * Frequently used to imperatively set props on slotted children.
     * Do not set internal state here.
     *
     *
     * @function didRender
     * @param {Map} changedProps - Keys are the names of changed properties;
     * Values are the corresponding previous values.
     */
    /* eslint-disable-next-line no-unused-vars */
    didRender(changedProps) {}

    /**
     * Lifecycle hook
     * Component is about to be disconnected from the DOM (but may be
     * connected again later...).
     * Good time to remove any subscribers.
     *
     *
     * @function didDisconnect
     */
    didDisconnect() {}

    /**
     * Get the property definitions as defined for the component.
     * @returns {Map}
     */
    get propDefinitions() {
      const propMap = new Map();
      Object.keys(this.constructor._propDefs)
        .filter(key => !key.startsWith('_'))
        .forEach(key => {
          propMap.set(key, this.constructor._propDefs[key]);
        });
      return propMap;
    }

    /**
     * @description returns the global window property
     * @param {String} prop
     */
    _getWindow(prop) {
      return window[prop];
    }

    /**
     * @description Manually trigger lifecycle callbacks.  Would be used in conjunction
     * with a custom arePropsChangedCallback.
     */
    triggerComponentUpdate() {
      this._lifecycleDebounced();
    }

    /**
     * @description Called (as part of HTML spec) when attribute changes
     * @param {string} name
     * @param {string} oldValue
     * @param {string} newValue
     */
    attributeChangedCallback(name, oldValue, newValue) {
      if (super.attributeChangedCallback) {
        super.attributeChangedCallback(name, oldValue, newValue);
      }
      const propName = helpers.dashToCamel(name);
      const propDef = this.constructor._propDefs[propName];
      const { deserialize } = typeMapping(propDef.type);
      if (propDef && propDef.attribute === true) {
        this._syncAttributeToProperty(propName, newValue, deserialize);
      }
    }

    /**
     * @description Invoke the props changed/rendering lifecycle
     * @function _executeLifecycle
     * @private
     */
    async _executeLifecycle() {
      // Skip lifecycle callbacks if component isn't connected. Don't
      // want to try manipulating a DOM tree that doesn't exist.
      // https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected
      if (!this.isConnected) {
        return;
      }

      // Prev/next callbacks, passed on to lifecycle callbacks
      const prevWasUndefined = this._prevProps === undefined;
      const prev = prevWasUndefined ? {} : this._prevProps;

      // Initial render only
      if (this._justConnected) {
        // Check for any missing required props
        if (this.constructor._propDefs) {
          Object.entries(this.constructor._propDefs).forEach(
            ([key, propDef]) => {
              if (propDef.required && this[key] == null) {
                helpers.warn(
                  `[${this.constructor.is}] Required prop "${key}" was not set`,
                );
              }
            },
          );
        }
        this.didConnect();

        this._justConnected = false;
      }

      const changedProps = this._setDiff(prev, this.props);

      // call didChangeProps when there is a change.
      if (changedProps.size > 0) {
        this.didChangeProps(changedProps);
      }

      // Set _prevProps ready for next update, after giving the user a
      // chance to update internal state props in earlier lifecycle hooks
      // Any prop changes after this point will trigger didChangeProps on
      // next microtask
      this._prevProps = this.props;

      // Never let the user bypass the initial render.
      if (
        prevWasUndefined ||
        // This hook has final say on rendering or not
        this.shouldRender(changedProps)
      ) {
        this.willRender(changedProps);

        try {
          this.executeRender();
          this.didRender(changedProps);
        } catch (error) {
          console.error(`[${this.localName}] ${error}`);
        }
      }
    }

    /**
     * Perform a comparison between previous prop values and current prop values
     * to determine differences. Each different prop (key:value) is put into a Map.
     * This Map is set as the changeProps map and used as input to all lifecycle callbacks.
     *
     * @function _setDiff
     * @param {Object} previous - previous prop values
     * @param {Object} current - current prop values
     * @private
     */
    _setDiff(previous, current) {
      const changes = new Map();
      const keys = Object.keys(previous);
      keys.forEach(key => {
        if (previous[key] !== current[key]) {
          changes.set(key, previous[key]);
        }
      });
      return changes;
    }

    /**
     * Sync the HTML attribute value to the JS object property
     *
     * @param {string} name - property name
     * @param {string} v - property value, all types
     * @param {function} deserialize - function for deserializing value
     * @private
     */
    _syncAttributeToProperty(name, v, deserialize) {
      if (name in this.constructor._propDefs) {
        // blocks the setter trying to sync the attribute again, recursion
        this._syncingAttributeToProperty = true;
        // Deserialize based on prop type
        const value = deserialize(v);
        this[name] = value;
        this._syncingAttributeToProperty = false;
      }
    }

    /**
     * Sync a property value to an HTML attribute
     * @param {string} name - property name
     * @param {*} v - property value, all types
     * @param {function} serialize - function for serializing value
     * @private
     */
    _syncPropertyToAttribute(name, v, serialize) {
      if (!this._syncingAttributeToProperty) {
        // Serialize to string | null
        const value = serialize(v);
        const attributeName = helpers.camelToDash(name);
        // Blocking until attributeChangeCallback is complete from attribute change
        if (value == null) {
          this.removeAttribute(attributeName);
        } else {
          this.setAttribute(attributeName, value);
        }
      }
    }
  };
};
