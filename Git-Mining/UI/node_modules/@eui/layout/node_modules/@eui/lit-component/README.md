# E-UI SDK Lit-Component

A renderer for `@eui/component` which uses [lit-html](https://lit.dev/).  

`lit-html` makes use of
[tagged template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals), a built-in feature of ES2015, so allow the easy creation of HTML templates in JavaScript without needing any transpilation before delivering to the browser (given that the user is on a modern browser).

## Documentation

The complete documentation for `@eui/lit-component` can be found at [E-UI SDK - Lit-Component](https://euisdk.seli.wh.rnd.internal.ericsson.com/euisdk/#docs?chapter=lit-component)

## Overview

In this simple example the component `<hello-world></hello-world>` is created to render the heading "Hello World".  
When the component is added to the DOM WITHOUT the name prop set it will render a default String "Hello World".  

`<hello-world></hello-world>`

When the component is added to the DOM with the `name` prop set to "Steve", it to will render "Hello Steve".

`<hello-world name="Steve"></hello-world>`

```javascript
// hello-world.js
import { LitComponent, html, definition } from '@eui/lit-component';      

export default class HelloWorld extends LitComponent {
  render() {
    return html`
      <div>
        <h1>Hello ${this.name}</h1>
      </div>
    `;
  }
}

definition('hello-world', {
  style: `:host {display: block;}`,
  props: {
    name: { attribute: true, type: String, default: 'World' }
  }
})(HelloWorld);
```

---

## Scoped Elements

Web Components evolve over time, new features are added, functionality is modified, bugs are fixed, etc. In a standalone project it is easy for a development team to know with 100% certainty the library/component version they are using (it is specified in their package.json). They will develop their Apps/Components towards the installed library version.

When their App/Component runs standalone in a browser they know (again with 100% certainty) the version of Button they are using is v1.0, so any time they use `<eui-button></eui-button>` in their App/Component they will get, for example; v1.0 of Button.

All components are registered in the browser using the CustomElementRegistry. There is only one instance of the CustomElementRegistry (per tab). A component can only be registered once in the CustomElementRegistry. This means `eui-button` can only be registered once, an attempt to register `eui-button` again (with a different version of Button) will silently fail. This poses a problem when different versions of a component tries to register (with the same name) in the same CustomElementRegistry.

Scoped elements makes it possible to use the same tag for different versions of Web Component.

Scoped elements use a polyfill from @webcomponents. In order to use scoped element registry you must import the `scoped-custom-element-registry` to the entry point of your project. In E-UI SDK this is `public/index.html`.

import the package to your project...

```npm
npm import @webcomponents/scoped-custom-element-registry
```

```html
<!DOCTYPE html>
<html>
  <head>
    <script src="@webcomponents/scoped-custom-element-registry/scoped-custom-element-registry.min.js"></script>
    ...
  </head>
  ...
</html>
```

> ### Self registering components
> in order for scoped elements to work correctly you **should not have any of your component "self register"**.  
> It was customary to register your component as a side effect, so when it is imported it automatically registers itself. 
> ```javascript
> export default class MyComponent extends LitComponent {
>   ...
> }
> definition('my-component')(MyComponent);
> MyComponent.register();
> //            ðŸ‘† this registers the component to the global registry. DO not do this
> ```
>
### Register a component to the scoped element registry

1. Import the sub component you want to use in your component

```javascript
import ComponentA from '@component-lib/component-a/v1/component.js';
```

2. Register the sub component using the `static get components()` method

```javascript
export default class MainComponent extends LitComponent {
  static get components() {
    return {
      'comp-a': ComponentA,
    }
  } 
}
```

3. Use sub component. This uses version one of component A.

```javascript
render() {
  return html`
    <comp-a></comp-a>
  `;
}
```

#### Methods of component registration

When registering multiple components, override `static get components` in your class

```javascript
export default class MainComponent extends LitComponent {
  static get components() {
    return {
      'comp-a': ComponentA,
      'comp-b': ComponentB,
      'comp-c': ComponentC,
    }
  } 
}
```

When registering multiple components, call `registerAll` from your class' `constructor()`

```javascript
export default class MainComponent extends LitComponent {
  constructor() {
    super();
    this.registerAll({
      'comp-a': ComponentA,
      'comp-b': ComponentB,
      'comp-c': ComponentC,
    });
  } 
}
```

When registering a single component, call `register` from your class' `constructor()`

```javascript
export default class MainComponent extends LitComponent {
  constructor() {
    super();
    this.register(ComponentA); // register with default (if ComponentA is an E-UI SDK Component) name.
    this.register(ComponentB, 'my-comp-b');
    //                         ðŸ‘† give component B a new name
  } 
}
```

### Using globally scoped elements

In order to use a globally scoped component you must register it to the scoped custom element registry.

```javascript
static get components() {
  return {
    'eui-icon': customElements.get('eui-v0-icon'),
  };
}
```

### Creating elements

When using the render function of LitComponent it will automatically use the scoped element registry. The scoped element registry is added to the shadowRoot.

```javascript
render() {
  return html`
    <eui-button>My button</eui-button>
  `;
}
```

When creating elements outside the render function.  

```javascript
initElements() {
  // creating a `eui-button` element in the global scope
  const button = document.createElement('eui-button');
  //                                       ðŸ‘† may fail if eui-button is only registered in the scoped registry

  // create a `eui-button` element in the local scope
  const button = this.shadowRoot.createElement('eui-button');
  //                              ðŸ‘† this only works with the polyfill!

  // use a convenience function to create a `eui-button` element in the local/global scope
  const button = this.createElement('eui-button');
  //                              ðŸ‘† if the polyfill is NOT used this call equates to document.createElement
  //                                 if the polyfill is used this call equates to this.shadowRoot.createElement

  this.appendChild(button);
}
```

### Lazy scoped components

It is possible to define a component at a later time. This is especially useful if you are trying to import a Module (Component) from another Micro Frontend and that Micro Frontend may or may not be available.

```javascript
import { LitComponent, html, definition } from '@eui/lit-component';  
import CompB from 'path/to/comp-b.js';

export default class myComponent extends LitComponent {
  constructor () {
    super();
    
    // register comp-b
    this.register(CompB);

    // dynamically import comp-a
    import('path/to/module.js').then( ({ Module }) => this.register(Module));
  }

  render() {
    return html`
      <comp-a></comp-a>
      <comp-b></comp-b>
    `;
  }
}

```

### Using a registry per component instance

By default the scoped element registry is shared between all instances of the same component class. If it is necessary for you to create a new registry per instance then you must override both the `getter` and `setter` for the registry...

```javascript
export default class CompA extends LitComponent {
  // override the getter for the customElementRegistry
  get customElementRegistry() {
    return this.__registry;
  }

  // override the setter for the customElementRegistry
  set customElementRegistry(registry) {
    this.__registry = registry;
  }

  render() {
    return html`
      <span>I am component A (v1.0)</span>
    `;
  }
}
definition('comp-a')(CompA);
```

---

## Installation

`$ npm install @eui/lit-component`

## Linting

Linting is an automated checking of the source code for programmatic and stylistic errors. Linting must be performed prior to code being submitted for review.

### Linting without automatic fixes
The following commands will run the eslinting & prettier rules which have been defined for this project on all .js and .html files. It will NOT attempt to fix errors found during this process. Errors are reported to the console. All errors must be fixed before progressing.

Run eslint and prettier on all .js and .html files.

```shell
npm run lint
```
Run just eslint on all .js and .html files.

```shell
npm run lint:eslint
```
Run just prettier on all .js and .html files.

```shell
npm run lint:prettier
```

### Linting with automatic fixes
The following commands will run the eslinting & prettier rules which have been defined for this project on all .js and .html files. It will attempt to
automatically fix errors found during this process. Errors that could not be automatically fixed are reported to the console. All errors must be fixed
before progressing.

Run eslint and prettier on all .js and .html files.

```shell
npm run format
```
Run just eslint on all .js and .html files.

```shell
npm run format:eslint
```

Run just prettier on all .js and .html files.

```shell
npm run format:prettier
```

### About the rules

Eslinting rules extends from the `@open-wc/eslint-config` rules set. For more information on how open-wc handles code linting & formatting please read their [documentation](https://open-wc.org/guides/tools/linting-and-formatting/).

Additional linting rules have been added to `.eslintrc.cjs` file for more precise control over the codes linting for individual libraries. For more information on each of these rules, please read eslints [documentation](https://eslint.org/docs/rules/).

The formatting rules set by prettier follow its defaults rules with three modifications to these rules made in the `package.json` file. All prettier rules can be found [here](https://prettier.io/docs/en/options.html).

- `"singleQuote": true` - Use single quotes instead of double quotes
- `"arrowParens": "avoid"` - Excludes the need to have a parentheses around a sole arrow function parameter.
- `"trailingComma": "all"` - Appends [final commas](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas). Eslint rule must also match to avoid conflicts when performing full formatting.

## Testing

[`@open-wc/testing`](https://open-wc.org/docs/testing/testing-package/) is used to unit test all components. It is an opinionated package that combines and configures testing libraries to minimize the amount of ceremony required when writing tests.  

### Running tests

Run all tests against the Firefox headless browser.  

``` shell
npm run test
```

Run all tests against all headless browsers (chrome, firefox and Safari).

``` shell
npm run test:all
```

Run all tests against Chrome headless browser in watch mode.

``` shell
npm run test:watch
```

## Demoing

To launch the demo, run the following command. A browser will open and display the demo.  

```shell
npm start
```

To start the scoping demo, run the following command. A browser will open and display the demo.

```shell
npm run start:scoping-demo
```

## Contribution

E-UI SDK is a community developed framework. We encourage developers to add functionality and help in bug fixing. Please follow the instructions in our documentation ([E-UI SDK - Contribution](https://euisdk.seli.wh.rnd.internal.ericsson.com/euisdk/#docs?chapter=contribution)) if you wish to contribute to your framework.
