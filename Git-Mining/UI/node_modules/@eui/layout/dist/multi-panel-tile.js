import { definition, TemplateComponent } from '@eui/component';
import { Tile } from './tile.js';
import { Icon } from '@eui/theme/icon';
import { Tooltip } from '@eui/base/tooltip';
import { FlyoutPanel } from './flyout-panel.js';

class PanelButton extends TemplateComponent {
  static get components() {
    return {
      'eui-icon': Icon,
      'eui-tooltip': Tooltip,
    };
  }

  static get template() {
    return `
      <eui-tooltip action>
        <eui-icon></eui-icon>
      </eui-tooltip>
    `;
  }

  /**
   * Get the tooltip component.
   *
   * @property _tooltip
   * @return {Element}
   * @private
   */
  get _tooltip() {
    return this.shadowRoot.querySelector('eui-tooltip');
  }

  /**
   * Get the icon component.
   *
   * @property _icon
   * @return {Element}
   * @private
   */
  get _icon() {
    return this.shadowRoot.querySelector('eui-icon');
  }

  /**
   * Set the tooltip message/
   *
   * @property _tooltipMessage
   * @param {String} - tooltip message
   * @private
   */
  set tooltipMessage(message) {
    if (message == null || message.trim() === '') {
      this._tooltip.visible = 'never';
    } else {
      this._tooltip.visible = null;
    }
    this._tooltip.message = message;
  }

  /**
   * Set the name of the icon
   */
  set iconName(name = 'square-dash') {
    this._icon.name = name;
  }

  /**
   * Set the position of the tooltip message
   */
  set tooltipPosition(position = 'bottom') {
    this._tooltip.position = position;
  }

  /**
   * Configure the button
   *
   * @function configure
   *
   * @param {String} icon - icon name
   * @param {String} tooltip - tooltip message
   * @param {String} slot - name of slot
   * @param {Boolean} hidden - hide/show the button
   */
  configure = (icon, tooltip, slot, hidden) => {
    this.icon = icon;
    this.tooltip = tooltip;
    this.slot = slot;
    this.hidden = hidden;
  };

  didChangeProps(changedProps) {
    if (changedProps.has('hidden')) {
      this.bubble('eui-panel-button:hidden');
    }
    if (changedProps.has('icon')) {
      this.iconName = this.icon;
    }
    if (changedProps.has('tooltip')) {
      this.tooltipMessage = this.tooltip;
    }
  }

  didConnect() {
    this.iconName = this.icon;
    this.tooltipMessage = this.tooltip;
    this.tooltipPosition =
      this.slot === 'left-panel-button' ? 'bottom' : 'bottom-end';
  }
}

const style$1 = `
  :host {
    height: 16px;
    width: 16px;
    display: block;
  }

  eui-icon {
    cursor: pointer;
  }

  :host([hidden]) {
    display: none;
  }
`;

definition('eui-panel-button', {
  style: style$1,
  props: {
    icon: { default: 'square-dashed' },
    tooltip: {},
    hidden: { attribute: true, type: Boolean },
  },
})(PanelButton);

/**
 * @license
 * COPYRIGHT Ericsson 2022
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 */

class MultiPanelTile extends Tile {
  static get components() {
    return {
      ...super.components,
      'eui-flyout-panel': FlyoutPanel,
      'eui-panel-button': PanelButton,
    };
  }

  static get template() {
    return `
      <div class="multi-panel-layout">
        <slot name="left"></slot>
        ${super.template}
        <slot name="right"></slot>
        <eui-flyout-panel panel-close></eui-flyout-panel>
      </div>
    `;
  }

  constructor() {
    super();
    this.addEventListener('eui-panel-button:hidden', event => {
      this._setDividerVisibility(event.target.slot);
    });

    this.addEventListener('eui-tile-panel:open', event => {
      this._showPanel(event.target);
    });

    const resizeobserver = new ResizeObserver(entries => {
      const { width } = entries[0].contentRect;
      if (width <= this.minWidth) {
        // check if there is a panel being resized...
        const resizingPanel = this.allPanels.find(
          panel => panel.resizing === true,
        );
        if (resizingPanel) {
          // prevent the ResizeObserver throwing a loop exception...
          requestAnimationFrame(() => {
            resizingPanel.freeze(this.minWidth - width);
          });
          return;
        }

        // if there are open panels, then we should close some...
        // if there is a panel currently closing (animating) then skip,
        // as we don't want to close two panels at the same time!
        if (this.allOpenPanels.length > 0 && this.closingPanel == null) {
          const closedPanelOnLeft = this._autoClosePanel('left');
          if (!closedPanelOnLeft) {
            this._autoClosePanel('right');
          }
        }
      }
    });
    resizeobserver.observe(this.mainTile);
  }

  get leftSlot() {
    return this.shadowRoot.querySelector('slot[name=left]');
  }

  get rightSlot() {
    return this.shadowRoot.querySelector('slot[name=right]');
  }

  get mainTile() {
    return this.shadowRoot.querySelector('.tile');
  }

  get leftPanels() {
    return [...this.querySelectorAll('[slot=left]')];
  }

  get rightPanels() {
    return [...this.querySelectorAll('[slot=right]')];
  }

  get allPanels() {
    return [...this.leftPanels, ...this.rightPanels];
  }

  get allOpenPanels() {
    return [
      ...this.leftPanels.filter(panel => panel.show),
      ...this.rightPanels.filter(panel => panel.show),
    ];
  }

  /**
   * Get a panel that is currently in the "closing" state.
   */
  get closingPanel() {
    return this.allPanels.find(panel => panel.closing);
  }

  get flyoutPanel() {
    return this.shadowRoot.querySelector('eui-flyout-panel');
  }

  _autoClosePanel = side => {
    const panels = [...this.querySelectorAll(`*[slot=${side}]`)];
    const visiblePanel = panels.find(panel => panel.show === true);
    if (visiblePanel) {
      visiblePanel.close();
    }
    return visiblePanel != null;
  };

  /**
   * Show the contents of a panel in a flyout.
   * This moves all slotted elements (contents and footer) from the panel to the flyout,
   * sets the title of the flyout (based on the panel tile) and opens the flyout panel.
   *
   * When the flyout is closed, all it's slotted elements (contents and footer)
   * are moved back to the originating panel.
   *
   * @function showFlyout
   * @param {Element} panel - the panel to be opened
   */
  showFlyout = panel => {
    // append elements to the flyout panel
    const apendToFlyoutPanel = elements => {
      elements.forEach(element => {
        this.flyoutPanel.appendChild(element);
      });
    };

    // get the contents of the panel...
    const panelContents = [...panel.childNodes].filter(
      node => node.slot === 'content',
    );
    apendToFlyoutPanel(panelContents);

    // get the contnets of the panel's footer...
    const panelFooters = panel.querySelectorAll('[slot=footer]');
    apendToFlyoutPanel(panelFooters);

    // create object to handle the events...
    const handlers = {
      handleEvent: () => {
        // append elements to the tile panel (put them back to where they originated)
        const appendToPanel = elements => {
          elements.forEach(element => {
            panel.appendChild(element);
          });
        };

        // get the contents of the flyout...
        const flyoutContents = [...this.flyoutPanel.childNodes].filter(
          node => node.slot === 'content',
        );
        appendToPanel(flyoutContents);

        // get the contnets of the flyout panel's footer...
        const flyoutFooters =
          this.flyoutPanel.querySelectorAll('[slot=footer]');
        appendToPanel(flyoutFooters);

        this.removeEventListener('eui-flyout-panel:closed', handlers);
      },
    };

    // add a listener to know when the flyout panel is closed...
    this.addEventListener('eui-flyout-panel:closed', handlers);

    this.flyoutPanel.panelTitle = panel.tileTitle;
    this.flyoutPanel.width = panel.width;
    this.flyoutPanel.position = panel.slot;
    this.flyoutPanel.show = true;
  };

  /**
   *
   * @param {String} slot - name of slot where the button should be slotted.
   * @param {Element} panel - Panel.
   * @returns
   */
  _createPanelButton = (slot, panel) => {
    const pButton = this.createElement('eui-panel-button');
    pButton.configure(panel.iconName, panel.tileTitle, slot, panel.show);

    // open the open the panel...
    pButton.addEventListener('click', () => {
      this._showPanel(panel);
    });

    // add a reference of the panel button to the panel.
    panel.panelButton = pButton;

    return pButton;
  };

  /**
   * Show a panel
   * Before a panel can be opened we must determine if it can be shown without the need to close another panel.
   * 1. Open panel on right.
   * 2. subtract width of R panel from main panel. Is there enough room to display panel?
   * 3. YES: Open panel inline
   * 3. NO:  Give me a list of all open panels ordered from left to right..
   * 3.      Determine if closing panels will give enough room. If it does, then close them and open the new panel inline
   * 3.      If it still won't give enough room, then open panel in flyout, but all open panels remain open.
   *
   * @function _showPanel
   * @param {Element} panel - panel to open
   */
  _showPanel = panel => {
    if (panel.show) {
      return;
    }
    if (this.autoClose) {
      // autoClose = true: Panels should auto close (or open in a flyout) when opening a new panel.
      const mainPanelWidth = this.mainTile.getBoundingClientRect().width - 32;
      const forcastedSpace = mainPanelWidth - panel.width;
      if (forcastedSpace >= this.minWidth) {
        panel.openInline();
      } else {
        const openPanels = this.allOpenPanels;
        if (openPanels.length === 0) {
          // no panels to be closed, so open in flyout.
          this.showFlyout(panel);
        } else {
          // if I close the first openPanel will that be enough?
          let gainedWidth = 0;
          let panelIndex = 0;
          const result = openPanels.some((openPanel, index) => {
            // get width of the panel.
            // if the width + forcastedWidth >= this.minwidth then close all open panels up to and including this index.
            panelIndex = index;
            gainedWidth += openPanel.width;
            return gainedWidth + forcastedSpace >= this.minWidth;
          });

          if (result) {
            // close all panels up to and including the index returned from the call to some.
            for (let i = 0; i <= panelIndex; i += 1) {
              openPanels[i].noAnimation = true;
              openPanels[i].close();
            }
            panel.openInline();
            // open the panel inline
          } else {
            // closing panels would not give enough room, so just open panel in flyout.
            this.showFlyout(panel);
          }
        }
      }
    } else {
      // autoClose = false: Panels should NOT auto close when opening a new panel.
      const mainPanelWidth = this.mainTile.getBoundingClientRect().width - 32;
      if (mainPanelWidth - panel.width <= this.minWidth) {
        this.showFlyout(panel);
      } else {
        panel.openInline();
      }
    }
  };

  /**
   * Get all the panel buttons on a particular side.
   *
   * @function _getPanelButtons
   * @param {String} side - 'left' | 'right'
   * @returns {Array} panel buttons.
   * @private
   */
  _getPanelButtons = side => [
    ...this.querySelectorAll(`eui-panel-button[slot=${side}]`),
  ];

  didConnect() {
    this.leftSlot.addEventListener('slotchange', event => {
      this._getPanelButtons('left-panel-button').forEach(button => {
        this.removeChild(button);
      });
      [...event.target.assignedElements()].forEach(panel => {
        panel.hidden = !panel.show;
        this.appendChild(this._createPanelButton('left-panel-button', panel));
      });
    });

    this.rightSlot.addEventListener('slotchange', event => {
      this._getPanelButtons('right-panel-button').forEach(button => {
        this.removeChild(button);
      });
      [...event.target.assignedElements()].forEach(panel => {
        panel.hidden = !panel.show;
        this.appendChild(this._createPanelButton('right-panel-button', panel));
      });
    });
  }
}

const style = `
:host {
  display: flex;
}

.multi-panel-layout {
  display: flex;
  gap: var(--space-large, 16px);
  width: 100%;
}
`;

definition('eui-multi-panel-tile', {
  style,
  props: {
    minWidth: { attribute: true, type: Number, default: 400 },
    autoClose: { attribute: true, type: Boolean },
  },
})(MultiPanelTile);

export { MultiPanelTile };
