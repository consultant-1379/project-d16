import { definition, TemplateComponent } from '@eui/component';
import { Icon } from '@eui/theme/icon';
import { Button } from '@eui/base/button';
import { HeaderStep } from './header-step.js';

var style = ":host {\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  box-sizing: border-box;\n}\n\n@media only screen {\n  :host(.mobile-view) {\n    flex-direction: row;\n    flex-flow: row;\n    align-items: stretch;\n  }\n\n  :host(.mobile-view) .wizard-steps {\n    /* The total width of vertical steps area is 300px\n       300px = 279px content + 1px border + 4px padding + 16px margin\n    */\n    width: 279px;\n    height: auto;\n    border-right: solid 1px var(--input-border-hover, #6a6a6a);\n    border-bottom: 0px;\n    flex-direction: column;\n    justify-content: flex-start;\n    align-items: flex-start;\n    padding-bottom: 0;\n    margin-top: 0;\n    margin-right: var(--space-large, 16px);\n    padding-right: var(--space-small, 4px);\n  }\n\n  :host(.mobile-view) .steps {\n    display: flex;\n    flex-wrap: nowrap;\n    justify-content: flex-start;\n    flex-direction: column;\n    overflow-y: auto;\n  }\n\n  :host(.mobile-view) .wizard-content-footer {\n    width: calc(100% - 300px);\n    height: auto;\n  }\n\n  :host(.mobile-view) .wizard-content {\n    padding: 0;\n  }\n}\n\n:host([maximize]) {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n}\n\n:host(:not([save])) eui-button#save {\n  display: none;\n}\n\n.wizard-steps {\n  width: 100%;\n  height: auto;\n  margin-top: var(--space-large, 16px);\n  padding-bottom: var(--space-large, 16px);\n  display: flex;\n  flex-wrap: nowrap;\n  align-items: center;\n  justify-content: center;\n  border-bottom: 1px solid var(--tile-divider,rgb(176, 176, 176));\n}\n\n.wizard-steps .arrow-left-holder,\n.wizard-steps .arrow-right-holder {\n  height: 47px;\n  margin-left: 0;\n  margin-top: -4px;\n}\n\n.wizard-steps .arrow-left-holder {\n  margin-right: var(--space-xl, 24px);\n}\n\n.wizard-steps .arrow-right-holder {\n  margin-left: var(--space-xl, 24px);\n}\n\n.wizard-steps eui-icon {\n  --icon-color: var(--wizard-footer-line,#c8c8c8);\n  cursor: pointer;\n}\n\n.wizard-steps eui-icon:hover {\n  --icon-color: var(--wizard-line-completed, #242424);\n}\n\n.steps {\n  width: 100%;\n  display: flex;\n  flex-wrap: nowrap;\n  justify-content: center;\n  overflow: hidden;\n  padding-top: var(--space-small, 4px);\n}\n\n.wizard-content-footer {\n  width: 100%;\n  height: calc(100% - 84px);\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n}\n\n.wizard-content {\n  padding: var(--space-xl, 24px) 0;\n  flex: 1;\n  overflow-y: auto;\n}\n\n.wizard-footer {\n  display: flex;\n  justify-content: space-between;\n  padding: var(--space-large, 16px) 0 0;\n  width: 100%;\n  border-top: 1px solid var(--wizard-footer-line,#c8c8c8);\n}\n\n.wizard-footer eui-button {\n  min-width: 100px;\n}\n\n.wizard-footer eui-button.minimize {\n  min-width: auto;\n}\n\n.wizard-footer .item {\n  display: flex;\n  gap: var(--space-base, 8px);\n  align-items: center;\n  flex-wrap: wrap;\n}\n\n.hidden {\n  display: none !important;\n}\n\n*::-webkit-scrollbar {\n  width: 8px;\n  height: 8px;\n  background: transparent;\n}\n*::-webkit-scrollbar-corner {\n  background: transparent;\n}\n*::-webkit-scrollbar-thumb {\n  background-color: var(--scrollbar-thumb, rgb(177, 177, 177));\n}\n* {\n  /* Firefox */\n  scrollbar-color: var(--scrollbar-thumb, rgb(177, 177, 177)) transparent;\n  scrollbar-width: thin;\n}\n";

var template = "<div class=\"wizard-steps\">\n  <div class=\"arrow-left-holder\">\n    <eui-icon\n      id=\"left\"\n      class=\"arrow-left\"\n      name=\"arrow-left\"\n      size=\"26px\"\n    ></eui-icon>\n  </div>\n  <div class=\"steps\"></div>\n  <div class=\"arrow-right-holder\">\n    <eui-icon\n      id=\"right\"\n      class=\"arrow-right\"\n      name=\"arrow-right\"\n      size=\"26px\"\n    ></eui-icon>\n  </div>\n</div>\n<div class=\"wizard-content-footer\">\n  <div class=\"wizard-content\">\n    <slot></slot>\n  </div>\n  <div class=\"wizard-footer\">\n    <div class=\"item\">\n      <eui-button id=\"cancel\"></eui-button>\n      <eui-button id=\"save\"></eui-button>\n    </div>\n    <div class=\"item\">\n      <eui-button id=\"previous\" icon=\"arrow-left\"></eui-button>\n      <eui-button id=\"next\" icon=\"arrow-right\" primary></eui-button>\n      <eui-button id=\"finish\" primary></eui-button>\n    </div>\n  </div>\n</div>\n";

class ScrollCalculator {
  elementLength = 0;

  scrollStart = 0;

  scrollEnd = 0;

  visibleArray = [];

  hiddenArray = [];

  maxElementsToShow = 5;

  showLeftArrowBtn = false;

  showRightArrowBtn = false;

  constructor(elementLength) {
    this.setLength(elementLength);
  }

  _getArray(start, end) {
    if (end - start < 0) {
      return [];
    }

    const result = [];
    for (let i = start; i <= end; i += 1) {
      result.push(i);
    }
    return result;
  }

  getScrollData() {
    return {
      elementLength: this.elementLength,
      scrollStart: this.scrollStart,
      scrollEnd: this.scrollEnd,
      visibleArray: this.visibleArray,
      hiddenArray: this.hiddenArray,
      showLeftArrowBtn: this.showLeftArrowBtn,
      showRightArrowBtn: this.showRightArrowBtn,
    };
  }

  setLength = (newLength, maxElementsToShow) => {
    this.elementLength = newLength || this.elementLength;
    this.maxElementsToShow = maxElementsToShow || this.maxElementsToShow;
    if (this.elementLength <= this.maxElementsToShow) {
      this.setScroll(0, this.elementLength - 1);
    } else {
      const newScrollStart =
        this.scrollStart > this.elementLength - this.maxElementsToShow - 1
          ? this.elementLength - this.maxElementsToShow - 1
          : this.scrollStart;

      const newScrollEnd = newScrollStart + this.maxElementsToShow - 1;
      this.setScroll(newScrollStart, newScrollEnd);
    }
    return this.getScrollData();
  };

  scrollLeft = () => {
    if (this.scrollStart !== 0) {
      this.setScroll(this.scrollStart - 1, this.scrollEnd - 1);
    }
    return this.getScrollData();
  };

  scrollRight = () => {
    if (this.scrollEnd !== this.elementLength - 1) {
      this.setScroll(this.scrollStart + 1, this.scrollEnd + 1);
    }
    return this.getScrollData();
  };

  setScroll = (start, end) => {
    this.scrollStart = start;
    this.scrollEnd = end;
    this.visibleArray = this._getArray(this.scrollStart, this.scrollEnd);
    this.hiddenArray = [
      ...this._getArray(0, this.scrollStart - 1),
      ...this._getArray(this.scrollEnd + 1, this.elementLength - 1),
    ];
    this.showLeftArrowBtn = this.scrollStart !== 0;
    this.showRightArrowBtn = this.scrollEnd < this.elementLength - 1;
    return this.getScrollData();
  };
}

var ScrollWidthTable = [
  {
    px: 400,
    size: 1,
  },
  {
    px: 600,
    size: 2,
  },
  {
    px: 900,
    size: 3,
  },
  {
    px: 1100,
    size: 4,
  },
  {
    px: 1400,
    size: 5,
  },
  {
    px: 1700,
    size: 6,
  },
  {
    px: 2000,
    size: 7,
  },
  {
    px: Number.MAX_SAFE_INTEGER,
    size: 8,
  },
];

/**
 * @license
 * COPYRIGHT Ericsson 2022
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 */

class Wizard extends TemplateComponent {
  static get components() {
    return {
      'eui-icon': Icon,
      'eui-wizard-header-step': HeaderStep,
      'eui-button': Button,
    };
  }

  scrollCalculator = new ScrollCalculator();

  _isFinished = false;

  get leftArrow() {
    return this.shadowRoot.querySelector('div.arrow-left-holder');
  }

  get rightArrow() {
    return this.shadowRoot.querySelector('div.arrow-right-holder');
  }

  get previousButton() {
    return this.shadowRoot.querySelector('eui-button#previous');
  }

  get nextButton() {
    return this.shadowRoot.querySelector('eui-button#next');
  }

  get finishButton() {
    return this.shadowRoot.querySelector('eui-button#finish');
  }

  get cancelButton() {
    return this.shadowRoot.querySelector('eui-button#cancel');
  }

  get saveButton() {
    return this.shadowRoot.querySelector('eui-button#save');
  }

  constructor() {
    super();
    this.addEventListener('eui-wizard-step:update', this, { passive: true });
    this.addEventListener('eui-wizard-step:valid', this, { passive: true });
  }

  get loc() {
    let currentLoc;

    try {
      currentLoc = window.EUI.Localizer.loc;
    } catch (e) {
      currentLoc = {};
    }

    return {
      CANCEL_BUTTON_WIZARD: currentLoc.CANCEL_BUTTON_WIZARD || 'Cancel',
      SAVE_BUTTON_WIZARD:
        currentLoc.SAVE_BUTTON_WIZARD || 'Save & finish later',
      PREVIOUS_BUTTON_WIZARD: currentLoc.PREVIOUS_BUTTON_WIZARD || 'Previous',
      NEXT_BUTTON_WIZARD: currentLoc.NEXT_BUTTON_WIZARD || 'Next',
      FINISH_BUTTON_WIZARD: currentLoc.FINISH_BUTTON_WIZARD || 'Finish',
      FINISHED_BUTTON_WIZARD: currentLoc.FINISHED_BUTTON_WIZARD || 'Finished',
    };
  }

  /**
   * Add a step indicator to the wizard heading.
   *
   * @function _addStepIndicator
   * @param {Step} wizardStep - wizard step component
   * @private
   */
  _addStepIndicator(wizardStep, index, stepTotal) {
    const step = this.createElement('eui-wizard-header-step');
    step.id = `step--${index}`;
    step.description = `${index + 1}. ${wizardStep.stepTitle}`;
    step.completed = wizardStep.completed;
    step.current = wizardStep.selected;
    step.first = index === 0;
    step.last = index === stepTotal - 1;

    step.addEventListener(
      'click',
      this.stepClick.bind(null, step, index),
      false,
    );
    this.shadowRoot.querySelector('.steps').appendChild(step);
  }

  /**
   * Select a step
   *
   * @function _selectStep
   * @private
   */
  _selectStep = index => {
    const currentStepIndex = this._selectedStepIndex;

    if (currentStepIndex !== index || currentStepIndex === -1) {
      this._menuSteps.forEach(menuStep => {
        menuStep.current = false;
      });

      if (index !== undefined) {
        this._wizardSteps.forEach(step => {
          step.selected = false;
        });

        this._menuStepAtIndex(index).current = true;
        this._wizardStepAtIndex(index).selected = true;
      }
    }
  };

  /**
   * Update the scroll of the step indicators in the heading.
   *
   * @function _updateScroll
   * @private
   */
  _updateScroll() {
    const { showLeftArrowBtn, showRightArrowBtn, visibleArray, hiddenArray } =
      this.scrollCalculator.getScrollData();
    const steps = this._menuSteps;

    visibleArray.forEach(visibleIndex => {
      steps[visibleIndex].hidden = false;
    });
    hiddenArray.forEach(hiddenIndex => {
      steps[hiddenIndex].hidden = true;
    });

    if (showLeftArrowBtn) {
      this._show(this.leftArrow);
    } else {
      this._hide(this.leftArrow);
    }
    if (showRightArrowBtn) {
      this._show(this.rightArrow);
    } else {
      this._hide(this.rightArrow);
    }
  }

  /**
   * Handle different view switching after component width changed
   */
  _updateView() {
    const clientWidth = this._getWizardClientWidth();

    if (clientWidth < ScrollWidthTable[2].px) {
      this.nextButton.classList.add('minimize');
      this.previousButton.classList.add('minimize');
    } else {
      this.nextButton.classList.remove('minimize');
      this.previousButton.classList.remove('minimize');
    }

    // Handle view switching
    if (this._isVerticalView(clientWidth)) {
      this.classList.add('mobile-view');
      this._menuSteps.forEach(i => i.classList.add('vertical'));
      this.scrollCalculator.setScroll(0, this._wizardSteps.length - 1);
    } else if (clientWidth <= ScrollWidthTable[1].px) {
      const scrollPosition = this._isFinished
        ? this._wizardSteps.length - 1
        : this._selectedStepIndex;
      this.classList.remove('mobile-view');
      this._menuSteps.forEach(i => i.classList.remove('vertical'));
      this.scrollCalculator.setScroll(scrollPosition, scrollPosition);
    } else {
      this.classList.remove('mobile-view');
      this._menuSteps.forEach(i => i.classList.remove('vertical'));
      this.scrollCalculator.setScroll(0, this._wizardSteps.length - 1);
    }
    this._addLocalization();
    this._updateScroll();
  }

  /**
   * Update the steps in the wizard.
   *
   * @function _updateSteps
   * @private
   */
  _updateSteps() {
    this.shadowRoot.querySelector('.steps').innerHTML = '';
    const wizardSteps = this._wizardSteps;
    const wizardStepTotal = wizardSteps.length;
    if (!wizardSteps.length) {
      return;
    }

    wizardSteps.forEach((step, index) =>
      this._addStepIndicator(step, index, wizardStepTotal),
    );
    if (!wizardSteps.find(step => step.selected)) {
      const lastSelectedStep = wizardSteps
        .map((step, index) => ({ step, index }))
        .reverse()
        .find(item => item.step.completed);
      this._selectStep(lastSelectedStep ? lastSelectedStep.index : 0);
    }

    let maxElementsToShow = ScrollWidthTable.find(
      element => element.px > this.clientWidth,
    ).size;
    if (this._isVerticalView(this.clientWidth)) {
      maxElementsToShow = this._wizardSteps.length;
    }
    this.scrollCalculator.setLength(wizardSteps.length, maxElementsToShow);
    this._updateScroll();
    this._updateFooter();
  }

  /**
   * Update the footer.
   *
   * @function _updateFooter
   * @private
   */
  _updateFooter = () => {
    const wizardSteps = this._wizardSteps;
    const selectedIndex = wizardSteps.findIndex(item => item.selected);
    if (selectedIndex === 0) {
      this._hide(this.previousButton, this.finishButton);
      this._show(this.nextButton);
    }

    if (selectedIndex > 0 && selectedIndex < wizardSteps.length - 1) {
      this._hide(this.finishButton);
      this._show(this.previousButton, this.nextButton);
    }

    if (selectedIndex === wizardSteps.length - 1) {
      this._hide(this.nextButton);
      this._show(this.previousButton, this.finishButton);
    }

    if (wizardSteps.length === 1) {
      this._hide(this.previousButton, this.nextButton);
      this._show(this.finishButton);
    }

    this.nextButton.disabled = !wizardSteps[selectedIndex].valid;
    this.finishButton.disabled = wizardSteps.find(step => !step.valid);

    if (this._menuSteps.reverse()[0].completed) {
      this._hide(this.previousButton);
    }
  };

  /**
   * Event handler for left step navigating
   */
  leftArrowClick = () => {
    if (this._isFinished) return;
    this.scrollCalculator.scrollLeft();
    this._updateScroll();
  };

  /**
   * Event handler for right step navigating
   */
  rightArrowClick = () => {
    if (this._isFinished) return;
    this.scrollCalculator.scrollRight();
    this._updateScroll();
  };

  /**
   * Event handler for step clicking navigation
   */
  stepClick = (step, number) => {
    if (this._isFinished) return;
    const currentStep = this._wizardSteps.find(
      wizardStep => wizardStep.selected,
    );

    // check if clicking on any previous step
    const clickedPrevStep = number < this._selectedStepIndex;
    if (!clickedPrevStep && (!step.completed || !currentStep.valid)) {
      return;
    }

    this.finishButton.disabled = false;
    this.finishButton.innerText = this.loc.FINISH_BUTTON_WIZARD;
    this._selectStep(number);
    this._updateFooter();
  };

  /**
   * Event handler for prev step navigation
   *
   * @function nextClick
   * @public
   */
  nextClick = () => {
    const wizardSteps = this._wizardSteps;
    const selectedIndex = wizardSteps.findIndex(item => item.selected);
    if (
      selectedIndex === wizardSteps.length - 1 ||
      !wizardSteps[selectedIndex].valid
    ) {
      return;
    }

    this._menuSteps[selectedIndex].completed = true;
    wizardSteps[selectedIndex].completed = true;
    this._selectStep(selectedIndex + 1);

    if (this._menuStepAtIndex(selectedIndex + 1).hidden) {
      this.scrollCalculator.scrollRight();
      this._updateScroll();
    }
    this._updateView();
    this._updateFooter();
  };

  /**
   * Event handler for prev step navigation
   */
  previousClick = () => {
    const selectedIndex = this._wizardSteps.findIndex(item => item.selected);
    if (selectedIndex === 0) {
      return;
    }

    this._selectStep(selectedIndex - 1);
    this.scrollCalculator.scrollLeft();
    this._updateScroll();
    this._updateFooter();
  };

  /**
   * Button handler for the Finish button.
   *
   * @function finishClick
   * @public
   */
  finishClick = () => {
    const wizardSteps = this._wizardSteps;
    const selectedIndex = wizardSteps.findIndex(item => item.selected);
    if (
      selectedIndex !== wizardSteps.length - 1 ||
      wizardSteps.find(step => !step.valid)
    ) {
      return;
    }

    this._menuStepAtIndex(selectedIndex).completed = true;
    wizardSteps[selectedIndex].completed = true;

    this.finishButton.disabled = true;
    this.finishButton.innerText = this.loc.FINISHED_BUTTON_WIZARD;
    this._isFinished = true;
    this._selectStep();
    this._updateFooter();
  };

  /**
   * Handle events
   *
   * @param {Event} event - button events
   */
  handleEvent(event) {
    if (event.target.id === 'cancel') {
      this.bubble('eui-wizard:cancel');
    }
    if (event.target.id === 'save') {
      this.bubble('eui-wizard:save');
    }
    if (event.target.id === 'finish') {
      const emittedEvent = this.bubble(
        'eui-wizard:finish',
        {},
        { cancelable: true },
      );

      if (!emittedEvent.defaultPrevented) {
        this.finishClick();
      }
    }
    if (event.target.id === 'next') {
      const emittedEvent = this.bubble(
        'eui-wizard:next',
        {},
        { cancelable: true },
      );

      if (!emittedEvent.defaultPrevented) {
        this.nextClick();
      }
    }
    if (event.type === 'eui-wizard-step:update') {
      this._updateSteps(event);
      this._updateView();
    }
    if (event.type === 'eui-wizard-step:valid') {
      const currentIndex = this._wizardSteps.indexOf(event.target);
      this._menuStepAtIndex(currentIndex).valid = event.target.valid;
      this._updateFooter(event);
    }
    if (event.type === 'resize') {
      if (!this.resizeTimeout) {
        this.resizeTimeout = setTimeout(() => {
          this.resizeTimeout = null;
          const maxElementsToShow = ScrollWidthTable.find(
            element => element.px > this.clientWidth,
          ).size;
          this.scrollCalculator.setLength(
            this._wizardSteps.length,
            maxElementsToShow,
          );
          this._updateView();
        }, 66);
      }
    }
  }

  /**
   * Hide component(s).
   *
   * @function _hide
   * @param  {...any} elements - spread of components to hide
   * @private
   */
  _hide(...elements) {
    elements.forEach(element => {
      element.classList.add('hidden');
    });
  }

  /**
   * Show component(s).
   *
   * @function _show
   * @param  {...any} elements - spread of components to show
   * @private
   */
  _show(...elements) {
    elements.forEach(element => {
      element.classList.remove('hidden');
    });
  }

  /**
   * Get the step indicators in the heading.
   *
   * @function _menuSteps
   * @private
   */
  get _menuSteps() {
    return [...this.shadowRoot.querySelectorAll('eui-wizard-header-step')];
  }

  /**
   * Get the menu step at a given index
   *
   * @function _menuStepAtIndex
   * @private
   */
  _menuStepAtIndex = index => this._menuSteps[index];

  /**
   * Get the index of the current selected step. If nothing is selected -1 is returned.
   *
   * @function _selectedStepIndex
   * @private
   */
  get _selectedStepIndex() {
    return this._menuSteps.findIndex(menuStep => menuStep.current);
  }

  /**
   * Get all the wizard steps
   *
   * @function _wizardSteps
   * @private
   */
  get _wizardSteps() {
    return [...this.querySelectorAll('eui-wizard-step')];
  }

  /**
   * Get the wizard step at a given index.
   *
   * @function _wizardStepAtIndex
   * @private
   */
  _wizardStepAtIndex = index => this._wizardSteps[index];

  /**
   * Get client width of current widget
   */
  _getWizardClientWidth = () => this.clientWidth;

  /**
   * Check if wizard is under vertical view
   */
  _isVerticalView = clientWidth =>
    clientWidth <= ScrollWidthTable[3].px &&
    clientWidth > ScrollWidthTable[1].px;

  /**
   * Apply localization for all UI elements
   */
  _addLocalization() {
    this.cancelButton.innerHTML = this.loc.CANCEL_BUTTON_WIZARD;
    this.saveButton.innerHTML = this.loc.SAVE_BUTTON_WIZARD;
    this.previousButton.innerHTML = !this.previousButton.classList.contains(
      'minimize',
    )
      ? this.loc.PREVIOUS_BUTTON_WIZARD
      : '';
    this.nextButton.innerHTML = !this.nextButton.classList.contains('minimize')
      ? this.loc.NEXT_BUTTON_WIZARD
      : '';
    this.nextButton.reverse = this.nextButton.innerHTML !== '';
    this.finishButton.innerHTML = this._isFinished
      ? this.loc.FINISHED_BUTTON_WIZARD
      : this.loc.FINISH_BUTTON_WIZARD;
  }

  /**
   * Apply localization
   */
  didRender() {
    this._addLocalization();
  }

  /**
   * Setting all the event handling
   */
  didConnect() {
    // add actionListeners...
    this.leftArrow.addEventListener('click', this.leftArrowClick, false);
    this.rightArrow.addEventListener('click', this.rightArrowClick, false);
    this.cancelButton.addEventListener('click', this, false);
    this.saveButton.addEventListener('click', this, false);
    this.previousButton.addEventListener('click', this.previousClick, false);
    this.nextButton.addEventListener('click', this, false);
    this.finishButton.addEventListener('click', this, false);

    window.addEventListener('resize', this, { passive: true });
    requestAnimationFrame(() => {
      this._updateView();
    });
  }

  /**
   * Clear all the event handling
   */
  didDisconnect() {
    window.removeEventListener('resize', this);
  }
}

/**
 * @property {Boolean} save - Displays the "Save & finish later" button. Hidden by default
 * @property {Boolean} maximize - Set the wizard to take up the fullscreen
 * @property {event} eui-wizard:cancel - dispatched when the "Cancel" button is pressed
 * @property {event} eui-wizard:save - dispatched when the "Save & finish later" button is pressed
 * @property {event} eui-wizard:finish - dispatched when the "Finish" button is pressed
 */
definition('eui-wizard', {
  style,
  template,
  props: {
    save: { attribute: true, type: Boolean },
    maximize: { attribute: true, type: Boolean },
  },
})(Wizard);

export { Wizard };
