import { definition } from '@eui/component';
import { Tile } from './tile.js';
import '@eui/base/tooltip';
import '@eui/theme/icon';

var style = ":host {\n  flex: none;\n  width: 0px;\n  transition: width 0.1s linear;\n  padding: 0;\n}\n\n:host([show]) {\n  width: var(--width);\n}\n\n:host([no-animation]:not([show])) {\n  transition: width 1ms;\n}\n\n:host([show]) .tile {\n  opacity: 1.0;\n}\n\n:host([show]) .separator {\n  opacity: 0.5;\n}\n  \n:host(:not([show])) .separator {\n  opacity: 0;\n  transition: opacity 0.1s linear 0.2s;\n}\n\n:host(:not([show])) .tile {\n  opacity: 0;\n  transition: opacity 0.1s;\n}\n\n.panel {\n  display: flex;\n  gap: var(--space-large, 16px);\n  height: 100%;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n}\n\n.tile {\n  width: 0;\n  opacity: 0;\n  transition: opacity 0.1s 0.08s;\n  display: flex;\n  flex-flow: column;\n  flex: auto;\n}\n\n.separator {\nopacity: 0;\nwidth: 20px;\ndisplay: flex;\nflex-flow: column;\nalign-items: center;\ntransition: opacity 0.3s;\n}\n\n.bar {\nflex: auto;\nwidth: 1px;\nbackground-color: var(--text);\n}\n\n.separator eui-icon {\ndisplay: none;\npadding: var(--space-small, 4px) 0;\n}\n\n:host([resizable]) .separator:hover,\n:host([resizable]) .separator:focus {\ncursor: col-resize;\nopacity: 1.0;\n}\n\n:host([resizing]) {\ntransition: none;\n}\n\n:host([resizable][resizing]) .separator {\ncursor: col-resize;\nopacity: 1.0;\n}\n\n:host([resizable]) .separator:hover eui-icon,\n:host([resizable]) .separator:focus eui-icon {\ndisplay: block;\n}\n\n:host([resizable][resizing]) .separator eui-icon {\ndisplay: block;\n}\n\n.separator:focus {\noutline: 1px solid var(--purple, #a56ebe);\noutline-offset: 1px;\n}\n\n@supports selector(:focus-visible) {\n.separator:focus {\n  outline: none;\n  background: transparent;\n}\n}\n\n.separator:focus-visible {\noutline: 1px solid var(--purple, #a56ebe);\noutline-offset: 1px;\n}";

class TilePanel extends Tile {
  // get the components from Tile...
  static get components() {
    return {
      ...super.components,
    };
  }

  // create the template
  static get template() {
    return `
    <div class="panel">
      ${super.template}
    </div>
    `;
  }

  /**
   * Get the separator (drag bar)
   */
  get separator() {
    return this.shadowRoot.querySelector('.separator');
  }

  /**
   * Get the panel
   */
  get panel() {
    return this.shadowRoot.querySelector('.panel');
  }

  /**
   * Get the tile (.tile class in the Tile component)
   */
  get tile() {
    return this.shadowRoot.querySelector('.tile');
  }

  set panelButton(panelButton) {
    this._panelButton = panelButton;
  }

  /**
   * Create the separator (drag bar)
   *
   * @returns HTMLFragment
   * @private
   */
  _createSeparator = () => {
    const temp = document.createElement('template');
    temp.innerHTML = `
      <div class="separator" tabindex="${this.resizable ? 0 : -1}">
        <div class="bar"></div>
        <eui-icon name="drag-handle"></eui-icon>
        <div class="bar"></div>
      </div>`;
    return temp.content;
  };

  /**
   * Resize the panel based on a forcased width.
   *
   * The forcased width is the new width that the panel
   * is about to be set as. But BEFORE this width can
   * be set, it must be checked aginst two controls
   *
   * minimum panel width (250px)
   * ---
   * If the forcasted width results in a value that is less than the minimum
   * width of the panel, the resize action is frozen, and the width is set
   * to the minimum (250px).
   *
   * maxWidth
   * ---
   * maxWidth represents the max width of the panel. It is set when the main
   * panel, in a Multi Panel Tile, calls "freeze". "freeze" is called when the main panel has reached
   * it's minimum width. This tells the panel that it cannot be made any wider.
   *
   * @param {Number} forecastedWidth
   */
  _forcastedWidth = forecastedWidth => {
    if (forecastedWidth <= 250) {
      // reached min width, stop resizing...
      this.width = 250;
    } else if (this.maxWidth == null) {
      this.width = forecastedWidth;
    } else if (this.maxWidth > forecastedWidth) {
      this.maxWidth = null;
      this.width = forecastedWidth;
    }
  };

  /**
   * Resize the panel using the mouse.
   *
   * @param {Number} stepSize - the distance the
   * mouse have moved from the initial start position
   */
  _resize = stepSize => {
    let forecastedWidth = 250;

    if (this.slot === 'left') {
      forecastedWidth = this.startWidth - stepSize;
    } else {
      forecastedWidth = this.startWidth + stepSize;
    }

    this._forcastedWidth(forecastedWidth);
  };

  /**
   * Resize the panel using the keyboard.
   *
   * @param {Number} stepSize - the distance the
   * mouse have moved from the initial start position
   * @param {String} direction - the direction of resize (left/right key press)
   */
  _resizeBy = (stepSize, direction = null) => {
    let forecastedWidth = 250;

    if (direction === 'left' && this.slot === 'left') {
      // decrease the width of the panel...
      forecastedWidth = this.width - stepSize;
    } else if (direction === 'left' && this.slot === 'right') {
      // increase the width of the panel...
      forecastedWidth = this.width + stepSize;
    } else if (direction === 'right' && this.slot === 'left') {
      // increase the width of the panel...
      forecastedWidth = this.width + stepSize;
    } else if (direction === 'right' && this.slot === 'right') {
      // decrease the width of the panel...
      forecastedWidth = this.width - stepSize;
    }

    this._forcastedWidth(forecastedWidth);
  };

  /**
   * Freeze this panel from resizing. Once frozen the panel cannot be widened.
   * The panel is unfrozen when it is reduced in width.
   *
   * @param {Number} overshoot - value of overshoot sent by the main tile.
   */
  freeze = overshoot => {
    this.width -= overshoot;
    this.maxWidth = this.width;
  };

  /**
   * open the panel inline...
   * This function MUST be used to show the panel. It relies on the setting of the panel hidden = false.
   * NOTE: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions
   * refer to the section on performing a transition after removing an element's `display: none;`
   *
   * @function openInline
   */
  openInline = () => {
    this.hidden = false;
    window.setTimeout(() => {
      this.show = true;
    }, 2);
  };

  /**
   * Tell the Multi Panel Tile that this panel SHOULD be opened.
   * The Multi Panel Tile will decide how this panel is displayed
   * depending on the available space.
   * If there is enough space, the Multi Panel Tile will call openInline()
   * If there is NOT enough space this panel will remain hidden, and it's
   * contents will be moved (by the Multi Panel Tile) into a Flyout Panel.
   *
   * @function open
   * @public
   */
  open() {
    this.bubble('eui-tile-panel:open');
  }

  /**
   * Close the panel
   *
   * @function close
   * @public
   */
  close() {
    this.show = false;
  }

  /**
   * mousedown
   * ---
   * Handle event when the mouse is clicked on the drag area.
   * Add mouse listeners.
   *
   * mouseup
   * ---
   * Remove listeners added in the mousedown event handler as they
   * are no longer needed.
   *
   * mousemove
   * ---
   * Resize the panel
   *
   * focus
   * ---
   * Add key listeners if the panel is resizable.
   * On window resize, the focused area should loose focus.
   *
   * blur
   * ---
   * remove all key listeners and the window resize listener.
   *
   * keydown
   * ---
   * Resize the panel.
   * Start a longpress timer, which increases the step size from
   * 1px to 10px after 1.5 seconds if the keyup has not
   * happened inbetween.
   *
   * keyup
   * ---
   * clear the longpress timer.
   *
   * resize
   * ---
   * remove focus from any focused drag area.
   *
   * @param {Event} event
   */
  handleEvent(event) {
    super.handleEvent(event);
    switch (event.type) {
      case 'mousedown':
        this.startPostion = event.clientX;
        this.startWidth = this.width;
        document.addEventListener('mouseup', this);
        document.addEventListener('mousemove', this);
        break;

      case 'mouseup':
        document.removeEventListener('mouseup', this);
        document.removeEventListener('mousemove', this);
        break;

      case 'mousemove':
        this._resize(this.startPostion - event.clientX);
        break;

      case 'focus':
        if (this.resizable) {
          this.resizing = true;
          window.addEventListener('resize', this, {
            passive: true,
            useCapture: true,
          });
          this.separator.addEventListener('blur', this);
          this.addEventListener('keydown', this);
          this.addEventListener('keyup', this);
        }
        break;

      case 'blur':
        this.resizing = false;
        this.maxWidth = null;
        window.removeEventListener('resize', this);
        this.separator.removeEventListener('blur', this);
        this.removeEventListener('keydown', this);
        this.removeEventListener('keyup', this);
        break;

      case 'keydown':
        if (this.longPressTimer == null) {
          this._stepSize = 1;
          this.longPressTimer = setTimeout(() => {
            this._stepSize = 10;
          }, 1500);
        }
        if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
          this._resizeBy(
            event.shiftKey ? 10 : this._stepSize,
            event.key === 'ArrowLeft' ? 'left' : 'right',
          );
        }
        break;

      case 'keyup':
        clearTimeout(this.longPressTimer);
        this.longPressTimer = null;
        break;

      case 'resize':
        this.separator.blur();
        break;
    }
  }

  /**
   * Create and add the close button for the panel
   *
   * @function _addCloseButton
   * @private
   */
  _addCloseButton = () => {
    const closeIcon = this.createElement('eui-icon');
    closeIcon.classList.add('close-button');
    closeIcon.slot = 'action';
    closeIcon.name = 'cross';

    // click on the close-button.
    closeIcon.addEventListener('click', event => {
      event.stopPropagation();
      this.show = false;
    });

    this.appendChild(closeIcon);
  };

  /**
   * When the panel is upgraded, determine the side (slot) the panel was inserted into.
   * This information is used to determine the side the drag handle should be placed.
   * - panel added to left of Multi Panel Tile, position separator (drag handle) on the right.
   * - panel added to right of Multi Panel Tile, position separator (drag handle) on the left.
   */
  didUpgrade() {
    super.didUpgrade();

    this.setWidth();

    if (this.slot === 'left') {
      this.panel.insertBefore(this._createSeparator(), null);
      this.panel.classList.add('left');
    } else {
      this.panel.insertBefore(this._createSeparator(), this.tile);
    }

    if (this.resizable) {
      this.separator.addEventListener('mousedown', this);
      this.separator.addEventListener('focus', this);
    }

    // When panel has transitioned to width: 0, set the panel to hidden...
    this.addEventListener('transitionend', () => {
      if (this.getBoundingClientRect().width === 0) {
        this.bubble('eui-tile-panel:closed');
        if (this._panelButton) {
          this._panelButton.hidden = false;
        }
        this.hidden = true;
        this.closing = false;
        this.noAnimation = false;
      }
    });

    this._addCloseButton();
  }

  /**
   * Set the CSS variable, --width
   *
   * @function setWidth
   */
  setWidth = () => {
    this.style.setProperty('--width', `${this.width}px`);
  };

  didChangeProps(changedProps) {
    super.didChangeProps(changedProps);
    if (changedProps.has('resizable')) {
      if (this.resizable) {
        this.separator.addEventListener('mousedown', this);
        this.separator.addEventListener('focus', this);
        this.separator.tabIndex = 0;
      } else {
        this.separator.removeEventListener('mousedown', this);
        this.separator.removeEventListener('focus', this);
        this.separator.tabIndex = -1;
      }
    }

    if (changedProps.has('show')) {
      if (this.show) {
        if (this._panelButton) {
          this._panelButton.hidden = true;
        }
        this.bubble('eui-tile-panel:show');
      } else {
        this.closing = true;
        this.bubble('eui-tile-panel:hide');
      }
    }

    if (changedProps.has('width')) {
      this.setWidth();
    }

    if (changedProps.has('tileTitle')) {
      if (this._panelButton) {
        this._panelButton.tooltip = this.tileTitle;
      }
    }

    if (changedProps.has('iconName')) {
      if (this._panelButton) {
        this._panelButton.icon = this.iconName;
      }
    }
  }

  didDisconnect() {
    super.didDisconnect();
    window.removeEventListener('resize', this);
  }
}

definition('eui-tile-panel', {
  style,
  props: {
    resizable: { attribute: true, type: Boolean },
    resizing: { attribute: true, type: Boolean },
    iconName: { attribute: true, type: String, default: 'square-dashed' },
    show: { attribute: true, type: Boolean },
    noAnimation: { attribute: true, type: Boolean },
    width: { attribute: true, type: Number, default: 300 },
  },
})(TilePanel);

export { TilePanel };
