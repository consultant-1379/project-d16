/**
 * @file Module to create Range slider component.
 */

/**
 * Class representing a range slider.
 */
export class RangeSlider {

  /**
   * Setup range slider properties.
   * @param {HTMLElement} input - input field.
   */
  constructor(input) {

    // user has passed a CSS3 selector string

    if (typeof input === 'string') {
      input = document.querySelector(input);
    }

    this.settings = {
      multiple: input.hasAttribute('multiple'),
      min: Number(input.min) || 0,
      max: Number(input.max) || 100,
      step: Number(input.step) || 1,

      classes: {
        input: 'ranger-input',
        container: 'ranger-container',
        progress: 'ranger-progress',
        handle: 'ranger-handle',
        tooltip: 'ranger-tooltip',
        track: 'ranger-track',
        multiple: 'ranger-multiple',
        limits: 'range-limits',
        limit: 'range-limit',
      }
    };

    this.dom = {
      input: input
    };

    this.listeners = {
      down: (evt) => this._down(evt),
      touchstart: (evt) => this._touchStart(evt),
      move: (evt) => this._move(evt),
      up: () => this._up(),
      update: () => this.update(),
      change: () => this._change(),
      reset: () => this._reset(),
      keyUp: (evt) => this._keyActions(evt),
      keyDown: (evt) => {
        if (evt.key === 'ArrowUp' || evt.key === 'ArrowDown'){
          evt.preventDefault();
        }
      },
    };

    this.listeners.scroll = this._throttle(this.listeners.update, 100);
    this.listeners.resize = this._throttle(this.listeners.update, 50);

    this.touch = false;

    this.init();
    this.onInit();
  }

  /**
   * Initialize range slider.
   * @public
   */
  init() {
    if (!this.dom.input.ranger) {

      this.dom.input.ranger = this;

      if (this.settings.multiple) {
        if (this.dom.input.getAttribute('values')) {
          this.dom.input.values = this.dom.input.getAttribute('values').split(',');

          this.dom.input.removeAttribute('values');
        } else {
          this.dom.input.values = [this.settings.min, this.settings.max];
        }
      } else {
        if (!this.dom.input.value) {
          this.dom.input.value = this.settings.max;
        }
      }

      this._render();
    }
  }

  /**
   * Generate custom range slider markup.
   * @private
   */
  _render() {
    const o = this.settings;
    const c = o.classes;

    const container = this._createElement('div', c.container);
    const track = this._createElement('div', c.track);
    const progress = this._createElement('div', c.progress);

    let handle = this._createElement('div', c.handle);
    let tooltip = this._createElement('div', c.tooltip);

    const limitsContainer = this._createElement('div', c.limits);
    const limits = [this._createElement('div', c.limit), this._createElement('div', c.limit)];

    track.appendChild(progress);

    if (o.multiple) {
      handle = [this._createElement('div', c.handle), this._createElement('div', c.handle)];
      tooltip = [
        this._createElement('div', c.tooltip),
        this._createElement('div', c.tooltip),
        this._createElement('div', c.tooltip)
      ];

      handle.forEach((node, i) => {
        node.index = i;
        node.tabIndex = 0;
        progress.appendChild(node);
        node.appendChild(tooltip[i]);
      });

      progress.appendChild(tooltip[2]);

      container.classList.add(c.multiple);
      this.dom.input.tabIndex = -1;

      handle[0].classList.add('rsh-min');
      handle[1].classList.add('rsh-max');
    } else {
      progress.appendChild(handle);
      handle.appendChild(tooltip);
    }

    limits[0].textContent = this.settings.min;
    limits[1].textContent = this.settings.max;

    limits.forEach((node, i) => {
      limitsContainer.appendChild(limits[i]);
    });

    track.appendChild(limitsContainer);

    this.dom = { ...this.dom, container, track, progress, handle, tooltip };

    container.appendChild(track);

    if (o.size) {
      container.style['width'] = !isNaN(o.size) ? `${o.size}px` : o.size;
    }

    this.dom.input.parentNode.insertBefore(container, this.dom.input);

    if (this.dom.input.disabled){
      container.classList.add('disabled');
    }

    container.insertBefore(this.dom.input, track);
    this.dom.input.classList.add(c.input);
    this._addEventListeners();
    this.update();
  }

  /**
   * Reset range slider value.
   * @private
   */
  _reset() {
    this._setValue(this.dom.input.value);
    // this._onEnd();
  }

  /**
   * Turn position of slider to value.
   * @private
   * @param {Event} evt - Field event.
   */
  _setValueFromPosition(evt) {
    const min = parseFloat(this.settings.min);
    const max = parseFloat(this.settings.max);
    const step = parseFloat(this.settings.step);
    const rect = this.rects;
    const axis = this.touch ? evt.touches[0]['clientX'] : evt['clientX'];
    const pos = axis - this.rects.container['left'];
    const size = rect.container['width'];

    // get the position of the cursor over the bar as a percentage

    const position = pos / size * 100;

    // work out the value from the position

    let value = position * (max - min) / 100 + min;

    // apply granularity (step)

    value = Math.ceil(value / step) * step;

    let index;

    if (this.settings.multiple) {
      index = this.activeHandle.index;

      switch (index) {
        case 0:
          if (value >= this.dom.input.values[1]) {
            value = this.dom.input.values[1];
          }

          break;
        case 1:
          if (value <= this.dom.input.values[0]) {
            value = this.dom.input.values[0];
          }
          break;
      }
    }

    /*
     * Only update the value if it's different. This allows the onChange event
     * to be fired only on a step and not all the time.
     */
    if (this.settings.multiple) {
      if (evt.type === 'mousedown' ||
        (index === 0) && parseFloat(value) !== parseFloat(this.dom.input.values[1]) ||
        (index === 1) && parseFloat(value) !== parseFloat(this.dom.input.values[0]) ) {
        this._setValue(value, index);
      }
    } else {
      if (evt.type === 'mousedown' || parseFloat(value) !== parseFloat(this.dom.input.value)) {
        this._setValue(value, index);
      }
    }

    this.dom.input.focus();
  }

  /**
   * Update single slider on change.
   * @private
   */
  _change() {
    if (!this.settings.multiple) {
      this.update();
    }
  }

  /**
   * Touch action.
   * @private
   * @param {Event} evt - Field event.
   */
  _touchStart(evt) {

    // this.nodes.container.removeEventListener("mousedown", this.events.down);

    this._down(evt);
  }

  /**
   * Mousedown / touchstart action.
   * @private
   * @param {Event} evt - Field event.
   */
  _down(evt) {
    evt.preventDefault();

    // show the tip now so we can get the dimensions later

    this.dom.container.classList.add('dragging');
    this._recalculate();
    this.activeHandle = this._getHandle(evt);
    this.activeHandle.classList.add('active');
    this._setValueFromPosition(evt);

    if (this.touch) {
      document.addEventListener('touchmove', this.listeners.move, false);
      document.addEventListener('touchend', this.listeners.up, false);
      document.addEventListener('touchcancel', this.listeners.up, false);
    } else {
      document.addEventListener('mousemove', this.listeners.move, false);
      document.addEventListener('mouseup', this.listeners.up, false);
    }
  }

  /**
   * Mousemove / touchmove action.
   * @private
   * @param {Event} evt - Field event.
   */
  _move(evt) {
    this._setValueFromPosition(evt);
    this.dom.input.dispatchEvent(new Event('input'));
  }

  /**
   * Mouseup / touchend action.
   * @private
   */
  _up() {
    this.dom.container.classList.remove('dragging');

    // this._onEnd();

    this.activeHandle.classList.remove('active');
    this.activeHandle = false;

    document.removeEventListener('mousemove', this.listeners.move);
    document.removeEventListener('mouseup', this.listeners.up);
    document.removeEventListener('touchmove', this.listeners.move);
    document.removeEventListener('touchend', this.listeners.up);
    document.removeEventListener('touchcancel', this.listeners.up);

    this.dom.input.dispatchEvent(new Event('change'));
  }

  /**
   * Recache the dimensions.
   * @private
   */
  _recalculate() {
    let handle = [];

    if (this.settings.multiple) {
      this.dom.handle.forEach((node, i) => {
        handle[i] = node.getBoundingClientRect();
      });
    } else {
      handle = this.dom.handle.getBoundingClientRect();
    }

    this.rects = {
      handle: handle,
      container: this.dom.container.getBoundingClientRect()
    };
  }

  /**
   * Update range slider.
   * @public
   */
  update() {
    this._recalculate();

    this.accuracy = 0;

    // detect float

    if (this.dom.input.step.includes('.')) {
      this.accuracy = (this.dom.input.step.split('.')[1] || []).length;
    }

    if (this.settings.multiple) {
      this.dom.input.values.forEach((val, i) => {
        this._setValue(val, i);
      });
    } else {
      this._setValue();
    }
  }

  /**
   * Set new range slider value.
   * @private
   * @param {Number} value - new value.
   * @param {Number} index - slider index.
   */
  _setValue(value, index) {
    const nodes = this.dom;
    const min = parseFloat(this.settings.min);
    const max = parseFloat(this.settings.max);

    if (this.settings.multiple && index === undefined) {
      return false;
    }

    if (value === undefined) {
      value = this.dom.input.value;
    }

    value = parseFloat(value);

    value = value.toFixed(this.accuracy);

    if (value < min) {
      value = min.toFixed(this.accuracy);
    } else if (value > max) {
      value = max.toFixed(this.accuracy);
    }

    // update the value

    if (this.settings.multiple) {
      const values = this.dom.input.values;
      values[index] = value;

      // update the node so we can get the width / height

      nodes.tooltip[index].textContent = value;

      // check if tips are intersecting...

      const intersecting = this._tipsIntersecting();

      if (intersecting) {

        /*
         * Format the combined tooltip.
         * Only show single value if they both match, otherwise show both seperated by a hyphen
         */

        nodes.tooltip[2].textContent = values[0] === values[1] ? values[0] : `${values[0]} - ${values[1]}`;
      }

      // ... and set the className where appropriate

      nodes.container.classList.toggle('combined-tooltip', intersecting);
    } else {
      this.dom.input.value = value;
      nodes.tooltip.textContent = value;
    }

    // set bar size

    this._setPosition(value, index);

    this.onChange();
  }

  /**
   * Set the bar size / position based on the value.
   * @private
   */
  _setPosition() {
    let width;

    if (this.settings.multiple) {
      const start = this._getPosition(this.dom.input.values[0]);
      const end = this._getPosition(this.dom.input.values[1]);

      // set the start point of the bar

      this.dom.progress.style['left'] = `${start}px`;

      width = end - start;
    } else {
      width = this._getPosition();
    }

    // set the end point of the bar

    this.dom.progress.style['width'] = `${width}px`;
  }

  /**
   * Calculate offset of slider value.
   * @private
   */
  _getOffset(){
    const trackWidth = this.dom.track.offsetWidth;
    const tooltip = this.dom.tooltip;

    if(!this.settings.multiple){
      const tooltipPadding = parseInt(window.getComputedStyle(tooltip, null).getPropertyValue('padding-left'), 0);

      const rightOffset = Math.round(trackWidth - (this._getPosition() + (tooltip.offsetWidth / 2) - tooltipPadding));
      const leftOffset = Math.round(this._getPosition() - ((tooltip.offsetWidth / 2) - tooltipPadding));

      this._setOffset(this.dom.tooltip, rightOffset, leftOffset);
    } else {

      const inpValues = this.dom.input.values;
      const rangeSize = this._getPosition(inpValues[1]) - this._getPosition(inpValues[0]);
      const tooltipPadding = parseInt(window.getComputedStyle(tooltip[2], null).getPropertyValue('padding-left'), 0);

      const rTrOffset = Math.round(trackWidth - (this._getPosition(inpValues[1]) +
                        (tooltip[1].offsetWidth / 2) - tooltipPadding));

      const lTrOffset = Math.round(this._getPosition(inpValues[0]) - ((tooltip[0].offsetWidth / 2) - tooltipPadding));

      this._setOffset([tooltip[0], tooltip[1]], rTrOffset, lTrOffset);


      const mdRightOffset = Math.round(trackWidth - (this._getPosition(inpValues[0]) +
                            ((tooltip[2].offsetWidth + rangeSize) / 2) - tooltipPadding));

      const mdLeftOffset = Math.round(this._getPosition(inpValues[1]) -
                           (((tooltip[2].offsetWidth + rangeSize) / 2) - tooltipPadding));

      this._setOffset(tooltip[2], mdRightOffset, mdLeftOffset);
    }
  }

  /**
   * Set the offset to element.
   * @private
   * @param {HTMLElement} target - handle element.
   * @param {Number} rightOffset - offset from right.
   * @param {Number} leftOffset - offset from left.
   */
  _setOffset(target, rightOffset, leftOffset){
    if (target instanceof Array){
      if (rightOffset < 0 || leftOffset < 0){
        if (rightOffset < 0){
          target[1].style['margin-right'] = Math.abs(rightOffset) + 'px';
        }

        if (leftOffset < 0){
          target[0].style['margin-right'] = '-' + Math.abs(leftOffset) + 'px';
        }
      } else {
        target[0].style['margin-right'] = 0;
        target[1].style['margin-right'] = 0;
      }
    } else {
      if (rightOffset < 0 || leftOffset < 0){
        if (rightOffset < 0){
          target.style['margin-right'] = Math.abs(rightOffset) + 'px';
        }

        if (leftOffset < 0){
          target.style['margin-right'] = '-' + Math.abs(leftOffset) + 'px';
        }
      } else {
        target.style['margin-right'] = 0;
      }
    }
  }

  /**
   * Get the position of handle from the value.
   * @private
   * @param {Number} value - current input value.
   * @return {Number} - position of handle element.
   */
  _getPosition(value = this.dom.input.value) {
    const min = parseFloat(this.settings.min);
    const max = parseFloat(this.settings.max);

    return (value - min) / (max - min) * this.rects.container['width'];
  }

  /**
   * Check whether the tooltips are colliding.
   * @private
   * @return {Boolean} - Tips intersecting or not.
   */
  _tipsIntersecting() {
    const nodes = this.dom.tooltip;
    const a = nodes[0].getBoundingClientRect();
    const b = nodes[1].getBoundingClientRect();

    return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);
  }

  /**
   * Get the correct handle on mousedown / touchstart.
   * @private
   * @param {Event} evt - Field event.
   */
  _getHandle(evt) {
    if (!this.settings.multiple) {
      return this.dom.handle;
    }

    const r = this.rects;
    const distA = Math.abs(evt['clientX'] - r.handle[0]['left']);
    const distB = Math.abs(evt['clientX'] - (r.handle[1]['left'] + 2));
    const handle = evt.target.closest(`.${this.settings.classes.handle}`);

    if (handle) {
      return handle;
    } else {
      if (distA > distB) {
        return this.dom.handle[1];
      } else {
        return this.dom.handle[0];
      }
    }
  }

  /**
   * Destroy range slider and associated events.
   * @public
   */
  destroy() {
    if (this.dom.input.ranger) {

      // remove all event listeners

      this._removeEventListeners();

      // remove the className from the input

      this.dom.input.classList.remove(this.settings.classes.input);

      // kill all nodes

      this.dom.container.parentNode.replaceChild(this.dom.input, this.dom.container);

      // remove the reference from the input

      delete (this.dom.input.ranger);
    }
  }

  /**
   * Callback on change.
   * @public
   */
  onInit() {
    if (this._isFunction(this.settings.onInit)) {
      this.settings.onInit.call(this, this.dom.input.value);
    }
  }

  /**
   * Callback on change.
   * @public
   */
  onChange() {
    if (this._isFunction(this.settings.onChange)) {
      this.settings.onChange.call(this, this.dom.input.value);
    }

    this._getOffset();
  }

  /**
   * Callback on end.
   *_onEnd() {
   * if (this._isFunction(this.settings.onEnd)) {
   *  this.settings.onEnd.call(this, this.dom.input.value);
   * }
   *}
   */


  /**
   * Slider keyboard actions
   * @param {Event} evt - Field event
   * @private
   */
  _keyActions(evt) {
    if (document.activeElement === this.dom.input){
      if (!this.settings.multiple) {
        this.update();
      }
    } else {

      const currMin = parseInt(this.dom.input.values[0], 10);
      const currMax = parseInt(this.dom.input.values[1], 10);

      if (document.activeElement.classList.contains('rsh-min')){
        if (evt.key === 'ArrowRight' || evt.key === 'ArrowUp'){
          if (currMin < currMax){
            this.dom.input.values[0] = currMin + this.settings.step;
            this.update();
          }
        }

        if (evt.key === 'ArrowLeft' || evt.key === 'ArrowDown'){
          if (currMin >= this.settings.min){
            this.dom.input.values[0] = currMin - this.settings.step;
            this.update();
          }
        }
      }

      if (document.activeElement.classList.contains('rsh-max')){
        if (evt.key === 'ArrowRight' || evt.key === 'ArrowUp'){
          if (currMax <= this.settings.max){
            this.dom.input.values[1] = currMax + this.settings.step;
            this.update();
          }
        }

        if (evt.key === 'ArrowLeft' || evt.key === 'ArrowDown'){
          if (currMax > currMin){
            this.dom.input.values[1] = currMax - this.settings.step;
            this.update();
          }
        }
      }
    }
  }

  /**
   * Add event listeners.
   * @private
   */
  _addEventListeners() {
    // throttle the scroll callback for performance

    document.addEventListener('scroll', this.listeners.scroll, false);

    if (this.settings.multiple){
      this.dom.handle.forEach((node) => {
        node.addEventListener('keydown', this.listeners.keyDown, false);
        node.addEventListener('keyup', this.listeners.keyUp, false);
      });
    } else {
      this.dom.input.addEventListener('keyup', this.listeners.keyUp, false);
    }

    // throttle the resize callback for performance

    window.addEventListener('resize', this.listeners.resize, false);

    // detect native change event

    this.dom.input.addEventListener('change', this.listeners.change, false);

    if (this.touch) {
      this.dom.container.addEventListener('touchstart', this.listeners.touchstart, false);
    } else {
      this.dom.container.addEventListener('mousedown', this.listeners.down);
    }

    // detect form reset

    if (this.dom.input.form) {
      this.dom.input.form.addEventListener('reset', this.listeners.reset, false);
    }
  }

  /**
   * Remove event listeners.
   * @private
   */
  _removeEventListeners() {

    if (this.touch) {
      this.dom.container.removeEventListener('touchstart', this.listeners.touchstart);
    } else {
      this.dom.container.removeEventListener('mousedown', this.listeners.down);
    }

    if (this.settings.multiple){
      this.dom.handle.forEach((node) => {
        node.removeEventListener('keyup', this.listeners.keyUp, false);
      });
    } else {
      this.dom.input.removeEventListener('keyup', this.listeners.keyUp, false);
    }
    // remove scroll listener

    document.removeEventListener('scroll', this.listeners.scroll);

    // remove resize listener

    window.removeEventListener('resize', this.listeners.resize);

    // remove input listener

    this.dom.input.removeEventListener('change', this.listeners.change);

    // remove form listener

    if (this.dom.input.form) {
      this.dom.input.form.removeEventListener('reset', this.listeners.reset);
    }

    this.listeners = null;
  }

  /**
   * Create DOM element helper.
   * @private
   * @param {String} type - html element type.
   * @param {Object} obj - object.
   * @return {HTMLElement} el - element helper.
   */
  _createElement(type, obj) {
    const el = document.createElement(type);

    if (typeof obj === 'string') {
      el.classList.add(obj);
    } else if (obj === Object(obj)) {
      for (const prop in obj) {
        if (prop in el) {
          el[prop] = obj[prop];
        } else {
          el.setAttribute(el[prop], obj[prop]);
        }
      }
    }

    return el;
  }

  /**
   * Check if function is really a function.
   * @private
   * @param {Function} func - function.
   * @return {Boolean} - true or false.
   */

  _isFunction(func) {
    return func && typeof func === 'function';
  }

  /**
   * Enhance slider performance.
   * @private
   * @param {Function} fn - function.
   * @param {Number} limit - limit.
   * @param {Object} context - object context.
   */
  _throttle(fn, limit, context) {
    let wait;

    return function () {

      context = context || this;

      if (!wait) {
        fn.apply(context, arguments);
        wait = true;

        return setTimeout(function () {
          wait = false;
        }, limit);
      }
    };
  }
}
