/**
 * @file Module to create Timeline component.
 */

/**
 * Class representing a timeline.
 */
export class Timeline {

  /**
   * Setup timeline properties.
   * @param {HTMLElement} element - a DOM element conaining the timeline.
   * @param {Object} data - a JSON-formatted object containing the timeline data.
   */
  constructor (element, data = null) {
    this.container = element;
    this.mainList = null;
    this.entries = JSON.parse(JSON.stringify(data));
    this.selected = null;
    this.counter = 0;
    this.focus = 0;
    this.resizeObserver = null;
    this.dateGroups = [];
    this.options = {
      sorting: 'order',
      order: 'dsc',
      from: null,
      to: null,
      selectable: false,
      headings: false,
      collapsible: false,
      locale: 'en-US',
      timeFormat: {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric'
      }
    };
    this.listeners = {
      document: [],
      entries: []
    };
  }

  /**
   * Initialize timeline
   * @public
   */
  init(options) {
    this.update(options);
    this._setResizeObserver();
  }

  /**
   * Update the timeline
   * @public
   * @param {Object} options - an object containing the timeline options.
   */
  update(options) {
    if (this.entries) {
      this.destroy();
      this._setProps(options);
      this._setMainList();
      this._addMainListClasses();
      this._formatDataAndGenerateContents();
      this._addGeneralListeners();
      this._setStickyHeaders();
    }
  }

  /**
   * Remove event listeners and resize observer
   * @public
   */
  destroy() {
    const listeners = this.listeners.entries.concat(this.listeners.document);
    if (listeners.length > 0) {
      listeners.forEach(({ action, element, handler }) => {
        element.removeEventListener(action, handler);
      });
    }
    if (this.resizeObserver) {
      this.resizeObserver.unobserve(this.container);
    }
  }

  /**
   * Set timeline properties.
   * @private
   * @param {Object} options - an object containing the timeline options.
   */
  _setProps(options) {
    for (const prop in options) {
      if (this.options.hasOwnProperty(prop)) {
        this.options[prop] = options[prop];
      }
    }
  }

  /**
   * Create the main list or clear its contents
   * @private
   */
  _setMainList() {
    if (!this.mainList) {
      this._createMainList();
    } else {
      this._clearMainList();
    }
  }

  /**
   * Create the main list element and append
   * @private
   */
  _createMainList(){
    this.mainList = document.createElement('UL');
    this.mainList.classList.add('main-list');
    this.container.appendChild(this.mainList);
  }

  /**
   * Clear the contents of the main list
   * @private
   */
  _clearMainList() {
    this.mainList.innerHTML = '';
  }

  /**
   * Add classes to main list based on timeline options
   * @private
   */
  _addMainListClasses() {
    const mainListClasses = ['selectable', 'headings'];
    mainListClasses.forEach((timelineClass) => {
      this._toggleClass(
        this.mainList,
        this.options[timelineClass],
        timelineClass
      );
    });
  }

  /**
   * Add or remove a class based on a condition
   * @private
   * @param {HTMLElement} element - the element on which to toggle the class.
   * @param {Boolean} condition - a condition to determine whether to add or remove the class.
   * @param {String} className - a string representing the class name to toggle.
   */
  _toggleClass(element, condition, className){
    if (condition) {
      element.classList.add(className);
    } else {
      element.classList.remove(className);
    }
  }

  /**
   * Format entry data and generate timeline DOM contents
   * @private
   */
  _formatDataAndGenerateContents() {
    this._formatEntryData(this.entries);
    const constrained = this._constrainEntries();
    this._generateTimelineContents(this.mainList, constrained);
  }

  /**
   * Format and add entry data
   * @private
   * @param {Array} entries - a collection of objects representing the entries.
   */
  _formatEntryData(entries) {
    entries.forEach(entry => {
      this._setEntryOrder(entry);
      this._parseTimestamp(entry);
      this._formatSubTimeline(entry);
    });
    this._sortEntries(entries);
  }

  /**
   * Set entry "order" attribute
   * @private
   * @param {Object} entry - an object representing an entry.
   */
  _setEntryOrder(entry) {
    if (entry.order === undefined) {
      entry.order = this.counter;
      this.counter += 1;
    }
  }

  /**
   * Format timestamp if available
   * @private
   * @param {Object} entry - an object representing an entry.
   */
  _parseTimestamp(entry) {
    if (entry.timestamp) {
      entry.timestamp = this._parseDate(entry.timestamp);
    }
  }

  /**
   * Parse date string if its not already a Date object
   * @private
   * @param {String} value - a Date value or a string representing a date.
   */
  _parseDate(value) {
    if(value instanceof Date){
      return value;
    }
    return new Date(value);
  }

  /**
   * Format sub-timeline if available
   * @private
   * @param {Object} entry - an object representing an entry.
   */
  _formatSubTimeline(entry) {
    if (entry.timeline) {
      this._formatEntryData(entry.timeline);
    }
  }

  /**
   * Sot entries based on sorting value and order
   * @private
   * @param {Array} entries - a collection of objects representing entries.
   */
  _sortEntries(entries) {
    entries.sort((a, b) => {
      if (this.options.order === 'dsc') {
        return b[this.options.sorting] - a[this.options.sorting];
      }
      return a[this.options.sorting] - b[this.options.sorting];
    });
  }

  /**
   * Apply lower and upper limits to which entries are shown based on sorting value
   * @private
   */
  _constrainEntries() {
    const {from, to} = this.options;
    return this.entries.filter(entry =>
      (!from || this._getSortValue(entry) >= this._getTimeIfDate(from))
        && (!to || this._getSortValue(entry) <= this._getTimeIfDate(to))
    );
  }

  /**
   * Get sorting value of entry
   * @private
   * @param {Object} entry - an object representing an entry.
   */
  _getSortValue(entry) {
    return this._getTimeIfDate(entry[this.options.sorting]);
  }

  /**
   * Get time value of date if "timestamp" is set as sorting value
   * @private
   * @param {Any} entry - a value from which to extract a time.
   */
  _getTimeIfDate(value) {
    if (this.options.sorting === 'timestamp') {
      return this._parseDate(value).getTime();
    }
    return value;
  }

  /**
   * Generate entries and append to timeline
   * @private
   * @param {HTMLElement} list - a DOM element on which to append entries.
   * @param {Array} entries - a collection of objects representing entries.
   */
  _generateTimelineContents(list = this.mainList, entries = this.entries) {
    let lastEntry = null;
    let entryList = list;
    entries.forEach(entry => {
      if (this._dateGroupIsNeeded(lastEntry, entry)){
        entryList = this._addDateGroup(entry, list);
      }
      this._generateEntry(entry, entryList);
      this._addScheduledClass(entry, lastEntry);
      lastEntry = entry;
    });
  }

  /**
   * Determine if a dategroup should be created
   * @private
   * @param {Object} lastEntry - an object representing the previous entry.
   * @param {Object} entry - an object representing the current entry.
   */
  _dateGroupIsNeeded(lastEntry, entry) {
    return this.options.sorting === 'timestamp'
      && this.options.headings
      && this._dayIsDifferent(lastEntry, entry);
  }

  /**
   * Determine if the day of the current date is different from the previous
   * @private
   * @param {Object} lastEntry - an object representing the previous entry.
   * @param {Object} entry - an object representing the current entry.
   */
  _dayIsDifferent(lastEntry, entry) {
    if (!lastEntry) {
      return true;
    }
    const trimmedLastDate = this._trimDate(lastEntry.timestamp);
    const trimmedCurrentDate = this._trimDate(entry.timestamp);
    return trimmedLastDate.getTime() !== trimmedCurrentDate.getTime();
  }

  /**
   * Set hours, minutes, seconds and milis to 0 to compare dates
   * @private
   * @param {Date} date - an object representing an entry.
   */
  _trimDate(date) {
    const newDate = new Date(date);
    newDate.setHours(0, 0, 0, 0);
    return newDate;
  }

  /**
   * Create a dateGroup and return its entryList
   * @private
   * @param {Object} entry - an object representing an entry.
   * @param {HTMLElement} list - a DOM element on which to append entries.
   */
  _addDateGroup(entry, list) {
    const heading = this._createDateGroupHeading(entry.timestamp);
    const dateGroup = this._createDateGroup(heading);
    this.dateGroups.push(dateGroup.container);
    const entryList = dateGroup.entryList;
    list.appendChild(dateGroup.container);
    return entryList;
  }

  /**
   * Create the dateGroup label DOM element
   * @private
   * @param {Date} timestamp - a Date object representing a timestamp.
   */
  _createDateGroupHeading(timestamp) {
    const options = { month: 'long', day: 'numeric', year: 'numeric' };
    const dateFormat = new Intl.DateTimeFormat(this.options.locale, options);
    const text = dateFormat.format(timestamp);
    const scheduledClass = timestamp > new Date() ? ' to-scheduled' : '';
    return `<div class="heading${scheduledClass}">
        <span class="label">${text}</span>
    </div>`;
  }

  /**
   * Create the dateGroup DOM element
   * @private
   * @param {HTMLElement} heading - a DOM element representing the dateGroup heading.
   */
  _createDateGroup(heading) {
    const container = document.createElement('LI');
    container.classList.add('date-group');
    container.innerHTML = heading;
    const entryList = document.createElement('UL');
    entryList.classList.add('entry-list');
    container.appendChild(entryList);
    return { container, entryList };
  }

  /**
   * Create an entry
   * @private
   * @param {Object} entry - an object representing an entry.
   * @param {HTMLElement} entryList - a DOM element on which to append entries.
   */
  _generateEntry(entry, entryList) {
    this._createEntryElement(entry);
    this._addIconClass(entry);
    this._registerEntryEvents(entry);
    this._addCollapseButton(entry);
    this._generateSubTimeline(entry);
    entryList.appendChild(entry.element);
  }

  /**
   * Create the entry DOM element
   * @private
   * @param {Object} entry - an object representing an entry.
   */
  _createEntryElement(entry) {
    const element = document.createElement('LI');
    element.classList.add('entry');
    const template = `
      <div class="target"${this._tabIndex()}>
        ${this._displayTime(entry)}
        ${this._displayTitle(entry)}
        ${this._displayStatus(entry)}
        ${this._displayContent(entry)}
      </div>`;
    element.innerHTML = template;
    entry.target = element.querySelector('.target');
    entry.element = element;
  }

  /**
   * Generat the tabIndex attribute if timeline is selectable
   * @private
   */
  _tabIndex() {
    return this.options.selectable ?
      'tabIndex="0"' : '';
  }

  /**
   * Create the timestamp DOM element if available
   * @private
   * @param {Object} entry - an object representing an entry.
   */
  _displayTime(entry) {
    return entry.timestamp ? `
      <time class="time" datetime="">
        ${this._formatTime(entry.timestamp)}
      </time>` : '';
  }

  /**
   * Format the timestamp based on locale and provided format
   * @private
   * @param {Date} time - an Date object to format based on the locale and provided format.
   */
  _formatTime(time) {
    return time.toLocaleString(this.options.locale, this.options.timeFormat);
  }

  /**
   * Create the timestamp DOM element if available
   * @private
   * @param {Object} entry - an object representing an entry.
   */
  _displayTitle(entry) {
    return entry.title ? `<h4 class="title">${entry.title}</h4>` : '';
  }

  /**
   * Create the status DOM element if available
   * @private
   * @param {Object} entry - an object representing an entry.
   */
  _displayStatus(entry) {
    if (entry.status) {
      let status = '';
      entry.status.forEach(s => {
        status += `<span class="icon-${s.icon}">${s.label}</span>`;
      });
      return `<span class="status">${status}</span>`;
    }
    return '';
  }

  /**
   * Create the content DOM element if available
   * @private
   * @param {Object} entry - an object representing an entry.
   */
  _displayContent(entry) {
    return entry.content ? `<div class="content">${entry.content}</div>` : '';
  }

  /**
   * Add class name for main icon
   * @private
   * @param {Object} entry - an object representing an entry.
   */
  _addIconClass(entry) {
    if(entry.icon) {
      entry.element.classList.add(`icon-${entry.icon}`);
    }
  }

  /**
   * Register entry events if timeline is selectable
   * @private
   * @param {Object} entry - an object representing an entry.
   */
  _registerEntryEvents(entry) {
    if (this.options.selectable){
      this._registerListener(entry.target, 'click', () => {
        this._selectEntry(entry);
      });
      this._registerListener(entry.target, 'keyup', (event) => {
        if(event.key === 'Enter') {
          this._deselectEntry();
          this._selectEntry(entry);
        }
      });
      this._registerListener(entry.target, 'focus', () => {
        this.focus = this._getIndex(entry);
      });
    }
  }

  /**
   * Add event listeners and save a reference to them
   * @private
   * @param {HTMLElement} element - the target DOM element.
   * @param {String} action - A string representing the event.
   * @param {Function} handler - the event handler.
   */
  _registerListener(element, action, handler) {
    element.addEventListener(action, handler);
    if (element === document) {
      this.listeners.document = { action, element, handler };
    } else {
      this.listeners.entries.push({ action, element, handler });
    }
  }

  /**
   * Mark an entry as selected and dispatch event
   * @private
   * @param {Object} entry - an object representing an entry.
   */
  _selectEntry(entry) {
    this.selected = entry.element;
    this.selected.classList.add('active');
    const event = new CustomEvent('selectEntry', {
      detail: {
        ...entry,
      }
    });
    event.detail[this.options.sorting] = entry[this.options.sorting];
    document.dispatchEvent(event);
  }

  /**
   * Unmark element as selected
   * @private
   */
  _deselectEntry() {
    if (this.selected) {
      this.selected.classList.remove('active');
    }
  }

  /**
   * Get index of a specified entry
   * @private
   * @param {Object} targetEntry - an object representing an entry.
   */
  _getIndex(targetEntry) {
    return this.entries.findIndex(entry =>
      entry === targetEntry
    );
  }

  /**
   * Add a button to collapse contents if "collapsible" option is set to true
   * @private
   * @param {Object} entry - an object representing an entry.
   */
  _addCollapseButton(entry){
    if(this.options.collapsible){
      const collapseElement = document.createElement('BUTTON');
      collapseElement.classList.add('collapse-btn');
      this._registerListener(collapseElement, 'click', (event) => {
        event.stopPropagation();
        event.preventDefault();
        entry.element.classList.toggle('collapsed');
      });
      entry.target.appendChild(collapseElement);
    }
  }

  /**
   * Generate nested timeline if available
   * @private
   * @param {Object} entry - an object representing an entry.
   */
  _generateSubTimeline(entry) {
    if (entry.timeline){
      const subTimeline = document.createElement('UL');
      entry.element.appendChild(subTimeline);
      this._generateTimelineContents(subTimeline, entry.timeline);
    }
  }

  /**
   * Add classes for scheduled entries
   * @private
   * @param {Object} entry - an object representing the current entry.
   * @param {Object} lastEntry - an object representing the previous entry
   */
  _addScheduledClass(entry, lastEntry) {
    if (this.options.sorting === 'timestamp') {
      this._addClassIfScheduled(lastEntry, entry, 'to-scheduled');
      this._addClassIfScheduled(entry, entry, 'scheduled');
    }
  }

  /**
   * Add class if entry is in the future
   * @private
   * @param {Object} entry - an object representing an entry.
   * @param {Object} reference - an object representing an entry.
   * @param {String} className - a string representing a class name.
   */
  _addClassIfScheduled (entry, reference, className) {
    if(entry && reference.timestamp > new Date()){
      entry.element.classList.add(className);
    }
  }

  /**
   * Add document and container listeners if timeline is selectable
   * @private
   */
  _addGeneralListeners() {
    if(this.options.selectable) {
      this._registerListener(document, 'mouseup', this._deselectEntry.bind(this));
      this._registerListener(this.container, 'keydown', this._keyboardNav.bind(this));
    }
  }

  /**
   * Handle the keyboard navigation
   * @private
   * @param {Event} event - an event.
   */
  _keyboardNav(event) {
    const keyCodes = this._getKeyCodes();
    this._updateFocus(event, keyCodes);
    this._constrainFocus();
    this._setFocus(event, keyCodes);
  }

  /**
   * Get relevant keycodes depending on layout of timeline
   * @private
   */
  _getKeyCodes() {
    const next = this._isHorizontal() ? 'ArrowRight' : 'ArrowDown';
    const prev = this._isHorizontal() ? 'ArrowLeft' : 'ArrowUp';
    return { prev, next };
  }

  /**
   * Determine whetner timeline is horizontal or not
   * @private
   */
  _isHorizontal() {
    return this.container.classList.contains('horizontal') &&
      !this.container.classList.contains('compact');
  }

  /**
   * Update the focus index based on the key pressed
   * @private
   * @param {Event} event - a keydown event.
   * @param {String} prev - the keycode that indicates a navigaton to the previous element.
   * @param {String} next - the keycode that indicates a navigation to the next element.
   */
  _updateFocus(event, { prev, next }) {
    if (event.key === next) {
      this.focus += 1;
    } else if(event.key === prev) {
      this.focus -= 1;
    }
  }

  /**
   * Prevent the focus index from exceding the length of elements or being less than 0
   * @private
   */
  _constrainFocus() {
    if(this.focus >= this.entries.length){
      this.focus = 0;
    }
    if(this.focus < 0) {
      this.focus = this.entries.length - 1;
    }
  }

  /**
   * Set focus on the relevant DOM element
   * @private
   * @param {Event} event - a keydown event.
   * @param {String} prev - the keycode that indicates a navigaton to the previous element.
   * @param {String} next - the keycode that indicates a navigation to the next element.
   */
  _setFocus(event, { prev, next }) {
    if(event.key === prev || event.key === next) {
      event.preventDefault();
      this.entries[this.focus].target.focus();
    }
  }

  /**
   * Register the scroll event for the main list
   * @private
   */
  _setStickyHeaders() {
    if (this.options.sorting === 'timestamp' && this.options.headings) {
      this._registerListener(this.mainList, 'scroll', this._throttle(this._scrollHandler, 100));
    }
  }

  /**
   * Set a minimum interval for the handler function to be triggered
   * @private
   * @param {Function} handler - the handler function to be triggered.
   * @param {Number} interval - the minimum interval for triggering the handler function.
   */
  _throttle(handler, interval) {
    let scroll = true;
    let timeout = null;
    setInterval(() => {
      scroll = true;
    }, interval);
    return (event) => {
      if (scroll) {
        handler.bind(this)(event);
      }
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        handler.bind(this)(event);
      }, 0);
      scroll = false;
    };
  }

  /**
   * toggle classes on dategroups based on the scroll position to achieve sticky headings
   * @private
   * @param {Event} event - a scroll event.
   */
  _scrollHandler(event) {
    const { target } = event;
    const minEntryWidth = 250;
    const minEntryHeight = 48;
    const scroll = this._isHorizontal() ? 'scrollLeft' : 'scrollTop';
    const start = this._isHorizontal() ? 'offsetLeft' : 'offsetTop';
    const size = this._isHorizontal() ? 'offsetWidth' : 'offsetHeight';
    const offset = this._isHorizontal() ? minEntryWidth : minEntryHeight;
    this.dateGroups.forEach((dateGroup) => {
      if(!this._isSubTimeline(dateGroup)) {
        const relativeStart = dateGroup[start];
        const reachedStart = relativeStart < target[scroll];
        const reachedEnd = (relativeStart + dateGroup[size] - offset) < target[scroll];
        this._toggleClass(dateGroup, reachedStart, 'timeline-sticky');
        this._toggleClass(dateGroup, reachedEnd,'fade');
      }
    });
  }

  /**
   * Check if dateGroup is inside a sub-timeline
   * @private
   * @param {HTMLElement} dateGroup - A DOM element representing an dateGroup.
   */
  _isSubTimeline(dateGroup) {
    return dateGroup.offsetParent.classList.contains('entry');
  }

  /**
   * Set a resize observer tu adjust layout of timeline based on container width
   * @private
   */
  _setResizeObserver() {
    if (typeof ResizeObserver !== 'undefined') {
      this.resizeObserver = new ResizeObserver(entries => {
        for (const entry of entries) {
          this._toggleClass(
            entry.target,
            entry.contentRect.width < 500,
            'compact'
          );
        }
      });
      this.resizeObserver.observe(this.container);
    }
  }

  /**
   * Add one or several entries to the timeline
   * @public
   * @param {(Object|Array)} entries - an object or a collection of objects representing entries.
   */
  addEntries(entries) {
    this._clearMainList();
    this.entries = this.entries.concat(entries);
    this._formatDataAndGenerateContents();
  }

  /**
   * Remove one or several entries from the timeline given their indices
   * @public
   * @param {(Number|Number[])} collection - an index or collection of indices representing one or several entries.
   */
  removeEntries(collection) {
    return this._removeEntriesBy(collection);
  }

  /**
   * Remove one or several entries using the specified remove function
   * @public
   * @param {(Any|Array)} collection - a value or collection of values representing one or several entries.
   * @param {Function} [removeFunction = this._removeEntry] - a function to apply for the removal of each entry.
   */
  _removeEntriesBy(collection, removeFunction = this._removeEntry) {
    const results = [];
    const toBeRemoved = [].concat(collection);
    toBeRemoved.forEach(reference => {
      const result = removeFunction.bind(this)(reference);
      results.push(result);
    });
    return results;
  }

  /**
   * Remove an entry given its index
   * @public
   * @param {Number} index - the index of the entry to remove.
   */
  _removeEntry(index) {
    if (this.entries[index]) {
      this._clearMainList();
      this._unregisterEntry(index);
      this._formatDataAndGenerateContents();
      return index;
    }
    return -1;
  }

  /**
   * Unregister an entry from this.entries given its index
   * @public
   * @param {Number} index - the index of the entry to unregister.
   */
  _unregisterEntry(index) {
    this.entries.splice(index, 1);
  }

  /**
   * Remove one or several entries from the timeline given their sorting values
   * @public
   * @param {(Any|Array)} collection - a value or collection of values representing one or several entries.
   */
  removeEntriesBySortValue(collection) {
    return this._removeEntriesBy(collection, this._removeEntryBySortValue);
  }

  /**
   * Remove one or several entries from the timeline given their sorting values
   * @public
   * @param {Any} reference - a value representing an entry.
   */
  _removeEntryBySortValue(reference){
    const index = this._sortValueToIndex(reference);
    return this._removeEntry(index);
  }

  /**
   * Obtain the index of an entry given its sorting value
   * @public
   * @param {Any} sortValue - a sorting value representing an entry.
   */
  _sortValueToIndex(sortValue) {
    return this.entries.findIndex(entry =>
      this._getSortValue(entry) === this._getTimeIfDate(sortValue)
    );
  }
}
