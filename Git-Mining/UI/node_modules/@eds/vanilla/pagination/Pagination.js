import { Select } from '../select/Select';

/**
 * @file Module to create Pagination component.
 */

const MAX_PAGES = 7;

/**
 * Class representing a pagination.
 */
export class Pagination {

  /**
   * Setup properties.
   * @param {HTMLElement} element - The DOM element to append the component.
   */
  constructor(element) {
    this.dom = {
      paginationGroup: element,
      paginationInput: element.querySelector('.actions input[type="number"]'),
      paginationSelect: element.querySelector('.actions .select')
    };
    this.state = {
      currentPage: 1,
      hasNextPage: false,
      hasPreviousPage: false,
      numEntries: 0,
      numPerPage: 0,
      numPages: 0,
      pageClicked: 0,
    };
    this.events = {
      paginationChangePage: new CustomEvent('paginationChangePage', {
        detail: { state: this.state },
      }),
      paginationChangeSelect: new CustomEvent('paginationChangeSelect', {
        detail: { state: this.state },
      }),
    };
    this.listeners = {
      pagination: [],
      inputChange: (evt) => this._onInputChange(evt),
      selectChange: (evt) => {
        const val = evt.detail.value[0];
        this.state.numPerPage = (val.toLowerCase() === 'all') ? this.state.numEntries : +val;
        this._onSelectChange();
      }
    };
  }

  /**
   * Create component.
   * @public
   * @param {number} num - Number of pages / entries.
   */
  init(num) {
    let nPages = num;

    // For pagination with select
    if (this.dom.paginationSelect) {
      const select = new Select(this.dom.paginationSelect);
      select.init();

      this._setNumEntries(num);
      this.state.numPerPage = +select.dom.current.innerHTML;
      nPages = this._calcNumPages();
    }

    this._setNumPages(nPages);
    this._injectPaginationControls();
    this._addEventListeners();
  }

  /**
   * Destroy component.
   * @public
   */
  destroy() {
    this._removeEventListeners();
  }

  /**
   * Add event listeners.
   * @private
   */
  _addEventListeners() {
    const paginationArray = Array.from(this.dom.paginationGroup.querySelectorAll('.pagination li'));
    this.listeners.pagination = paginationArray.map((item) => {
      const listener = (evt) => {
        evt.preventDefault();

        // Do nothing if clicked on current page or disabled element
        if (evt.target.classList.contains('disabled') || this.state.currentPage === +evt.target.dataset.value) {
          return;
        }

        this.state.pageClicked = item.dataset.value;
        this._updatePaginationDOM();

        // Deprecated. Dispatch event on pagination element instead
        document.dispatchEvent(this.events.paginationChangePage);

        // Add event listener to event 'paginationChangePage'
        this.dom.paginationGroup.dispatchEvent(this.events.paginationChangePage);
      };
      item.addEventListener('click', listener);
      return [item, listener];
    });

    if (this.dom.paginationInput) {
      this.dom.paginationInput.addEventListener('change', this.listeners.inputChange);
    }

    if (this.dom.paginationSelect) {
      this.dom.paginationSelect.addEventListener('selectOption', this.listeners.selectChange);
    }
  }

  /**
   * Remove event listeners.
   * @private
   */
  _removeEventListeners() {
    this.listeners.pagination.forEach(pair => {
      const [item, listener] = pair;
      item.removeEventListener('click', listener);
    });
    this.listeners.pagination = [];

    if (this.dom.paginationInput) {
      this.dom.paginationInput.removeEventListener('change', this.listeners.inputChange);
    }

    if (this.dom.paginationSelect) {
      this.dom.paginationSelect.removeEventListener('selectOption', this.listeners.selectChange);
    }
  }

  /**
   * Update pagination when click on arrow or page number.
   * @private
   */
  _updatePaginationDOM() {
    this._updateCurrentPage();
    this._setPaginationControls();
  }

  /**
   * Update state of current page.
   * @private
   */
  _updateCurrentPage() {
    if (this.state.numPages < 2) {
      return;
    }

    if (this.state.pageClicked.includes('left')) {
      if (this.state.currentPage > 1) {
        this.state.currentPage -= 1;
      }
    }
    // - Right arrow
    else if (this.state.pageClicked.includes('right')) {
      if (this.state.currentPage < this.state.numPages) {
        this.state.currentPage += 1;
      }
    } else if (this.state.pageClicked.length !== 0) {
      this.state.currentPage = parseInt(this.state.pageClicked, 10);
    }

    this.state.hasNextPage = true;
    this.state.hasPreviousPage = true;
    if (this.state.currentPage === 1) {
      this.state.hasNextPage = true;
      this.state.hasPreviousPage = false;
    }
    if (this.state.currentPage === this.state.numPages) {
      this.state.hasNextPage = false;
      this.state.hasPreviousPage = true;
    }
  }

  _calcNumPages() {
    // Pagination should have at least 1 page
    return Math.ceil(this.state.numEntries / this.state.numPerPage) || 1;
  }

  /**
   * Save number of pages to property.
   * @private
   * @param {number} nPages - Number of pages.
   */
  _setNumPages(nPages) {
    this.state.numPages = nPages;

    if (nPages > 1) {
      this.state.hasNextPage = true;
    }

    if (this.dom.paginationInput) {
      this.dom.paginationInput.setAttribute('max', nPages);
    }
  }

  _setNumEntries(nEntries) {
    this.state.numEntries = nEntries;
  }

  /**
   * Generate pagination controls dynamically.
   * @private
   */
  _injectPaginationControls() {
    const pagination = this.dom.paginationGroup.querySelector('.pagination');
    pagination.innerHTML = '';

    const leftArrow = this._genArrowControl('left', this.state.hasPreviousPage);
    const rightArrow = this._genArrowControl('right', this.state.hasNextPage);

    // Inject Left arrow
    pagination.appendChild(leftArrow);

    // Create empty page controls
    for (let i = 1; i <= Math.min(MAX_PAGES, this.state.numPages); i += 1) {
      pagination.appendChild(this._genPageControl('', false));
    }

    // Inject Right arrow
    pagination.appendChild(rightArrow);

    // Update empty page controls with real values
    this._setPaginationControls();
  }

  /**
   * Modifies the values of the DOM pages.
   * @private
   */
  _setPaginationControls() {
    const currentPage = parseInt(this.state.currentPage, 10);
    const numPages = parseInt(this.state.numPages, 10);
    const paginationArray = [];


    paginationArray.push({ label: 'left', state: false });

    /*
     * Set all pages, ie: 1 2 3 4 5 6 7
     */
    if (numPages <= MAX_PAGES) {
      for (let i = 1; i <= numPages; i += 1) {
        paginationArray.push({label: i, state: this._isCurrentPage(i)});
      }
    }
    else {
      if (currentPage < 5) {

        /*
         * Set pages in the beginning
         * Pattern: from 1 to (MAX_PAGES - 2) ... last page
         * ie: 1 2 3 [4] 5 ... 10
         */
        for (let i = 1; i <= 5; i += 1) {
          paginationArray.push({label: i, state: this._isCurrentPage(i)});
        }
        paginationArray.push({label: '', state: false});
        paginationArray.push({label: this.state.numPages, state: false});

      } else if (currentPage < numPages - 3) {

        /*
         * Set pages in the middle
         * Pattern: 1 ... n-1 n n+1 ... last page (n is current page)
         * ie: 1 ... 4 [5] 6 ... 10
         */
        paginationArray.push({label: '1', state: false});
        paginationArray.push({label: '', state: false});
        for (let i = currentPage - 1; i <= currentPage + 1; i += 1) {
          paginationArray.push({label: i, state: this._isCurrentPage(i)});
        }
        paginationArray.push({label: '', state: false});
        paginationArray.push({label: this.state.numPages, state: false});
      } else {

        /*
         * Set pages in the end
         * Pattern: 1 ... last (MAX_PAGES - 2) pages
         * ie: 1 ... 6 [7] 8 9 10
         */
        paginationArray.push({label: 1, state: false});
        paginationArray.push({label: '', state: false});
        for (let i = numPages - 4; i <= numPages; i += 1) {
          paginationArray.push({label: i, state: this._isCurrentPage(i)});
        }
      }
    }

    paginationArray.push({ label: 'right', state: false });

    const lis = this.dom.paginationGroup.querySelectorAll('.pagination li');

    Array.from(lis).forEach((item, i) => {
      const label = paginationArray[i].label;
      const state = paginationArray[i].state;
      if (label === 'left') {
        this._setArrowControl(item, 'left', this.state.hasPreviousPage);
      } else if (label === 'right') {
        this._setArrowControl(item, 'right', this.state.hasNextPage);
      } else {
        this._setPageControl(item, label, state);
      }
    });
  }

  /**
   * Create li element for arrow control.
   * @private
   * @param {string} direction - Left / right arrow.
   * @param {boolean} state - True if has previous / next page.
   * @return {HTMLElement} li - Created 'li' element.
   */
  _genArrowControl(direction, state) {
    const li = document.createElement('li');
    const a = document.createElement('a');
    const i = document.createElement('i');
    li.classList.add(`${direction}-arrow`);
    if (state) {
      li.classList.remove('disabled');
    } else {
      li.classList.add('disabled');
    }
    li.dataset.value = direction;
    i.classList.add('icon');
    i.classList.add(`icon-arrow-${direction}`);
    a.setAttribute('href', '#');
    a.appendChild(i);
    li.appendChild(a);
    return li;
  }

  /**
   * Create li element for page control.
   * @private
   * @param {string} label - Inner text (page number).
   * @param {boolean} state - True if the page is current.
   * @return {HTMLElement} li - Created 'li' element.
   */
  _genPageControl(label, state) {
    const li = document.createElement('li');


    if (state) {
      li.classList.add('active');
    }
    li.dataset.value = label;

    if (label){
      const a = document.createElement('a');

      a.href = '#';
      a.innerText = label;
      li.appendChild(a);
    }

    return li;
  }

  /**
   * Modify arrow control.
   * @private
   * @param {HTMLElement} element - 'li' element to be updated.
   * @param {string} direction - Left of Right arrow.
   * @param {boolean} state - True if has previous / next page.
   */
  _setArrowControl(element, direction, state) {
    const i = element.querySelector('i');
    element.classList.add(`${direction}-arrow`);
    if (state) {
      element.classList.remove('disabled');
    } else {
      element.classList.add('disabled');
    }
    element.dataset.value = direction;
    i.classList.add('icon');
    i.classList.add(`icon-arrow-${direction}`);
  }

  /**
   * Modify page control.
   * @private
   * @param {HTMLElement} element - 'li' element to be updated.
   * @param {string} label - Inner text (page number).
   * @param {boolean} state - True if the page is current.
   */
  _setPageControl(element, label, state) {
    if (state) {
      element.classList.add('active');
    } else {
      element.classList.remove('active');
    }
    element.dataset.value = label;

    if (label){
      element.innerHTML = '';

      const a = document.createElement('a');

      a.href = '#';
      a.innerText = label;
      element.appendChild(a);
    } else {
      element.innerText = label;
    }
  }

  /**
   * Check if the page is current.
   * @private
   * @param {number | string} pageNum - Page number to check.
   * @return {boolean} - True if the page is current.
   */
  _isCurrentPage(pageNum) {
    return parseInt(pageNum, 10) === parseInt(this.state.currentPage, 10);
  }

  _onInputChange({target}) {
    const value = Math.max(this.dom.paginationInput.min, Math.min(target.value, this.dom.paginationInput.max));
    this.dom.paginationInput.value = value;

    this.state.pageClicked = value.toString();
    this._updatePaginationDOM();
    this.dom.paginationGroup.dispatchEvent(this.events.paginationChangePage);
  }

  /**
   * Update pagination controls and component state.
   * @private
   */
  _onSelectChange() {
    let pageChangeFlag = false;
    const numPages = this.state.numPages;
    const newNumPages = this._calcNumPages();
    this._setNumPages(newNumPages);

    // E.g. show all entries
    if (this.state.numPages === 1) {
      // Disable arrows
      this.state.hasPreviousPage = false;
      this.state.hasNextPage = false;

      // Set current page to 1
      if (this.state.currentPage !== 1) {
        this.state.currentPage = 1;
        pageChangeFlag = true;
      }
    }

    // If current page greater than new number of pages, go to the last possible page
    if (this.state.currentPage > this.state.numPages) {
      this.state.pageClicked = this.state.numPages.toString();
      this._updateCurrentPage();
      pageChangeFlag = true;
    }

    // Redraw if number of pages change
    if (newNumPages !== numPages) {
      this._injectPaginationControls();
      this._addEventListeners();
    }

    // Used flag because we need to first dispatch select change event, then page change event.
    this.dom.paginationGroup.dispatchEvent(this.events.paginationChangeSelect);
    if (pageChangeFlag) {
      this.dom.paginationGroup.dispatchEvent(this.events.paginationChangePage);
    }
  }

  /**
   * Update pagination state when number of entries change.
   * @public
   * @param {Number} num - new number of entries.
   */
  update(num) {
    this._setNumEntries(num);
    this._onSelectChange();
  }
}
