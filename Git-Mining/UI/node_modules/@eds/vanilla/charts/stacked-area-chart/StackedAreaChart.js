/**
 * @file Component to create line chart
 */

import * as d3 from 'd3';

import { Stage } from '../common/Stage';
import { Axis } from '../common/Axis';
import { Tooltip } from '../common/Tooltip';
import { Legend } from '../common/Legend';
import { ColorScale } from '../common/ColorScale';
import { Format } from '../common/Format';

export class StackedAreaChart {

  /**
   * Setup chart properties
   * @param {Object} props - The properties to initialize the stage
   * @param {Object} props.data - The data necessary to draw the chart
   * @param {HTMLElement} props.element - The DOM element to append the chart
   * @param {number} [props.height] - The height of the chart
   * @param {Object} [props.margin] - The top, right, bottom and left margins
   * @param {number} [props.margin.top] - The top margin
   * @param {number} [props.margin.right] - The right margin
   * @param {number} [props.margin.bottom] - The bottom margin
   * @param {number} [props.margin.left] - The left margin
   * @param {Object} [props.y] - Y axis properties
   * @param {boolean} [props.y.isPercentage] - If Y axis is in percentage
   * @param {string} [props.y.unit] - The Y axis unit
   * @param {number} [props.y.decimalOffset] - Adjust the decimal position of the units
   * @param {string} [props.y.tickFormat] - The Y axis tick format
   * @param {Object} [props.x] - X axis properties
   * @param {boolean} [props.x.scaleType] - The type of scale used for the x-axis
   * @param {string} [props.x.unit] - The X axis unit
   * @param {string} [props.x.tickFormat] - The X axis tick format
   * @param {Object} [props.format] - Format used for line chart data manipulation
   * @param {string} [props.format.input] - Format used to parse the data input
   * @param {Object} [props.tooltip] - Tooltip properties
   * @param {boolean} [props.tooltip.isHidden] - Hide the tooltip
   * @param {Object} [props.tooltip.format] - Format necessary for representing data
   * @param {string} [props.tooltip.format.title] - Time specific format (see D3 formats)
   * @param {string} [props.tooltip.format.value] - Number specific format (see D3 formats)
   */

  constructor(props) {
    this.data = props.data;
    this.element = props.element;
    this.height = props.height || 250;
    this.showTotal = props.showTotal || true;
    this.format = {
      input: '%Y-%m-%d',
      ...props.format
    };
    this.margin = {
      top: 25,
      bottom: 35,
      right: 25,
      left: 35,
      ...props.margin,
    };

    this.tooltip = {
      format: {
        title: null,
        value: '.2f'
      },
      isHidden: false,
      ...props.tooltip,
    };

    this.y = {
      isPercentage: false,
      unit: null,
      decimalOffset: 0,
      ...props.y,
    };

    this.x = {
      scaleType: 'time',
      unit: '',
      ...props.x,
    };

    // params
    this.animationSpeed = 980;
    this.axisPadding = 8;
    this.fontSize = 14;
    this.id = Date.now();
    if (this.y.unit || this._showPercentage()) {
      this.margin.top += this.fontSize + this.axisPadding;
    }
    if (this.x.unit) {
      this.margin.bottom += this.fontSize + this.axisPadding;
    }

    this.isNegative = true;
  }

  /**
   * Determine whether percentage units should be shown
   * @return {boolean} - A boolean representing whether percentage units should be shown
   * @private
   */
  _showPercentage() {
    return this.y.unit === null && this.y.isPercentage;
  }

  /**
   * Initialize the chart
   * @public
   */
  init() {
    this._parseData();
    this._createCommonComponents();

    this.element.classList.add('stacked-area-container');
    this.stage.onResize(this._render.bind(this));
    this.canvas = this.stage.getCanvas();

    this._render();
  }

  /**
   * Filter and format data, set instance variables
   * @param {Object} data - The data to be parsed
   * @private
   */
  _parseData(data) {
    this.data = data || this.data;
    this._parseDates();
    this._sortCommonData(this.data.common, this.x.scaleType);
    this.isNegative = this._isNegative();
    this.stackedData = this._stackData(this.data);
    this.stackedData.summary = this._getSummary(this.stackedData);
  }

  /**
   * Format and parse time data if necessary
   * @private
   */
  _parseDates() {
    if (this.x.scaleType === 'time') {
      this.data.common.forEach((date, i) => {
        if (!(date instanceof Date)) {
          const formatedDate = Format.formatTime(this.format.input)(new Date(date));
          this.data.common[i] = d3.timeParse(this.format.input)(formatedDate);
        }
      });
    }
  }

  /**
   * Sorts the common data in ascending order (date or numerical)
   * @param {array} commonData - array of common continuous data
   * @param {boolean} isDate - specifies if the chart uses Date values
   * @private
   */
  _sortCommonData(commonData, scaleType) {
    // Note: to perform the bisection correctly, the array must be ordered
    if (scaleType === 'time') {
      commonData.sort((a, b) =>
        new Date(a) - new Date(b)
      );
    } else if(scaleType === 'linear'){
      commonData.sort((a, b) => a - b);
    }
  }

  /**
   * Determine whether the chart is negative or not
   * @return {boolean} - A boolean representing whether the chart is negative or not
   * @private
   */
  _isNegative() {
    if(this.y.isPercentage) {
      return false;
    }
    const extreme = this.data.common.map((_, i) =>
      this._addColumn(this.data.series, i)
    ).reduce((a, b) => this._mostExtreme(a, b));
    return extreme < 0;
  }

  /**
   * Determine the most extreme (i.e. most negative or positive) of two values
   * @param {number} a - The first value
   * @param {number} b - The second value
   * @return {number} - The most extreme of the two values
   * @private
   */
  _mostExtreme(a, b) {
    if (Math.abs(a) > Math.abs(b)){
      return a;
    }
    return b;
  }

  /**
   * Generate a copy of the data with a stack of the values in each series
   * @param {Object} data - The data to be copied and stacked
   * @return {Object} - The stacked data
   * @private
   */
  _stackData(data) {
    const stackedData = {};
    stackedData.series = data.series.map((series, i) =>
      this._stackSeries(series, i)
    );
    stackedData.common = data.common;
    return stackedData;
  }

  /**
   * Generate a copy of a series with a stack of the values in each series
   * @param {Object} series - The series to be copied and stacked
   * @param {number} i - The index of the series to be copied and stacked
   * @return {Object} - The stacked series
   * @private
   */
  _stackSeries(series, i) {
    const stackedSeries = {};
    stackedSeries.name = series.name;
    stackedSeries.values = [];
    stackedSeries.stack = series.values.map((v, j) => {
      const colSum = this._addColumn(this.data.series, j, i);
      const value = this._transform(v, j);
      const start = this._transform(colSum, j);
      const end = value + start;
      stackedSeries.values[j] = value;
      return [start, end];
    });
    return stackedSeries;
  }

  /**
   * Add all values that occupy the same position in each series
   * @param {array} seriesArray - An array representing the series
   * @param {number} column - A number representing the index of the column to be added
   * @param {number} limit - A number representing the index of the last series to be added
   * @return {number} - The sum of all values occupying the same position in each series
   * @private
   */
  _addColumn(seriesArray, column, limit) {
    return seriesArray.map((series) => series.values[column])
      .filter((_, i) => this._shouldBeAdded(i, limit, seriesArray.length))
      .reduce((accumulator, value) => accumulator + Number(value), 0);
  }

  /**
   * Determine wheter an entry should be added to the sum of columns
   * @param {number} i - A number representing the index of the entry to be added
   * @param {number} limit - A number representing the index of the last entry to be added
   * @param {number} defaultLimit - A number representing a default limit for negative values
   * @return {boolean} - A boolean representing whether an entry should be added to the sum of columns
   * @private
   */
  _shouldBeAdded(i, limit, defaultLimit) {
    if (this.isNegative) {
      return i < this._useDefault(limit, defaultLimit);
    }
    return i > this._useDefault(limit, -1);
  }

  /**
   * Use the default value when value is undefined
   * @param {number} value - The value to use if not undefined
   * @param {number} defaultValue - The value to use if value is undefined
   * @return {number} - The value of the defualt value, if value is undefined
   * @private
   */
  _useDefault(value, defaultVal) {
    return value === undefined ? defaultVal : value;
  }

  /**
   * Apply transformations to the data based on passed parameters
   * @param {number} value - The value to be transformed
   * @param {number} i - The index of the column that the value belongs to
   * @return {number} - A number, transformed according to parameters
   * @private
   */
  _transform(v, i) {
    const value = Number(v);
    if(this.y.isPercentage) {
      return this._toPercent(value, i);
    }
    if(this.y.decimalOffset !== 0) {
      return this._decimalOffset(value);
    }
    return value;
  }

  /**
   * Convert values to percentages if this.y.isPercentage attribute is true
   * @param {number} value - The value to be converted to percentage
   * @param {number} column - A number representing the index of the column of the value
   * @return {number} - The value converted to a percentage of the max amount in the column provided
   * @private
   */
  _toPercent(value, column){
    return (value * 100) / this._addColumn(this.data.series, column);
  }

  /**
   * Change the order of magnitude of the value by the amount in this.y.decimalOffset
   * @param {number} value - The value to be converted to percentage
   * @return {number} - The value converted to the magnitude indicated by this.y.decimalOffset
   * @private
   */
  _decimalOffset(value){
    return value * (Math.pow(10, this.y.decimalOffset));
  }

  /**
   * Generate the summary data (total, average, etc.)
   * @param {Object} data - The data from which to generate the summary
   * @return {Object} - The summary of the data
   * @private
   */
  _getSummary(data) {
    const summary = [];
    if(this.showTotal){
      summary.push(this._getTotal(data));
    }
    return summary;
  }

  /**
   * Generate the entry for the total
   * @param {Object} data - The data from which to generate the total
   * @return {Object} - An object containing the total amounts
   * @private
   */
  _getTotal(data) {
    return {
      name: 'Total',
      values: this._getTotalValues(data)
    };
  }

  /**
   * Get the sum of all values for each point in the common
   * @param {Object} data - The data from which to generate the total
   * @return {Array} - An array containing the sum of all values for each point in the commmon
   * @private
   */
  _getTotalValues(data) {
    return data.series.length > 0 ? data.common.map((_, i) =>
      this._addColumn(data.series, i)
    ) : [];
  }

  /**
   * Create all the common components
   * @private
   */
  _createCommonComponents() {
    this.legend = this._createNewLegend();
    this.legend.init();

    this.stage = this._createNewStage();
    this.stage.init();

    this.colorScale = this._createNewColorScale();
    this.colorScale.init();

    this.tooltipBox = this._createNewTooltipBox();
    this.tooltipBox.init();
  }

  /**
   * Create a new legend
   * @return {Legend} - A Legend instance
   * @private
   */
  _createNewLegend() {
    return new Legend({
      element: this.element,
      data: this.data,
      draw: this.draw.bind(this),
      highlight: this._highlight.bind(this),
      margin: {
        ...this.margin,
        left: 0
      }
    });
  }

  /**
   * Highlight one common element in all series
   * @param {String} key - The key matching the common element
   * @private
   */

  _highlight(key) {
    const series = this.canvas.selectAll('.series');
    if (key) {
      series.classed('dim', d => d.name !== key);
    } else {
      series.classed('dim', false);
    }
  }

  /**
   * Create a new stage
   * @return {Stage} - A Stage instance
   * @private
   */
  _createNewStage() {
    return new Stage({
      element: this.element,
      margin: this.margin,
      height: this.height,
    });
  }

  /**
   * Create a new color scale
   * @return {ColorScale} - A ColorScale instance
   * @private
   */
  _createNewColorScale() {
    return new ColorScale({
      length: this.data.series.length
    });
  }

  /**
   * Create a new tooltip
   * @return {Tooltip} - A Tooltip instance
   * @private
   */
  _createNewTooltipBox() {
    return new Tooltip({
      element: this.element,
      data: this.stackedData,
      hoverClass: 'mouse-area',
      showSummary: true,
      format: this.tooltip.format,
      isTime: this.x.scaleType === 'time',
      unit: {
        value: this._showPercentage() ? '%' : this._showUnits(),
        title: this.x.unit,
      }
    });
  }

  /**
   * Determine whether units should be shown or not
   * @return {boolean} - A boolean representing whether units should be shown or not
   * @private
   */
  _showUnits() {
    return this.y.unit ? this.y.unit : '';
  }

  /**
   * Draw the chart based on data
   * @param {Object} data - The data necessary to draw the chart
   * @public
   */
  _render() {
    this.width = this.stage.getCanvasWidth();

    /**
     * X axis
     */
    this.xScale = this._getXScale();
    const xAxis = this._getXAxis();
    xAxis.init();

    /**
     * Y axis
     */
    this.yScale = this._getYScale();
    const yAxis = this._getYAxis();
    yAxis.init();

    const seriesGroup = this._getSeriesGroup();

    // Enter
    const enter = seriesGroup.enter();
    const series = this._appendSeries(enter);

    this._appendPath(series, 'fill');
    this._appendPath(series, 'line');

    seriesGroup.merge(series).select('.fill');
    seriesGroup.merge(series).select('.line');

    // Update
    this._update();

    // Exit
    seriesGroup.exit().remove();

    /**
     * Tooltip & hovering
     */

    this._initTooltip();
  }

  /**
   * Get x-axis scaling function
   * @return {function} - A d3 scaling function for the x axis
   * @private
   */
  _getXScale() {
    switch (this.x.scaleType) {
      case 'linear':
        return d3.scaleLinear()
          .domain(d3.extent(this.data.common))
          .range([0, this.width]);
      case 'point':
        return d3.scalePoint()
          .domain(this.data.common)
          .range([0, this.width]);
      default:
        return d3.scaleTime()
          .domain(d3.extent(this.data.common))
          .range([0, this.width]);
    }
  }

  /**
   * Generate x-axis
   * @return {Axis} - An Axis instance for the x-axis
   * @private
   */
  _getXAxis() {
    return new Axis({
      position: 'bottom',
      canvas: this.canvas,
      x: this.xScale,
      width: this.width,
      height: this.height,
      margin: this.margin,
      fontSize: 14,
      axisPadding: 8,
      hasDomain: true,
      unit: this.x.unit,
      tickFormat: this._getXTickFormat(),
      animationSpeed: this.animationSpeed
    });
  }

  /**
   * Get x-axis tick format
   * @return {function} - A d3 formating function for the x-axis
   * @private
   */
  _getXTickFormat() {
    if (this.x.tickFormat){
      if(this.x.scaleType === 'time') {
        return d3.timeFormat(this.x.tickFormat);
      }
      return d3.format(this.x.tickFormat);
    }
  }

  /**
   * Get y-axis scaling function
   * @return {function} - A d3 scaling function for the y-axis
   * @private
   */
  _getYScale() {
    return d3.scaleLinear()
      .domain([this._getMin(), this._getMax()])
      .nice()
      .range([this.height, 0]);
  }

  /**
   * Get minimum value for the y-axis
   * @private
   */
  _getMin() {
    const min = d3.min(
      this.stackedData.series,
      d => d3.min(d.stack,
        value => Math.min(value[0], value[1])
      )
    );
    return min;
  }

  /**
   * Get maximum value for the y-axis
   * @return {number} - The maximum value in the stack
   * @private
   */
  _getMax() {
    return d3.max(
      this.stackedData.series,
      d => d3.max(d.stack,
        value => Math.max(value[0], value[1])
      )
    );
  }

  /**
   * Generate y-axis
   * @return {Axis} - An Axis instance for the y-axis
   * @private
   */
  _getYAxis() {
    return new Axis({
      position: 'left',
      canvas: this.canvas,
      y: this.yScale,
      width: this.width,
      height: this.height,
      margin: this.margin,
      fontSize: 14,
      axisPadding: 10,
      hasDomain: false,
      ticks: this.height / 60,
      tickFormat: this._getYTickFormat(),
      unit: this._showPercentage() ? 'Percent (%)' : this.y.unit
    });
  }

  /**
   * Get y-axis tick format
   * @return {function} - A d3 formating function for the y-axis
   * @private
   */
  _getYTickFormat() {
    if (this.y.tickFormat) {
      return d3.format(this.y.tickFormat);
    }
  }

  /**
   * Select or generate series group and select all series
   * @return {Object} - A d3 selection containing the series-group
   * @private
   */
  _getSeriesGroup() {
    const stackedAreaChart = this.canvas.classed('stacked-area-chart', true);
    return this._selectOrAppend(
      stackedAreaChart,
      'series-group',
      'g',
      { 'clip-path': `url(#${this.id})` }
    )
      .selectAll('.series')
      .data(
        this.stackedData.series,
        d => d.name
      );
  }

  /**
   * Select an element or append it if it does not exist
   * @param {Object} element - A d3 selection containing the parent of the element to select or append
   * @param {string} className - The class name of the element to select or append
   * @param {string} type - The type of element to append if it is not found. Defaults to "g".
   * @param {Object} attributes - Any additional attributes to append to the element if it is not found
   * @return {Object} - A d3 selection containing the element to be selected or appended
   * @private
   */
  _selectOrAppend(element, className, type = 'g', attributes = {}) {
    if(element.select(`.${className}`).empty()) {
      return this._attrs(
        element.append(type)
          .classed(className, true),
        attributes
      );
    }
    return element.select(`.${className}`);
  }

  /**
   * Add attributes to an element and return the element
   * @param {Object} element - A d3 selection containing the element which the attributes will be appended to
   * @param {Object} attributes - An object representing the attributes to append
   * @return {Object} - A d3 selection containing the element with the appended attributes
   * @private
   */
  _attrs(element, attributes) {
    for (const key in attributes) {
      if (attributes.hasOwnProperty(key)) {
        element.attr(key, attributes[key]);
      }
    }
    return element;
  }

  /**
   * Append the series group
   * @param {Element} seriesGroup - An element representing the series group
   * @return {Object} - A d3 selection containing an SVG group for a series
   * @private
   */
  _appendSeries(seriesGroup) {
    return seriesGroup
      .append('g')
      .classed('series', true)
      .attr('name', d => d.name);
  }

  /**
   * Append a path to the series
   * @param {Object} series - An element representing a series
   * @param {string} type - A string representing the type of path
   * @return {Object} - A d3 selection containing a path
   * @private
   */
  _appendPath(series, type) {
    return this._addDataAndClass(series.append('path'), type);
  }

  /**
   * Add data and class to a path based on the type
   * @param {Element} path - A path to which the data and class should be added
   * @param {string} type - A string representing the type of path
   * @private
   */
  _addDataAndClass(path, type){
    const dataFunction = this._getDataFunction(type);
    path
      .attr('d', d => dataFunction(d.stack))
      .attr('class', d => `${type} ${this.colorScale.get()(d.name)}`);
  }

  /**
   * Retrieve the data function according to the type of path
   * @param {string} type - A string representing the type of path
   * @return {function} - A d3 function to convert data into SVG paths
   * @private
   */
  _getDataFunction(type) {
    const dataFunction = type === 'fill' ? this._area : this._line;
    return dataFunction.bind(this)();
  }

  /**
   * Generate area function
   * @return {function} - A d3 area function
   * @private
   */
  _area() {
    return d3.area()
      .x((_, i) => this.xScale(this.data.common[i]))
      .y0(d => this.yScale(d[0]))
      .y1(d => this.yScale(d[1]));
  }

  /**
   * Generate line function
   * @return {function} - A d3 line function
   * @private
   */
  _line() {
    return d3.line()
      .defined(d => !isNaN(d[1]))
      .x((_, i) => this.xScale(this.data.common[i]))
      .y(d => this.yScale(d[1]));
  }

  /**
   * Update fills and strokes
   * @private
   */
  _update() {
    if (this.data.series.length > 0) {
      this._transitionAndUpdate('fill');
      this._transitionAndUpdate('line');
    }
  }

  /**
   * Add transition and update data of elements
   * @param {string} type - A string representing the type of element
   * @private
   */
  _transitionAndUpdate(type) {
    this._addDataAndClass(
      this.canvas.selectAll(`.series .${type}`)
        .transition()
        .duration(this.animationSpeed)
      , type);
  }

  /**
   * Initialize the tooltip
   * @private
   */
  _initTooltip() {
    if (!this.tooltip.isHidden) {
      this.xCommon = this._getXCommon();
      this.midpoints = this._getMidpoints(this.xCommon);

      this.tooltipLine = this._selectOrAppend(this.canvas, 'tooltip-line', 'path');

      const tooltipCirclesGroup = this._appendCirclesGroup();

      const mouseArea = this._appendMouseArea();
      this._addMouseEvents(mouseArea);

      const chartParentD3 = d3.select(`#${this.element.id}`);
      this.chartTooltip = chartParentD3.select('.chart-tooltip');

      tooltipCirclesGroup.exit().remove();
    }
  }

  /**
   * Calculate the pixel position of the points in the common
   * @return {Array} - An array containing the SVG x-position of each point in the common
   * @private
   */
  _getXCommon() {
    return this.data.common.map(element => this.xScale(element));
  }

  /**
   * Calculate the location of the points between each point of the x-axis
   * @param {Array} xCommon - An array containing the SVG x-position of each point in the common
   * @return {Array} - An array contianing the SVG x-position of each point between the points in the common
   * @private
   */
  _getMidpoints(xCommon) {
    return xCommon.map((v, i) => {
      if (i - 1 >= 0) {
        const result = v - ((v - xCommon[i-1]) / 2);
        return result;
      }
      return v;
    });
  }

  /**
   * Append the circles that will mark the point positions
   * @param {Object} container - A d3 selection representing the container for the circles
   * @return {Object} - A d3 selection containing the circles that mark each data point
   * @private
   */
  _appendCirclesGroup(){
    const container = this._selectOrAppend(this.canvas, 'circles');
    return container
      .selectAll('.tooltip-circle')
      .data(this.stackedData.series, d => d.name)
      .enter()
      .append('circle')
      .attr('r', 3)
      .attr('opacity', 0)
      .attr('class', d => `tooltip-circle ${this.colorScale.get()(d.name)}`);
  }

  /**
   * Append a rectangle to the chart to catch mouse events
   * @return {Object} - A d3 selection containing the mouse area element
   * @private
   */
  _appendMouseArea() {
    const mouseArea = this._selectOrAppend(this.canvas, 'mouse-area', 'svg:rect');
    return mouseArea
      .attr('width', this.width)
      .attr('height', this.height)
      .attr('fill', 'blue')
      .attr('opacity', 0)
      .attr('pointer-events', 'all');
  }

  /**
   * Add the mouse events to the mouse area
   * @param {Element} mouseArea - An element representing the mouse area
   * @private
   */
  _addMouseEvents(mouseArea) {
    const _this = this;

    mouseArea.on('touchmove mousemove', function() {
      _this._interruptTransition();
      _this.coord = d3.mouse(this);
      _this.showTooltip();
    }, {passive: true});

    mouseArea.on('touchend mouseleave', function() {
      _this.coord = null;
      _this.hideTooltip();
    }, {passive: true});
  }

  /**
   * Interrupt the transition of the tooltip circles and line
   * @private
   */
  _interruptTransition() {
    this.canvas.selectAll('.tooltip-circle').interrupt();
    this.tooltipLine.interrupt();
  }

  /**
   * Toggle the visibility of the tooltip elements and position them
   * @param {boolean} isSmooth - If set to true the positioning will have a smooth transition
   * @public
   */
  showTooltip(isSmooth) {
    if (!this.coord) {
      return;
    }

    const commonIndex = this._getCommonIndex();
    this.xPosition = this._getXPosition(commonIndex);

    if (commonIndex > -1) {
      this._positionTooltipCircles(commonIndex, isSmooth);
      this._positionTooltipLine(isSmooth);
      this.tooltipBox.update(commonIndex, this.stackedData);
    }
    this.chartTooltip.style('opacity', this.data.series.length > 0 ? 1 : 0);
  }

  /**
   * Get the index of the closest common based on mouse position
   * @return {number} - The index of the closest common entry
   * @private
   */
  _getCommonIndex() {
    return d3.bisect(this.midpoints, this.coord[0]) - 1;
  }

  /**
   * Get the position on the x-axis for a given index of a point in the common
   * @param {number} commonIndex - The index of the point in the common
   * @return {number} - The x-position of the common entry referenced by the index
   * @private
   */
  _getXPosition(commonIndex) {
    return this.xCommon[commonIndex] || 0;
  }

  /**
   * Position the tooltip circles based on the closest point in the common
   * @param {number} commonIndex - The index of the closest point in the common
   * @param {boolean} isSmooth - If set to true the positioning will have a smooth transition
   * @return {Object} - A d3 selection containing the circles that mark each data point
   * @private
   */
  _positionTooltipCircles(commonIndex, isSmooth) {
    return this._isTransition(
      this.canvas.selectAll('.tooltip-circle')
        .attr('opacity', d => this._isVisible(this.data.series, d))
      , isSmooth)
      .attr('cx', this.xPosition)
      .attr('cy', d => this.yScale(d.stack[commonIndex][1]));
  }

  /**
   * Add a transition to an element if isSmooth is set to true and return said element
   * @param {Object} element - A d3 selection containing the element to add the transition to
   * @param {boolean} isSmooth - Determines whether to add the transition or not
   * @return {Object} - A d3 selection containing the element the transition was added to
   * @private
   */
  _isTransition(element, isSmooth) {
    if(isSmooth) {
      return element
        .transition(this._getTransition());
    }
    return element;
  }

  /**
   * Get the transition function
   * @return {function} - A d3 transition function
   * @private
   */
  _getTransition() {
    return d3.transition().duration(this.animationSpeed);
  }

  /**
   * Determine if a circle should be visible based on whether its series is active
   * @param {Array} series - A collection of the currently active series
   * @param {Object} data - An object representing the current data point
   * @return {number} - A number representing the visibility of a DOM element
   * @private
   */
  _isVisible(series, data) {
    return series.filter(serie => serie.name === data.name).length < 1 ? 0 : 1;
  }

  /**
   * Position the tooltip line based on the closest point in the common
   * @param {boolean} isSmooth - If set to true the positioning will have a smooth transition
   * @return {Onject[]} - A d3 selection containing the positioned tooltip line
   * @private
   */
  _positionTooltipLine(isSmooth) {
    return this._isTransition(
      this.tooltipLine
        .attr('opacity', 1)
        .attr('d', `M0,${0}L0,${this.height}`)
      , isSmooth)
      .attr('transform', `translate(${this.xPosition},0)`);
  }

  /**
   * Hide all tooltip elements
   * @public
   */
  hideTooltip() {
    this.tooltipLine.attr('opacity', 0);
    this.canvas.selectAll('.tooltip-circle').attr('opacity', 0);
    this.chartTooltip.style('opacity', 0);
  }

  /**
   * Parse and render the chart with updated data
   * @return {data} - New data to be parsed and rendered
   * @ublic
   */
  draw(data) {
    this._parseData(data);
    this._render();
  }

  /**
   * Update method
   * @public
   */
  update(props) {
    this._setProps(props);
    this._parseData();
    this._render();
  }

  /**
   * Set properties after initialisation
   * @param {Object} props - An object containing the properties to set
   * @private
   */
  _setProps(props) {
    for (const prop in props) {
      if (this.hasOwnProperty(prop) && prop !== 'data') {
        this[prop] = props[prop];
      }
    }
  }

  /**
   * Destroy method
   * @public
   */
  destroy() {
    this.stage.destroy();
  }
}
