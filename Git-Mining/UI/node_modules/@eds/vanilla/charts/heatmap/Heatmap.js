import * as d3 from 'd3';

import { Axis } from '../common/Axis';
import { ColorScale } from '../common/ColorScale';
import { Format } from '../common/Format';
import { Legend } from '../common/Legend';
import { RangeSlider } from '../common/RangeSlider';
import { Stage } from '../common/Stage';
import { Tooltip } from '../common/Tooltip';

export class Heatmap {

  /**
   * Setup chart properties
   * @param {Object} props - The properties to initialize the stage
   * @param {Object} props.data - The data necessary to draw the chart
   * @param {HTMLElement} props.element - The DOM element to append the chart
   * @param {number} [props.height] - The height of the chart
   * @param {Object} [props.margin] - The top, right, bottom and left margins
   * @param {number} [props.margin.top] - The top margin
   * @param {number} [props.margin.right] - The right margin
   * @param {number} [props.margin.bottom] - The bottom margin
   * @param {number} [props.margin.left] - The left margin
   * @param {Object} [props.format] - Format used for line chart data manipulation
   * @param {string} [props.format.inputX] - Format used to parse the X data input
   * @param {string} [props.format.inputY] - Format used to parse the Y data input
   * @param {Object} [props.y] - Y axis properties
   * @param {string} [props.y.tickFormat] - The tick format for the Y axis
   * @param {boolean} [props.y.isTime] - If Y axis is time-based
   * @param {string} [props.y.unit] - The Y axis unit
   * @param {Object} [props.x] - X axis properties
   * @param {string} [props.x.unit] - The X axis unit
   * @param {string} [props.x.tickFormat] - The tick format for the X axis
   * @param {boolean} [props.x.isTime] - If X axis is time-based
   * @param {string} [props.x.unit] - The X axis unit
   * @param {Object} [props.tooltip] - Tooltip properties
   * @param {boolean} [props.tooltip.isHidden] - Hide the tooltip
   * @param {Object} [props.tooltip.format] - Format necessary for representing data
   * @param {string} [props.tooltip.format.title] - Time specific format (see D3 formats)
   * @param {string} [props.tooltip.format.label] - Time specific format (see D3 formats)
   * @param {string} [props.tooltip.format.value] - Number specific format (see D3 formats)
   * @param {string} [props.palette] - The color palette to use for the chart
   */
  constructor(props) {
    this.element = props.element;
    this.data = props.data;

    this.height = props.height || 150;
    this.margin = {
      bottom: 50,
      left: 100,
      right: 25,
      top: 25,
      ...props.margin,
    };

    this.format = {
      inputX: '%Y-%m-%d %H:%M:%S',
      inputY: '%Y-%m-%d %H:%M:%S',
      ...props.format,
    };

    this.x = {
      unit: '',
      ...props.x,
    };

    this.y = {
      unit: '',
      ...props.y,
    };

    this.tooltip = {
      format: {
        title: null,
        label: '%Y-%m-%d %H:%M:%S',
        value: '.2f'
      },
      isHidden: false,
      ...props.tooltip,
    };

    this.rangeOptions = {
      title: '',
      reverse: false,
      ...props.range,
    };

    this.axisPadding = 8;
    this.fontSize = 14;

    if (this.y.unit) {
      this.margin.top += this.fontSize + this.axisPadding;
    }
    if (this.x.unit) {
      this.margin.bottom += this.fontSize + this.axisPadding;
    }

    this.theme = document.querySelector('body').classList;
    this.colorPalette = ColorScale.getRangePaletteClass(props.palette || 'sequential 1');
    this.range = [];

    this.cellSpacing = 2;
    this.firstDrawFlag = true;
  }

  init() {
    this.colors = {
      light: {
        'sequential-1': ['#7F7F7F', '#2B2B2B'],
        'sequential-2': ['#E75FA0', '#88144C'],
        'sequential-3': ['#23969A', '#071D1D'],
        'sequential-4': ['#B98327', '#2D2009'],
        'sequential-5': ['#976CF4', '#3E0DA9'],
        'sequential-6': ['#E75D34', '#561B0A'],
        'sequential-7': ['#6688A5', '#24323E'],
        'sequential-8': ['#C86F6D', '#652726'],
        'sequential-9': ['#7F87AD', '#33384F'],
        'sequential-10': ['#E24F72', '#74132A'],
        'diverging-1': ['#A80D00', '#A08209', '#329864'],
        'diverging-2': ['#A80D00', '#A08209', '#329864', '#1F78C7'],
        'diverging-3': ['#75172E', '#8087AD', '#26959A'],
        'diverging-4': ['#ED0E00', '#8087AD', '#329864'],
        'diverging-5': ['#333333', '#8087AD', '#4B677F'],
        'diverging-6': ['#A08209', '#339864', '#3D1EA1']
      },
      dark: {
        'sequential-1': ['#FFFFFF', '#808080'],
        'sequential-2': ['#F6D7E7', '#D84B92'],
        'sequential-3': ['#C7F1F2', '#239497'],
        'sequential-4': ['#FEFAD4', '#D4C407'],
        'sequential-5': ['#E7DDFD', '#7E4AF2'],
        'sequential-6': ['#F2AF99', '#C94319'],
        'sequential-7': ['#BACAD6', '#557791'],
        'sequential-8': ['#E9C5C4', '#BF5652'],
        'sequential-9': ['#CACDDE', '#68709E'],
        'sequential-10': ['#F8D5DD', '#E04367'],
        'diverging-1': ['#DC2D37', '#DCAF01', '#288964'],
        'diverging-2': ['#DC2D37', '#DCAF01', '#288964', '#0077DB'],
        'diverging-3': ['#E04367', '#A6ABC6', '#74DCDF'],
        'diverging-4': ['#DC2D37', '#A6ABC6', '#288964'],
        'diverging-5': ['#68709E', '#A6ABC6', '#FFFFFF'],
        'diverging-6': ['#DCAF01', '#288964', '#7E4AF2']
      }
    };

    this.element.classList.add('heatmap');

    this.legend = new Legend({
      element: this.element,
      data: {
        common: this.data.commonX,
        series: this.data.series
      },
      draw: this._filterLegend.bind(this),
      margin: {
        ...this.margin,
        left: 0
      }
    });
    this.legend.init();

    this.stage = new Stage({
      element: this.element,
      height: this.height,
      margin: this.margin,
    });
    this.stage.init();
    this.stage.onResize(this.draw.bind(this));

    this.rangeSlider = new RangeSlider({
      element: this.element,
      margin: this.margin,
      options: this.rangeOptions,
    });
    this.rangeSlider.init();

    this.tooltipBox = new Tooltip({
      element: this.element,
      data: this.data,
      hoverClass: 'mouse-area',
      format: this.tooltip.format,
      isTime: this.x.isTime,
      unit: {
        title: this.x.unit,
        value: this.rangeOptions && this.rangeOptions.unit ? this.rangeOptions.unit : ''
      }
    });
    this.tooltipBox.init();

    this.canvas = this.stage.getCanvas();
    this.svg = d3.select(this.canvas.node().parentNode);

    this.listeners = {
      switchTheme: () => {
        this.theme = event.detail.theme;
        this.draw();
      },
    };
    this._addEventListeners();

    this.draw();
  }

  _filterLegend(data) {
    if (data !== undefined && data.series.length === 0) {
      this.containerGroup.classed('hidden', true);
    } else {
      this.containerGroup.classed('hidden', false);
    }
  }

  draw(data) {
    this.data = data || this.data;
    this.width = this.stage.getCanvasWidth();

    const xLength = this.data.commonX.length;
    const yLength = this.data.commonY.length;

    const isXNumber = typeof this.data.commonX[0] === 'number';
    const isYNumber = typeof this.data.commonY[0] === 'number';

    // Convert text dates to actual date objects.
    if (this.x.isTime) {
      this.data.commonX.forEach((date, i) => {
        if (!(date instanceof Date)) {
          const formatedDate = Format.formatTime(this.format.inputX)(new Date(date));
          this.data.commonX[i] = d3.timeParse(this.format.inputX)(formatedDate);
        }
      });
    }

    if (this.y.isTime) {
      this.data.commonY.forEach((date, i) => {
        if (!(date instanceof Date)) {
          const formatedDate = Format.formatTime(this.format.inputY)(new Date(date));
          this.data.commonY[i] = d3.timeParse(this.format.inputY)(formatedDate);
        }
      });
    }

    // Define ranges and colors.
    const minValues = this.data.series.map(d0 => d3.min(d0.values, d1 => d3.min(d1)));
    const maxValues = this.data.series.map(d0 => d3.max(d0.values, d1 => d3.max(d1)));
    const globalMinValue = d3.min(minValues);
    const globalMaxValue = d3.max(maxValues);
    this.range = [globalMinValue, globalMaxValue];

    const colorScales = this.data.series.map(() => {
      const domain = [globalMinValue, globalMaxValue];
      const domainWithPivot = [];

      const colorRange = JSON.parse(JSON.stringify(this.colors[this.theme][this.colorPalette]));
      if (this.rangeOptions.reverse === true) {
        colorRange.reverse();
      }

      const colorRangeLength = colorRange.length;
      colorRange.forEach((color, index) => {
        const val = domain[1] + (domain[0] - domain[1]) * (colorRangeLength - index - 1) / (colorRangeLength - 1);
        domainWithPivot.push(val);
      });

      return d3.scaleLinear()
        .domain(domainWithPivot)
        .range(colorRange);
    });

    this.rangeSlider.update(
      colorScales[0],
      globalMinValue,
      globalMaxValue);

    // Setup scales.

    let xExtent;
    let yExtent;
    let xScale;
    let yScale;

    let cellHeight = 0;
    let cellWidth = 0;

    if (this.x.isTime) {
      xExtent = d3.extent(this.data.commonX);
      const xStep = (xExtent[1] - xExtent[0]) / (xLength - 1);
      xExtent[1] = new Date(xExtent[1].getTime() + xStep);

      xScale = d3.scaleTime()
        .range([0, this.width])
        .domain(xExtent);

      cellWidth = (xScale(xExtent[1]) - xScale(xExtent[0])) / xLength;
    } else if (isXNumber) {
      xExtent = d3.extent(this.data.commonX);
      const xStep = (xExtent[1] - xExtent[0]) / (xLength - 1);
      xExtent[1] = xExtent[1] + xStep;

      xScale = d3.scaleLinear()
        .range([0, this.width])
        .domain(xExtent);

      cellWidth = (xScale(xExtent[1]) - xScale(xExtent[0])) / xLength;
    } else {
      xScale = d3.scaleBand()
        .range([0, this.width])
        .domain(this.data.commonX);
    }

    if (this.y.isTime) {
      yExtent = d3.extent(this.data.commonY);
      const yStep = (yExtent[1] - yExtent[0]) / (yLength - 1);
      yExtent[1] = new Date(yExtent[1].getTime() + yStep);

      yScale = d3.scaleTime()
        .range([0, this.height])
        .domain(yExtent);

      cellHeight = Math.abs(yScale(yExtent[1]) - yScale(yExtent[0])) / yLength;
    } else if (isYNumber) {
      yExtent = d3.extent(this.data.commonY);
      const yStep = (yExtent[1] - yExtent[0]) / (yLength - 1);
      yExtent[0] = yExtent[0] - yStep;

      yScale = d3.scaleLinear()
        .range([this.height, 0])
        .domain(yExtent);

      cellHeight = Math.abs(yScale(yExtent[1]) - yScale(yExtent[0])) / yLength;
    } else {
      yScale = d3.scaleBand()
        .range([this.height, 0])
        .domain(this.data.commonY);
    }

    // Draw axis.
    let xTickFormat;
    let yTickFormat;

    if (this.x.isTime && this.x.tickFormat) {
      xTickFormat = d3.timeFormat(this.x.tickFormat);
    } else if (this.x.tickFormat) {
      xTickFormat = d3.format(this.x.tickFormat);
    }

    if (this.y.isTime && this.y.tickFormat) {
      yTickFormat = d3.timeFormat(this.y.tickFormat);
    } else if (this.y.tickFormat) {
      yTickFormat = d3.format(this.y.tickFormat);
    }

    const xAxis = new Axis({
      position: 'bottom',
      canvas: this.canvas,
      x: xScale,
      width: this.width,
      height: this.height,
      margin: this.margin,
      fontSize: 14,
      axisPadding: 8,
      hasDomain: true,
      tickFormat: xTickFormat,
      animationSpeed: 980,
      unit: this.x.unit
    });
    xAxis.init();

    const yAxis = new Axis({
      position: 'left',
      canvas: this.canvas,
      y: yScale,
      width: this.width,
      height: this.height,
      margin: this.margin,
      fontSize: 14,
      axisPadding: 10,
      hasDomain: true,
      tickFormat: yTickFormat,
      ticks: this.height / 60,
      unit: this.y.unit
    });
    yAxis.init();

    // Hide x labels if space it not sufficient.
    let hasLabelSpace = true;
    if (this.x.isTime !== true && isXNumber !== true) {
      const seriesDistance = xScale(this.data.commonX[1]) - xScale(this.data.commonX[0]);

      this.data.commonX.forEach(d => {
        if (hasLabelSpace) {
          hasLabelSpace = d.length * this.fontSize / 1.5 < seriesDistance;
        }
      });

      if (hasLabelSpace) {
        this.canvas.selectAll('.bottom.axis text:not(.unit)').style('opacity', 1);
      } else {
        this.canvas.selectAll('.bottom.axis text:not(.unit)').style('opacity', 0);
      }
    }

    // Create container group.
    this.containerGroup = this.canvas.select('g.container').empty() ?
      this.canvas.append('g')
        .classed('container', true) :
      this.canvas.select('g.container');

    // Draw matrix.

    // Matrix container.

    let matrixGroup;
    if (this.firstDrawFlag) {
      matrixGroup = this.containerGroup
        .append('g')
        .classed('matrix', true);
    } else {
      matrixGroup = this.containerGroup
        .select('g.matrix');
    }

    // Series container.

    const serieGroupsUpdate = matrixGroup.selectAll('g.serie')
      .data(this.data.series, d => d.name);

    const serieGroupsEnter = serieGroupsUpdate.enter()
      .append('g')
      .classed('serie', true);

    serieGroupsUpdate.exit().remove();

    const serieGroups = serieGroupsUpdate.merge(serieGroupsEnter);

    // Define getters.

    const getX = (d, i) => `translate(${xScale(this.data.commonX[i]) + 1},0)`;
    const getY = (d, i) => (yScale(this.data.commonY[i]) + 1);
    const getWidth = () => {
      if (this.x.isTime || isXNumber) {
        return Math.max(0, cellWidth - 1);
      } else {
        return Math.max(0, xScale.bandwidth() - 1);
      }
    };
    const getHeight = () => {
      if (this.y.isTime || isYNumber) {
        return Math.max(0, cellHeight - 1);
      } else {
        return Math.max(0, yScale.bandwidth() - 1);
      }
    };

    // Create grid.
    const gridXUpdate = this.containerGroup.selectAll('line.grid-horizontal')
      .data(this.data.commonX, d => d);
    const gridXEnter = gridXUpdate
      .enter()
      .append('line')
      .classed('grid-horizontal', true);
    gridXUpdate.exit().remove();

    gridXUpdate.merge(gridXEnter)
      .attr('x1', (d) => xScale(d) + getWidth() + 1)
      .attr('x2', (d) => xScale(d) + getWidth() + 1)
      .attr('y1', 0)
      .attr('y2', this.height);

    const gridYUpdate = this.containerGroup.selectAll('line.grid-vertical')
      .data(this.data.commonY, d => d);
    const gridYEnter = gridYUpdate
      .enter()
      .append('line')
      .classed('grid-vertical', true);
    gridYUpdate.exit().remove();

    gridYUpdate.merge(gridYEnter)
      .attr('x1', 0)
      .attr('x2', this.width)
      .attr('y1', d => yScale(d))
      .attr('y2', d => yScale(d));

    // Column container.

    const columnGroupsUpdate = serieGroups.selectAll('g.column')
      .data(d => d.values)
      .attr('transform', getX);

    const columnGroupsEnter = columnGroupsUpdate.enter()
      .append('g')
      .classed('column', true)
      .attr('transform', getX);

    columnGroupsUpdate.exit().remove();

    const columnGroups = columnGroupsUpdate.merge(columnGroupsEnter);

    // Rectangles.

    const rectsUpdate = columnGroups.selectAll('rect')
      .data(d => d)
      .classed('rect', true)
      .style('fill', d => colorScales[0](d))
      .attr('y', getY)
      .attr('width', getWidth)
      .attr('height', getHeight);

    rectsUpdate.enter()
      .append('rect')
      .classed('rect', true)
      .style('fill', d => colorScales[0](d))
      .attr('y', getY)
      .attr('width', getWidth)
      .attr('height', getHeight);

    rectsUpdate.exit().remove();

    // Tooltip.
    const mouseArea = this.canvas.select('.mouse-area').empty() ?
      this.canvas.append('svg:rect').classed('mouse-area', true) :
      this.canvas.select('.mouse-area');

    mouseArea
      .attr('width', this.width)
      .attr('height', this.height)
      .attr('fill', 'blue')
      .attr('opacity', 0)
      .attr('pointer-events', 'all');

    const _this = this;

    mouseArea.on('touchmove mousemove', function () {
      const coords = d3.mouse(this);
      let xCommon;
      let yCommon;

      if (_this.x.isTime || isXNumber) {
        xCommon = Math.floor(coords[0] / cellWidth);
      } else {
        xCommon = Math.floor(coords[0] / xScale.bandwidth());
      }

      if (_this.y.isTime) {
        yCommon = Math.floor(coords[1] / cellHeight);
      } else if (isYNumber) {
        yCommon = yLength - Math.floor(coords[1] / cellHeight) - 1;
      } else {
        yCommon = yLength - Math.floor(coords[1] / yScale.bandwidth()) - 1;
      }

      if (xCommon < 0) xCommon = 0;
      if (xCommon >= _this.data.commonX.length) xCommon = _this.data.commonX.length - 1;
      if (yCommon < 0) yCommon = 0;
      if (yCommon >= _this.data.commonY.length) yCommon = _this.data.commonY.length - 1;

      _this.canvas
        .selectAll('g.column')
        .style('opacity', (d, i) => i === xCommon ? '' : 0.2)
        .filter((d, i) => i !== xCommon)
        .selectAll('rect.rect')
        .style('opacity', 1);
      _this.canvas
        .selectAll('g.column')
        .filter((d, i) => i === xCommon)
        .selectAll('rect.rect')
        .style('opacity', (d, i) => yCommon === i ? '' : 0.2);

      const valueX = _this.data.commonX[xCommon];
      let valueY = _this.data.commonY[yCommon];
      const value = _this.data.series[0].values[xCommon][yCommon];

      if (_this.y.isTime && _this.tooltip.format.label) {
        valueY = d3.timeFormat(_this.tooltip.format.label)(valueY);
      } else if (_this.y.isTime && yTickFormat) {
        valueY = yTickFormat(valueY);
      } else if (_this.y.isTime) {
        valueY = d3.timeFormat('%Y-%m-%d %H:%M:%S')(valueY);
      } else if (isYNumber && _this.tooltip.format.label) {
        valueY = d3.format(_this.tooltip.format.label)(value);
      }

      _this.tooltipBox.updateSingle(valueX, valueY, value);
    });

    mouseArea.on('touchend mouseleave', function () {
      _this.canvas
        .selectAll('g.column')
        .style('opacity', '')
        .selectAll('rect.rect')
        .style('opacity', '');
    });

    // Set draw flag.
    this.firstDrawFlag = false;
  }

  _addEventListeners() {
    document.addEventListener('switchTheme', this.listeners.switchTheme);
  }

  _removeEventListeners() {
    document.removeEventListener('switchTheme', this.listeners.switchTheme);
  }

  destroy() {
    this._removeEventListeners();
    this.stage.destroy();
    this.element.innerHTML = '';
  }
}
