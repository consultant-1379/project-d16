import * as d3 from 'd3';

import { Stage } from '../../common/Stage';
import { ColorScale } from '../../common/ColorScale';
import { Tooltip } from '../../common/Tooltip';

/**
 * Setup chart properties.
 * @param {Object}      props - The properties to initialize the stage
 * @param {Object}      props.data - The data necessary to draw the chart
 * @param {HTMLElement} props.element - The DOM element to append the chart
 * @param {boolean}     props.alerts - Determines if the alerts button should be on by default.
 * @param {boolean}     props.simulation - Calculate node locations automatically.
 * @param {boolean}     props.draggable - Determines if the nodes should be draggable.
 * @param {number}      props.zoom - The initial zoom level.
 * @param {number}      props.maxZoom - The max zoom amount.
 * @param {number}      props.minZoom - The min zoom amount.
 * @param {string}      props.grouping - Set the hover group method.
 */
export class LogicalViewChart {
  constructor(props) {
    this.element = props.element;

    this.height = props.height || 500;
    this.data = JSON.parse(JSON.stringify(props.data));
    this.onSelect = props.onSelect;
    this.onMove = props.onMove;

    this.innerCircleRadius = 16;
    this.outerCircleRadius = 20;
    this.lineCircleRadius = 10;
    this.circleFontSize = 14;

    this.isProcessed = false;
    this.connectionMap = {};

    this.showAlerts = props.alerts || false;
    this.simulation = props.simulation || false;
    this.draggable = props.draggable || false;

    this.zoom = props.zoom || 1;
    this.minZoom = props.minZoom || 0.5;
    this.maxZoom = props.maxZoom || 2.0;
    this.grouping = props.grouping || 'neighbour';

    this.properties = {
      scale: () => 1 / this.zoom,
      lineDashArray: d => {
        switch (d.type) {
          case 'dashed':
            return 4 / this.zoom;
          case 'solid':
          default:
            return null;
        }
      },
      mouseAreaClass: d => d.alerts && d.alerts.length > 0 || d.descriptions && d.descriptions.length > 0,
      innerCircleRadius: () => this.innerCircleRadius,
      outerCircleRadius: () => this.outerCircleRadius,
      textPositionY: () => (this.outerCircleRadius + 4),
      alertsPositionY: () => (this.properties.textPositionY() + this.circleFontSize + 4),
      lineNodeGeometry: d => {
        const round = e => Math.round(e * 100) / 100;
        const triangle = [
          [
            round(Math.cos(Math.PI / 6 + Math.PI * 2 / 3 * 0) * this.lineCircleRadius),
            round(Math.sin(Math.PI / 6 + Math.PI * 2 / 3 * 0) * this.lineCircleRadius),
          ],
          [
            round(Math.cos(Math.PI / 6 + Math.PI * 2 / 3 * 1) * this.lineCircleRadius),
            round(Math.sin(Math.PI / 6 + Math.PI * 2 / 3 * 1) * this.lineCircleRadius),
          ],
          [
            round(Math.cos(Math.PI / 6 + Math.PI * 2 / 3 * 2) * this.lineCircleRadius),
            round(Math.sin(Math.PI / 6 + Math.PI * 2 / 3 * 2) * this.lineCircleRadius),
          ]
        ];
        const square = [
          [
            round(1 / Math.sqrt(2) * this.lineCircleRadius),
            round(1 / Math.sqrt(2) * this.lineCircleRadius)
          ],
          [
            -round(1 / Math.sqrt(2) * this.lineCircleRadius),
            round(1 / Math.sqrt(2) * this.lineCircleRadius)
          ],
          [
            -round(1 / Math.sqrt(2) * this.lineCircleRadius),
            -round(1 / Math.sqrt(2) * this.lineCircleRadius)
          ],
          [
            round(1 / Math.sqrt(2) * this.lineCircleRadius),
            -round(1 / Math.sqrt(2) * this.lineCircleRadius)
          ]
        ];
        const pentagon = [
          [
            round(Math.cos(Math.PI * 3 / 2 + Math.PI * 2 / 5 * 0) * this.lineCircleRadius),
            round(Math.sin(Math.PI * 3 / 2 + Math.PI * 2 / 5 * 0) * this.lineCircleRadius)
          ],
          [
            round(Math.cos(Math.PI * 3 / 2 + Math.PI * 2 / 5 * 1) * this.lineCircleRadius),
            round(Math.sin(Math.PI * 3 / 2 + Math.PI * 2 / 5 * 1) * this.lineCircleRadius)
          ],
          [
            round(Math.cos(Math.PI * 3 / 2 + Math.PI * 2 / 5 * 2) * this.lineCircleRadius),
            round(Math.sin(Math.PI * 3 / 2 + Math.PI * 2 / 5 * 2) * this.lineCircleRadius)
          ],
          [
            round(Math.cos(Math.PI * 3 / 2 + Math.PI * 2 / 5 * 3) * this.lineCircleRadius),
            round(Math.sin(Math.PI * 3 / 2 + Math.PI * 2 / 5 * 3) * this.lineCircleRadius)
          ],
          [
            round(Math.cos(Math.PI * 3 / 2 + Math.PI * 2 / 5 * 4) * this.lineCircleRadius),
            round(Math.sin(Math.PI * 3 / 2 + Math.PI * 2 / 5 * 4) * this.lineCircleRadius)
          ]
        ];
        const hexagon = [
          [
            round(Math.cos(Math.PI / 6 + Math.PI / 3 * 0) * this.lineCircleRadius),
            round(Math.sin(Math.PI / 6 + Math.PI / 3 * 0) * this.lineCircleRadius)
          ],
          [
            round(Math.cos(Math.PI / 6 + Math.PI / 3 * 1) * this.lineCircleRadius),
            round(Math.sin(Math.PI / 6 + Math.PI / 3 * 1) * this.lineCircleRadius)
          ],
          [
            round(Math.cos(Math.PI / 6 + Math.PI / 3 * 2) * this.lineCircleRadius),
            round(Math.sin(Math.PI / 6 + Math.PI / 3 * 2) * this.lineCircleRadius)
          ],
          [
            round(Math.cos(Math.PI / 6 + Math.PI / 3 * 3) * this.lineCircleRadius),
            round(Math.sin(Math.PI / 6 + Math.PI / 3 * 3) * this.lineCircleRadius)
          ],
          [
            round(Math.cos(Math.PI / 6 + Math.PI / 3 * 4) * this.lineCircleRadius),
            round(Math.sin(Math.PI / 6 + Math.PI / 3 * 4) * this.lineCircleRadius)
          ],
          [
            round(Math.cos(Math.PI / 6 + Math.PI / 3 * 5) * this.lineCircleRadius),
            round(Math.sin(Math.PI / 6 + Math.PI / 3 * 5) * this.lineCircleRadius)
          ]
        ];

        if (d.shape === 'hexagon') {
          return `
            M${hexagon[0][0]} ${hexagon[0][1]}
            L${hexagon[1][0]} ${hexagon[1][1]}
            L${hexagon[2][0]} ${hexagon[2][1]}
            L${hexagon[3][0]} ${hexagon[3][1]}
            L${hexagon[4][0]} ${hexagon[4][1]}
            L${hexagon[5][0]} ${hexagon[5][1]} Z`;
        } else if (d.shape === 'pentagon') {
          return `
            M${pentagon[0][0]} ${pentagon[0][1]}
            L${pentagon[1][0]} ${pentagon[1][1]}
            L${pentagon[2][0]} ${pentagon[2][1]}
            L${pentagon[3][0]} ${pentagon[3][1]}
            L${pentagon[4][0]} ${pentagon[4][1]} Z`;
        } else if (d.shape === 'square') {
          return `
            M${square[0][0]} ${square[0][1]}
            L${square[1][0]} ${square[1][1]}
            L${square[2][0]} ${square[2][1]}
            L${square[3][0]} ${square[3][1]} Z`;
        }
        return `
          M${triangle[0][0]} ${triangle[0][1]}
          L${triangle[1][0]} ${triangle[1][1]}
          L${triangle[2][0]} ${triangle[2][1]} Z`;
      }
    };
  }

  /**
   * Initialize the chart
   */
  init() {
    const _this = this;

    this.element.classList.add('logical-view-chart');

    // Toggles.
    this.legendAlerts = d3.select(this.element)
      .append('div');
    this.labelAlerts = this.legendAlerts
      .append('label')
      .classed('switch', true);
    this.legendAlertsInput = this.labelAlerts
      .append('input')
      .attr('type', 'checkbox')
      .attr('checked', this.showAlerts === true ? true : null)
      .on('click', function () {
        _this.showAlerts = this.checked;
        _this.canvas.selectAll('g.alerts').classed('hidden', !_this.showAlerts);
      });
    this.labelAlerts
      .append('i')
      .classed('ball', true);
    this.labelAlerts
      .append('span')
      .attr('data-enabled', 'Alerts on')
      .attr('data-disabled', 'Alerts off');

    // Color scale.
    this.colorScale = new ColorScale({});
    this.colorScale.init();

    if (this.data.alerts && this.data.alerts.length > 0) {
      this.colorScale.set(d3.scaleOrdinal()
        .domain(this.data.alerts.map(d => d.name))
        .range([
          'color-red icon icon-severity-critical',
          'color-orange icon icon-severity-major',
          'color-blue icon icon-severity-warning',
          'color-yellow icon icon-severity-minor',
          'color-gray icon icon-severity-indeterminate',
          'color-green icon icon-severity-cleared'
        ])
      );
    }

    // Stage.
    this.stage = new Stage({
      element: this.element,
      margin: {
        bottom: 0,
        left: 0,
        right: 0,
        top: 0
      },
      height: this.height,
    });
    this.stage.init();
    this.stage.onResize(this.draw.bind(this));

    // Tooltip.
    this.tooltipBox = new Tooltip({
      element: this.element,
      colorScale: this.colorScale,
      rawMode: true,
      data: {
        common: [],
        series: this.data.alerts || [],
      },
      hoverClass: 'mouse-area'
    });
    this.tooltipBox.init();

    this.canvas = this.stage.getCanvas();
    this.svg = d3.select(this.canvas.node().parentNode);

    const zoom = d3.zoom()
      .scaleExtent([this.minZoom, this.maxZoom])
      .on('zoom', () => {
        this.zoom = d3.event.transform.k;

        this.canvas.attr('transform', d3.event.transform);

        this.canvas.selectAll('g.container')
          .attr('transform', `scale(${this.properties.scale()})`);

        this.canvas.selectAll('line')
          .style('stroke-width', this.properties.scale)
          .style('stroke-dasharray', this.properties.lineDashArray);
      });
    this.svg
      .call(zoom)
      .call(zoom.transform, d3.zoomIdentity.scale(this.zoom));

    // Labels.
    const labelGroup = this.svg.select('g.labels').empty()
      ? this.svg.append('g').classed('labels', true)
      : this.svg.select('g.labels');

    labelGroup.attr('transform', 'translate(0,20)');
    const labels = labelGroup.selectAll('g.label')
      .data(this.data.labels || [])
      .enter()
      .append('g')
      .classed('label', true)
      .attr('transform', (d, i) => `translate(0,${this.lineCircleRadius * 2.5 * i + 10})`);
    labels.selectAll('path.line-node')
      .data(d => [d])
      .enter()
      .append('path')
      .classed('line-node', true)
      .attr('d', this.properties.lineNodeGeometry)
      .attr('transform', `translate(${this.lineCircleRadius},${this.lineCircleRadius})`);
    labels.selectAll('text.label')
      .data(d => [d])
      .enter()
      .append('text')
      .classed('label', true)
      .attr('dominant-baseline', 'middle')
      .attr('transform', `translate(${this.lineCircleRadius * 2 + 8},${this.lineCircleRadius})`)
      .text(d => d.name);

    // Render.
    this.draw(this.data);
  }

  /**
   * Draws the new data to canvas.
   */
  draw(data) {
    const _this = this;

    if (data) {
      this.isProcessed = false;
      this.data = JSON.parse(JSON.stringify(data));

      this.connectionMap = {};
      this.data.links.forEach(d => {
        if (this.connectionMap[d.source]) {
          this.connectionMap[d.source].push(d.target);
        } else {
          this.connectionMap[d.source] = [d.target];
        }
        if (this.connectionMap[d.target]) {
          this.connectionMap[d.target].push(d.source);
        } else {
          this.connectionMap[d.target] = [d.source];
        }
      });

      let disableAlerts = true;
      this.data.nodes.forEach(node => {
        if (node.alerts && node.alerts.length > 0) {
          disableAlerts = false;
        }
      });
      if (disableAlerts === true) {
        this.legendAlertsInput.attr('disabled', true);
      } else {
        this.legendAlertsInput.attr('disabled', null);
      }
    }
    this.width = this.stage.getCanvasWidth();

    // Center group.
    const centerGroup = this.canvas.select('g.center').empty()
      ? this.canvas.append('g')
        .classed('center', true)
      : this.canvas.select('g.center');
    centerGroup
      .attr(
        'transform',
        `translate(${this.width / 2.0},${this.height / 2.0})`
      );

    // Links.
    const linksUpdate = centerGroup
      .selectAll('line')
      .data(this.data.links)
      .style('stroke-width', this.properties.scale)
      .style('stroke-dasharray', this.properties.lineDashArray);
    linksUpdate.exit().remove();

    const linksEnter = linksUpdate
      .enter()
      .append('line')
      .style('stroke-width', this.properties.scale)
      .style('stroke-dasharray', this.properties.lineDashArray);

    const linkNodesUpdate = centerGroup
      .selectAll('g.line-node')
      .data(this.data.links.filter(d => d.data !== undefined));
    const linkNodesEnter = linkNodesUpdate
      .enter()
      .append('g')
      .classed('line-node', true);
    linkNodesUpdate.exit().remove();

    const linkNodes = linkNodesUpdate.merge(linkNodesEnter);

    const linkNodesContainerUpdate = linkNodes
      .selectAll('g.container')
      .data(d => [d]);
    linkNodesContainerUpdate.exit().remove();
    const linkNodesContainerEnter = linkNodesContainerUpdate
      .enter()
      .append('g')
      .classed('container', true);

    const linkNodesContainers = linkNodesContainerUpdate.merge(linkNodesContainerEnter);

    const linkNodesCircleUpdate = linkNodesContainers
      .selectAll('path.line-node')
      .data(d => [d.data])
      .attr('d', this.properties.lineNodeGeometry);
    linkNodesCircleUpdate.exit().remove();
    linkNodesCircleUpdate
      .enter()
      .append('path')
      .classed('line-node', true)
      .attr('d', this.properties.lineNodeGeometry);

    // Nodes.
    const nodesUpdate = centerGroup
      .selectAll('g.circle')
      .data(this.data.nodes);
    nodesUpdate.exit().remove();

    const nodesEnter = nodesUpdate
      .enter()
      .append('g')
      .classed('circle', true);

    this._nodes = nodesEnter.merge(nodesUpdate);
    this._links = linksEnter.merge(linksUpdate);
    this._linkNodes = linkNodes;

    // Setup click and mouse hover state.
    this._nodes.on('click', function () {
      if (this.classList.contains('selected')) {
        this.classList.remove('selected');
      } else {
        this.classList.add('selected');
      }
      const selected = [];
      _this._nodes.each(function (d) {
        if (this.classList.contains('selected')) {
          selected.push(d);
        }
      });
      if (_this.onSelect) {
        _this.onSelect(selected);
      }
    }).on('touchmove mousemove', d1 => {
      // Node grouping.
      _this._nodes.style('opacity', d2 => {
        if (d1 === d2) {
          return '1';
        }

        // Grouping methods.
        switch (this.grouping) {
          case 'type':
            if (d1.group === d2.group) {
              return '1';
            } else {
              return '0.2';
            }
          case 'neighbour':
          default:
            if (
              this.connectionMap[d1.key] &&
              this.connectionMap[d1.key].indexOf(d2.key) !== -1 ||
              this.connectionMap[d2.key] &&
              this.connectionMap[d2.key].indexOf(d1.key) !== -1
            ) {
              return '1';
            }
            return '0.2';
        }
      });

      // Tooltip.
      let series = [];
      if (d1.descriptions && d1.descriptions.length > 0) {
        series = series.concat(d1.descriptions.map(e => ({ name: e })));
      }
      if (d1.alerts && d1.alerts.length > 0) {
        series = series.concat(d1.alerts.map(e => ({ name: `${e.name} (${e.value})` })));
      }

      this.tooltipBox.update(0, {
        common: [d1.name],
        series,
      });
    }).on('touchend mouseleave', function() {
      _this._nodes.style('opacity', null);
    });

    // Setup draggable state.
    if (this.draggable === true) {
      this._nodes.call((() => {
        function dragged() {
          d3.event.subject.x = d3.event.x;
          d3.event.subject.y = d3.event.y;
          if (_this._simulation) _this._simulation.stop();
          _this._updatePositions();
        }

        function dragend() {
          d3.event.subject.x = d3.event.x;
          d3.event.subject.y = d3.event.y;
          if (_this.onMove) _this.onMove(d3.event.subject);
          _this._updatePositions();
        }

        return d3.drag()
          .on('drag', dragged)
          .on('end', dragend);
      })());
    }

    // Node container.
    const nodesContainerUpdate = this._nodes.selectAll('g.container')
      .data(d => [d])
      .attr('class', d => {
        const ret = ['container'];
        let maxAlert;
        if (d.alerts && d.alerts.length > 0) {
          maxAlert = d.alerts[0];
          d.alerts.forEach(e => {
            maxAlert = e.value > maxAlert.value ? e : maxAlert;
          });
          const classes = this.colorScale.get()(maxAlert.name);
          const colorClass = classes.split(' ')[0];
          ret.push(colorClass);
        }
        return ret.join(' ');
      });
    nodesContainerUpdate.exit().remove();
    const nodesContainerEnter = nodesContainerUpdate
      .enter()
      .append('g')
      .attr('class', d => {
        const ret = ['container'];
        let maxAlert;
        if (d.alerts && d.alerts.length > 0) {
          maxAlert = d.alerts[0];
          d.alerts.forEach(e => {
            maxAlert = e.value > maxAlert.value ? e : maxAlert;
          });
          const classes = this.colorScale.get()(maxAlert.name);
          const colorClass = classes.split(' ')[0];
          ret.push(colorClass);
        }
        return ret.join(' ');
      });

    const containers = nodesContainerUpdate
      .merge(nodesContainerEnter)
      .attr('scale', `scale(${this.properties.scale()})`);

    // Root circle.
    const rootUpdate = containers
      .selectAll('circle.outer')
      .data(d => [d])
      .attr('r', this.properties.outerCircleRadius)
      .style('stroke-width', 1)
      .classed('mouse-area', this.properties.mouseAreaClass);
    rootUpdate.enter()
      .append('circle')
      .classed('outer', true)
      .attr('r', this.properties.outerCircleRadius)
      .style('stroke-width', 1)
      .classed('mouse-area', this.properties.mouseAreaClass);
    rootUpdate.exit().remove();

    // Inner circle.
    const circleUpdate = containers.selectAll('circle.circle')
      .data(d => [d])
      .attr('r', this.properties.innerCircleRadius)
      .classed('mouse-area', this.properties.mouseAreaClass);
    circleUpdate.enter()
      .append('circle')
      .classed('circle', true)
      .attr('r', this.properties.innerCircleRadius)
      .classed('mouse-area', this.properties.mouseAreaClass);
    circleUpdate.exit().remove();

    // Icon update.
    const iconUpdate = containers.selectAll('text.icon')
      .data(d => [d])
      .attr('class', d => `icon ${d.icon}`)
      .classed('mouse-area', this.properties.mouseAreaClass);
    const iconEnter = iconUpdate.enter()
      .append('text')
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'middle')
      .attr('class', d => `icon ${d.icon}`)
      .classed('mouse-area', this.properties.mouseAreaClass);
    iconUpdate.exit().remove();

    const icons = iconUpdate.merge(iconEnter);
    icons.text(function () {
      return (getComputedStyle(this, ':before').content).slice(1, -1);
    });

    // Text section.
    const textUpdate = containers.selectAll('text.text')
      .data(d => [d])
      .text(d => d.name)
      .attr('y', this.properties.textPositionY)
      .classed('mouse-area', this.properties.mouseAreaClass);
    textUpdate.exit().remove();
    textUpdate.enter()
      .append('text')
      .classed('text', true)
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'hanging')
      .attr('y', this.properties.textPositionY)
      .classed('mouse-area', this.properties.mouseAreaClass)
      .text(d => d.name);

    // Alert icons.
    containers
      .filter(d => !d.alerts || d.alerts.length === 0)
      .selectAll('g.alerts')
      .remove();

    const alertsUpdate = containers
      .filter(d => d.alerts && d.alerts.length > 0)
      .selectAll('g.alerts')
      .data(d => [d])
      .classed('hidden', !this.showAlerts)
      .attr('transform', `translate(0,${this.properties.alertsPositionY()})`);
    const alertsEnter = alertsUpdate.enter()
      .append('g')
      .classed('alerts', true)
      .classed('hidden', !this.showAlerts)
      .attr('transform', `translate(0,${this.properties.alertsPositionY()})`);
    const alerts = alertsUpdate.merge(alertsEnter);

    const alertTextUpdate = alerts
      .selectAll('text.alert.text')
      .data(d => d.alerts)
      .attr('alignment-baseline', 'hanging')
      .attr('text-anchor', 'start')
      .classed('mouse-area', true)
      .text(d => d.value);
    alertTextUpdate.exit().remove();
    alertTextUpdate.enter()
      .append('text')
      .classed('alert', true)
      .classed('text', true)
      .attr('alignment-baseline', 'hanging')
      .attr('text-anchor', 'start')
      .classed('mouse-area', true)
      .text(d => d.value);

    const alertsIconUpdate = alerts
      .selectAll('text.alert.icon')
      .data(d => d.alerts)
      .attr('class', d => `alert ${this.colorScale.get()(d.name)}`)
      .classed('mouse-area', true);
    alertsIconUpdate.exit().remove();
    const alertsIconEnter = alertsIconUpdate.enter()
      .append('text')
      .attr('class', d => `alert ${this.colorScale.get()(d.name)}`)
      .classed('mouse-area', true);

    alertsIconUpdate.merge(alertsIconEnter)
      .attr('alignment-baseline', 'hanging')
      .attr('text-anchor', 'end')
      .text(function () {
        return (getComputedStyle(this, ':before').content).slice(1, -1);
      });

    // Calculate alert positions.
    alerts.each(function () {
      let maxLength = 0;
      d3.select(this)
        .selectAll('text.text')
        .each(function () {
          maxLength = Math.max(this.getComputedTextLength(), maxLength);
        })
        .attr('transform', (d, i) => `translate(${-maxLength / 2 + 14 / 2}, ${i * 16})`);
      d3.select(this)
        .selectAll('text.icon')
        .attr('transform', (d, i) => `translate(${-maxLength / 2 + 6 / 2}, ${i * 16})`);
    });

    if (this.simulation === false) {
      if (this.isProcessed === false) {
        const keyNodeMap = {};
        this.data.nodes.forEach(node => { keyNodeMap[node.key] = node; });
        this.data.links.forEach(link => {
          link.source = keyNodeMap[link.source];
          link.target = keyNodeMap[link.target];
        });
      }
      this.isProcessed = true;

      this._updatePositions();
    } else {
      // Start a simulation.
      if (this.isProcessed !== true) {
        if (this._simulation) {
          this._simulation.stop();
          this._simulation = undefined;
        }

        this._simulation = d3.forceSimulation(this.data.nodes)
          .force('link', d3.forceLink().id(d => d.key).links(this.data.links))
          .force('charge', d3.forceManyBody().strength(-5000))
          .force('centerX', d3.forceX(0).strength(0.2))
          .force('centerY', d3.forceY(0).strength(0.2))
          .on('tick', this._updatePositions.bind(this));
        this.isProcessed = true;
      }
    }
  }

  /**
   * Update node locations from computed input.
   */
  _updatePositions() {
    const links = this._links;
    const nodes = this._nodes;
    const linkNodes = this._linkNodes;

    links
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y);

    nodes
      .attr('transform', d => `translate(${d.x},${d.y})`);

    linkNodes
      .attr('transform', d => {
        const x = (d.source.x + d.target.x) / 2.0;
        const y = (d.source.y + d.target.y) / 2.0;
        return `translate(${x},${y})`;
      });
  }

  /**
   * Destroy method
   */
  destroy() {
    this.element.innerHTML = '';
  }
}
