import * as d3 from 'd3';

import { Dropdown } from '../../../dropdown/Dropdown';
import { ColorScale } from '../../common/ColorScale';

/**
 * Setup chart properties.
 * @param {Object}      props - The properties to initialize the stage
 * @param {Object}      props.data - The data necessary to draw the chart
 * @param {HTMLElement} props.element - The DOM element to append the chart
 * @param {boolean}     props.compact - If to initialize the chart in compact mode
 * @param {boolean}     props.alerts - If to initialize the chart in alert mode
 * @param {boolean}     props.horizontal - If to draw the chart in horizontal mode
 * @param {Function}    props.onDropdownClick - A callback to react to dropdown click events
 */
export class HierarchyChart {
  constructor(props) {
    this.element = props.element;

    this.height = props.height || 1000;
    this.horizontal = props.horizontal || false;

    this.data = props.data;
    this.dropdowns = [];

    this.compactView = props.compact === true ? true : false;
    this.showValues = props.alerts === true ? true : false;

    this.onDropdownClick = props.onDropdownClick;

    this.listeners = {
      onDropdownClick: d => {
        if (this.onDropdownClick) {
          this.onDropdownClick(d);
        }
      }
    };
  }

  init() {
    const _this = this;

    this.canvas = d3.select(this.element);
    this.canvas.classed('hierarchy-chart', true);

    // Color scale.
    this.colorScale = new ColorScale({});
    this.colorScale.init();

    if (this.data.alerts && this.data.alerts.length > 0) {
      this.colorScale.set(d3.scaleOrdinal()
        .domain(this.data.alerts.map(d => d.name))
        .range([
          'icon icon-severity-critical color-red',
          'icon icon-severity-major color-orange',
          'icon icon-severity-minor color-yellow',
          'icon icon-severity-warning color-blue',
          'icon icon-severity-indeterminate color-gray',
          'icon icon-severity-cleared color-green'
        ])
      );
    }

    // Add switches.
    this.legendCompact = this.canvas
      .append('div');
    this.labelCompact = this.legendCompact
      .append('label')
      .classed('switch', true);
    const inputCheckboxCompact = this.labelCompact
      .append('input')
      .attr('type', 'checkbox')
      .on('click', function () {
        _this.compactView = this.checked;
        _this.canvas.select('.root-container')
          .classed('compact', _this.compactView);
      });
    if (this.compactView) {
      inputCheckboxCompact.attr('checked', true);
    }
    this.labelCompact
      .append('i')
      .classed('ball', true);
    this.labelCompact
      .append('span')
      .attr('data-enabled', 'Compact view on')
      .attr('data-disabled', 'Compact view off');

    this.legendAlerts = this.canvas
      .append('div');
    this.labelAlerts = this.legendAlerts
      .append('label')
      .classed('switch', true);
    this.inputCheckboxAlerts = this.labelAlerts
      .append('input')
      .attr('type', 'checkbox')
      .on('click', function () {
        _this.showValues = this.checked;
        _this.canvas.selectAll('.alerts').classed('hidden', !_this.showValues);
      });
    if (this.showValues) {
      this.inputCheckboxAlerts.attr('checked', true);
    }
    this.labelAlerts
      .append('i')
      .classed('ball', true);
    this.labelAlerts
      .append('span')
      .attr('data-enabled', 'Alerts on')
      .attr('data-disabled', 'Alerts off');

    // Diagram container.
    this.rootContainer = this.canvas
      .append('div')
      .classed('root-container', true)
      .style('max-height', `${this.height}px`)
      .classed('compact', this.compactView)
      .classed('horizontal', this.horizontal);

    this.draw(this.data);
  }

  draw(data) {
    if (data) {
      this.data = data;
    }

    this.dropdowns.forEach(dropdown => dropdown.destroy());
    this.dropdowns = [];

    this.rootContainer.text('');

    if (this._hasAlerts(this.data.nodes)) {
      this.inputCheckboxAlerts.property('disabled', false);
    } else {
      this.inputCheckboxAlerts.property('disabled', true);
    }

    const rootNode = this.rootContainer
      .append('table')
      .classed('root-table', true);

    const rootCellContainer = rootNode
      .append('tr');

    const subTreeTables = rootCellContainer.selectAll('td')
      .data(data.nodes, d => d.key)
      .enter()
      .append('td')
      .classed('root-td', true);

    if (this.horizontal !== true) {
      this._renderVerticalSubTree(subTreeTables, 0);
    } else {
      this._renderHorizontalSubTree(subTreeTables, 0);
    }
  }

  _hasAlerts(nodes) {
    if (nodes && nodes.length === 0) {
      return false;
    }

    for (let i = 0; i < nodes.length; i += 1) {
      if (nodes[i].alerts && nodes[i].alerts.length > 0) {
        return true;
      } else if (nodes[i].children && nodes[i].children.length > 0) {
        if (this._hasAlerts(nodes[i].children)) {
          return true;
        }
      }
    }

    return false;
  }

  _renderCellData(container) {
    const card = container
      .append('div')
      .attr('class', function (d) {
        const classes = ['card'];
        if (d.alerts && d.alerts.length > 0) {
          classes.push('alert');
        } else {
          classes.push('normal');
        }
        return classes.join(' ');
      })
      .on('click', function (d) {
        const dropdown = this.querySelector('.dropdown');
        const table = this.closest('.child-table');
        const target = d3.event.target ? d3.event.target : d3.event.srcElement;

        if (
          dropdown && dropdown === target ||
          dropdown && dropdown.contains(target)
        ) {
          return;
        }

        if (table && table.classList.contains('closed')) {
          d.open = true;
          table.classList.remove('closed');
        } else {
          d.open = false;
          table.classList.add('closed');
        }
      });

    // Setup elements.
    card
      .append('span')
      .classed('key', true)
      .text(d => d.key);
    card
      .filter(d => d.hasSibling)
      .append('span')
      .classed('sibling', true)
      .on('touchmove mousemove', d => {
        this.canvas.selectAll('.card').each(function (a) {
          if (d === a) {
            this.classList.add('marked');
          } else if (a.children && a.children.indexOf(d) !== -1) {
            this.classList.add('marked');
          } else {
            this.classList.remove('marked');
          }
        });
      })
      .on('touchend mouseleave', () => {
        this.canvas.selectAll('.card').each(function () {
          this.classList.remove('marked');
        });
      });

    const header = card
      .append('div')
      .classed('header', true);
    const headerLeft = header
      .append('div')
      .classed('left', true);
    const headerRight = header
      .append('div')
      .classed('right', true);
    const content = card
      .append('div')
      .classed('content', true);

    headerLeft
      .filter(d => d.title ? d.title.length > 0 : false)
      .append('div')
      .classed('title', true)
      .text(d => d.title);
    headerLeft
      .filter(d => d.subtitle ? d.subtitle.length > 0 : false)
      .append('span')
      .classed('subtitle', true)
      .text(d => d.subtitle);

    content.selectAll('p.description')
      .data(d => d.descriptions ? d.descriptions : [])
      .enter()
      .append('p')
      .classed('description', true)
      .text(d => d);

    // Setup dropdown.
    const more = headerRight
      .filter(d => d.menus ? d.menus.length > 0 : false)
      .append('div')
      .classed('action', true)
      .append('div')
      .classed('dropdown', true)
      .classed('more', true)
      .attr('data-type', 'click');
    const button = more
      .append('button')
      .classed('btn', true)
      .classed('clickable', true);
    button
      .append('i')
      .classed('icon', true)
      .classed('icon-more', true);
    const menu = more
      .append('div')
      .classed('menu', true)
      .classed('right', true);
    menu
      .selectAll('div.item')
      .data(d => d.menus ? d.menus : [])
      .enter()
      .append('div')
      .classed('item', true)
      .text(d => d.title)
      .on('click', this.listeners.onDropdownClick);

    more.nodes().forEach(node => {
      const dropdown = new Dropdown(node);
      dropdown.init();
      this.dropdowns.push(dropdown);
    });

    // Setup value icons.
    const values = card
      .filter(d => d.alerts && d.alerts.length > 0)
      .append('div')
      .classed('alerts', true)
      .classed('hidden', !this.showValues)
      .selectAll('div.value')
      .data(d => d.alerts)
      .enter()
      .append('div')
      .classed('value', true)
      .on('touchmove mousemove', () => {
        this.canvas.selectAll('.card.normal').style('opacity', '0.2');
        if (this.horizontal === true) {
          this.canvas.selectAll('.line-horizontal-bottom').style('opacity', '0.2');
          this.canvas.selectAll('.line-horizontal-left').style('opacity', '0.2');
          this.canvas.selectAll('.line-horizontal-right').style('opacity', '0.2');
        } else {
          this.canvas.selectAll('.line-vertical-left').style('opacity', '0.2');
          this.canvas.selectAll('.line-vertical-top').style('opacity', '0.2');
          this.canvas.selectAll('.line-vertical-down').style('opacity', '0.2');
        }
      })
      .on('touchend mouseleave', () => {
        this.canvas.selectAll('.card.normal').style('opacity', '');
        if (this.horizontal === true) {
          this.canvas.selectAll('.line-horizontal-bottom').style('opacity', '');
          this.canvas.selectAll('.line-horizontal-left').style('opacity', '');
          this.canvas.selectAll('.line-horizontal-right').style('opacity', '');
        } else {
          this.canvas.selectAll('.line-vertical-left').style('opacity', '');
          this.canvas.selectAll('.line-vertical-top').style('opacity', '');
          this.canvas.selectAll('.line-vertical-down').style('opacity', '');
        }
      });

    const tooltips = values
      .classed('tooltip', true)
      .append('div')
      .classed('message bottom white', true);
    tooltips
      .append('p')
      .classed('title', true)
      .text(d => `${d.name} (${d.value})`);
    tooltips
      .selectAll('p.description')
      .data(d => d && d.descriptions ? d.descriptions : [])
      .enter()
      .append('p')
      .classed('description', true)
      .text(d => d);

    values
      .append('i')
      .attr('class', d => this.colorScale.get()(d.name))
      .classed('icon', true);

    values
      .append('p')
      .text(d => d.value);
  }

  _renderVerticalSubTree(nodeRows, depth) {
    if (nodeRows.data().length === 0) {
      return;
    }

    const tables = nodeRows.append('table')
      .attr('class', d => {
        const classes = ['child-table'];
        if (d.open === false || d.open === undefined && depth >= 2) {
          d.open = false;
          classes.push('closed');
        } else {
          d.open = true;
        }
        return classes.join(' ');
      });
    const tablesWithChildren = tables.filter(d => d.children && d.children.length > 0);

    // Cell container.
    const cellContainer = tables.append('tr')
      .classed('tr-node', true)
      .append('td')
      .attr('colspan', d => d.children ? d.children.length * 2 : '')
      .append('div')
      .classed('node-container', true);

    // Line down.
    tablesWithChildren.append('tr')
      .classed('tr-line', true)
      .append('td')
      .attr('colspan', d => d.children.length * 2)
      .append('div')
      .classed('line-vertical-down', true);

    // Line connections.
    tablesWithChildren
      .append('tr')
      .classed('tr-line', true)
      .each(function (d) {
        const row = d3.select(this);
        const numberOfChildren = d.children.length;

        d.children.forEach((child, i) => {
          const left = row.append('td');
          const right = row.append('td');

          left.classed('line-vertical-right', true);
          right.classed('line-vertical-left', true);

          if (i !== 0) {
            left.classed('line-vertical-top', true);
          }
          if (i !== (numberOfChildren - 1)) {
            right.classed('line-vertical-top', true);
          }
        });
      });

    const nextNodeRows = tablesWithChildren.append('tr').classed('tr-child', true);
    const nextNodeCells = nextNodeRows
      .selectAll('td')
      .data(d => d.children)
      .enter()
      .append('td')
      .attr('colspan', 2);

    this._renderCellData(cellContainer);
    this._renderVerticalSubTree(nextNodeCells, depth + 1);
  }

  _renderHorizontalSubTree(nodeRows, depth) {
    if (nodeRows.data().length === 0) {
      return;
    }

    const tables = nodeRows.append('table')
      .attr('class', d => {
        const classes = ['child-table', 'horizontal'];
        if (d.open === false || d.open !== true && depth >= 2) {
          d.open = false;
          classes.push('closed');
        } else {
          d.open = true;
        }
        return classes.join(' ');
      });
    const tablesWithoutChildren = tables.filter(d => !(d.children && d.children.length > 0));
    const tablesWithChildren = tables.filter(d => d.children && d.children.length > 0);

    // cell container.
    const cellsWithoutChildrenContainer = tablesWithoutChildren
      .append('tr')
      .classed('tr-node', true)
      .append('td')
      .append('div')
      .classed('node-container', true)
      .classed('horizontal', true);

    const rowWithChildren = tablesWithChildren
      .append('tr')
      .classed('tr-node', true);
    const cellsWithChildrenContainer = rowWithChildren
      .append('td')
      .attr('rowspan', d => d.children ? d.children.length * 2 : '')
      .append('div')
      .classed('node-container', true)
      .classed('horizontal', true);

    // Line right.
    rowWithChildren
      .append('td')
      .attr('rowspan', d => d.children ? d.children.length * 2 : '')
      .classed('line-horizontal-right-container', true)
      .append('div')
      .classed('line-horizontal-right', true);

    // Line connections and nodes.
    rowWithChildren
      .append('td')
      .classed('line-horizontal-bottom', true);
    let children = rowWithChildren
      .append('td')
      .classed('td-child', true)
      .attr('rowspan', 2);

    tablesWithChildren.each(function (d) {
      const element = d3.select(this);
      const numberOfChildren = d.children.length;
      d.children.forEach((_, i) => {
        const top = element
          .append('tr')
          .append('td')
          .classed('line-horizontal-top', true);
        if (i !== (numberOfChildren - 1)) {
          top.classed('line-horizontal-left', true);
        }

        if (i !== (numberOfChildren - 1)) {
          const row = element.append('tr');
          row.append('td')
            .classed('line-horizontal-bottom', true)
            .classed('line-horizontal-left', true);
          children = children.merge(row.append('td')
            .classed('td-child', true)
            .attr('rowspan', 2));
        }
      });
    });

    const nextNodeCells = tablesWithChildren
      .selectAll('td.td-child')
      .data(d => d.children);

    this._renderCellData(cellsWithoutChildrenContainer);
    this._renderCellData(cellsWithChildrenContainer);
    this._renderHorizontalSubTree(nextNodeCells, depth + 1);
  }

  destroy() {
    this.dropdowns.forEach(dropdown => {
      dropdown.destroy();
    });
    this.element.innerText = '';
  }
}
