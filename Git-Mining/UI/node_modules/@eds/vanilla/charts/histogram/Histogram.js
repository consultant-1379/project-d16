/**
 * @file Component to create histogram
 */

import * as d3 from 'd3';
import { Stage } from '../common/Stage';
import { Axis } from '../common/Axis';
import { Tooltip } from '../common/Tooltip';
import { Legend } from '../common/Legend';
import { ColorScale } from '../common/ColorScale';

export class Histogram {

  /**
   * Setup chart properties
   * @param {Object} props - The properties to initialize the stage
   * @param {Object[]} props.data - The data necessary to draw the chart
   * @param {HTMLElement} props.element - The DOM element to append the chart
   * @param {number} [props.height] - The height of the chart
   * @param {Object} [props.margin] - The top, right, bottom and left margins
   * @param {number} [props.margin.top] - The top margin
   * @param {number} [props.margin.right] - The right margin
   * @param {number} [props.margin.bottom] - The bottom margin
   * @param {number} [props.margin.left] - The left margin
   * @param {Object[]} [props.thresholds] - Thresholds that can be added to a chart
   * @param {number} [props.thresholds[].moreThan] - Sets the positive threshold
   * @param {number} [props.thresholds[].lessThan] - Sets the negative threshold
   * @param {string} [props.thresholds[].color] - Threshold color (green, red)
   * @param {string} [props.y] - The Y axis properties
   * @param {string} [props.y.unit] - The unit of the Y axis
   * @param {string} [props.x] - The X axis properties
   * @param {string} [props.x.unit] - The unit of the X axis
   */

  constructor(props) {
    this.data = props.data;
    this.element = props.element;
    this.height = props.height || 250;
    this.margin = {
      top: 16,
      bottom: 32,
      right: 24,
      left: 40,
      ...props.margin,
    };

    this.thresholds = props.thresholds;
    this.y = {
      unit: '',
      ...props.y,
    };

    this.x = {
      unit: '',
      binSize: props.x.binSize || 'medium',
      ...props.x,
    };

    this.axisPadding = 8;
    this.fontSize = 14;

    if (this.thresholds) {
      this.margin.right += this.axisPadding;
    }

    if (this.x.unit) {
      this.margin.bottom += this.fontSize + this.axisPadding;
    }
  }

  /**
   * Initialize the chart
   */

  init() {
    this.stage = new Stage({
      element: this.element,
      margin: this.margin,
      height: this.height,
    });

    this.stage.init();
    this.stage.onResize(this.draw.bind(this));

    this.canvas = this.stage.getCanvas();

    this.colorScale = new ColorScale({
      length: this.data.series.length
    });

    this.colorScale.init();

    this.legend = new Legend({
      element: this.element,
      data: this.data,
      draw: this.draw.bind(this),
      highlight: this._highlight.bind(this),
      margin: {
        left: 0
      }
    });
    this.legend.init();

    this.tooltip = new Tooltip({
      element: this.element,
      data: this.data,
      hoverClass: 'line-hover',
      unit: {
        value: this.x.unit,
      }
    });

    this.tooltip.init();
    this.draw();
  }

  /**
   * Destroy the cart
   */

  destroy() {
    this.stage.destroy();
  }

  /**
   * Draw the chart based on data
   * @param {Object} data - The data necessary to draw the chart
   */

  draw(data) {
    this.data = data || this.data;
    this.data = this.legend.filter(this.data);
    this.width = this.stage.getCanvasWidth();
    this.canvas.classed('histogram', true);

    // Number of bars (resolution of histogram)
    let dividend = 25;
    const size = {
      small: 15,
      medium: 25,
      large: 50
    };
    const binSize = this.x.binSize;
    if(!isNaN(binSize)){
      dividend = binSize;
    } else {
      if(size[binSize] !== undefined){
        dividend = size[binSize];
      }
    }

    const count = Math.round(this.width / dividend);

    const x = d3.scaleLinear()
      .domain([
        d3.min(this.data.series, d => d3.min(d.values)),
        d3.max(this.data.series, d => d3.max(d.values))
      ])
      .nice()
      .range([0, this.width]);

    const histogram = d3.histogram().domain(x.domain()).thresholds(x.ticks(count));
    const bins = [];
    this.data.series.forEach(serie => bins.push(histogram(serie.values)));

    const xAxis = new Axis({
      position: 'bottom',
      canvas: this.canvas,
      x: x,
      width: this.width,
      height: this.height,
      margin: this.margin,
      fontSize: this.fontSize,
      axisPadding: this.axisPadding,
      hasDomain: true,
      tickFormat: (d) => d3.format('.2s')(d).replace('.0', ''),
      unit: this.x.unit
    });
    xAxis.init();

    const y = d3.scaleLinear()
      .domain([0, d3.max(bins, d => d3.max(d, e => e.length))])
      .nice()
      .range([this.height, 0]);

    const yAxis = new Axis({
      position: 'left',
      canvas: this.canvas,
      y: y,
      width: this.width,
      height: this.height,
      fontSize: this.fontSize,
      axisPadding: this.axisPadding,
      ticks: this.height / 60,
      thresholds: this.thresholds
    });
    yAxis.init();

    const barGroups = this.canvas
      .selectAll('.bar-group')
      .data(bins[0] || []);

    let barGroupsEnter = barGroups
      .enter()
      .append('g')
      .classed('bar-group', true);

    barGroupsEnter = barGroupsEnter
      .merge(barGroups)
      .attr('transform', d => `translate(${x(d.x0)} ,0)`);

    const bars = barGroupsEnter
      .merge(barGroups)
      .selectAll('.bar')
      .data((d, i) => {
        const histogramSeries = [];
        bins.forEach((bin, k) => histogramSeries.push({
          name: this.data.series[k].name,
          histogram: bin[i]
        }));
        return histogramSeries;
      });

    const getThresholdsClass = d => {
      let color = '';
      if (this.thresholds) {
        this.thresholds
          .sort((a, b) => a.moreThan - b.moreThan || b.lessThan - a.lessThan)
          .forEach(t => {
            if (t.moreThan && d >= t.moreThan || t.lessThan && d <= t.lessThan) {
              color = t.color;
            }
          });
      }
      return color;
    };

    bars
      .enter()
      .append('rect')
      .merge(bars)
      .attr('class', d => 'bar ' + this.colorScale.get()(d.name) + ' ' + getThresholdsClass(d.histogram.length))
      .style('pointer-events', 'none')
      .transition()
      .duration(400)
      .attr('x', (d, i) => i * 6)
      .attr('width', d => Math.max(0, x(d.histogram.x1) - x(d.histogram.x0) - bins.length * 5))
      .attr('y', d => y(d.histogram.length))
      .attr('height', d => y(0) - y(d.histogram.length));

    const barsHover = barGroupsEnter
      .merge(barGroups)
      .selectAll('.line-hover')
      .data(d => [d]);

    barsHover
      .enter()
      .append('rect')
      .merge(barsHover)
      .classed('line-hover', true)
      .attr('width', d => x(d.x1) - x(d.x0))
      .attr('stroke-width', 1)
      .attr('stroke', 'red')
      .attr('fill', 'blue')
      .attr('opacity', '0')
      .attr('height', this.height)
      .attr('y', 0)
      .on('mouseover', (group, i, selection) => {
        const all = barGroupsEnter.selectAll('.bar');
        all.attr('opacity', '.2');
        const histogramSeries = [];
        d3.select(selection[i].parentNode)
          .selectAll('.bar')
          .attr('opacity', d => {
            histogramSeries.push({
              name: d.name,
              values: [d.histogram.length]
            });
            return 1;
          });

        const newData = {
          common: [`[${group.x0}, ${group.x1}]`],
          series: histogramSeries
        };
        this.tooltip.update(0, newData);
      })
      .on('mouseout', () => {
        const all = barGroupsEnter.selectAll('.bar');
        all.attr('opacity', '1');
      });

    barGroups.exit().remove();
    bars.exit()
      .transition()
      .duration(400)
      .attr('y', y(0))
      .attr('height', 0)
      .remove();
    barsHover.exit().remove();
  }

  /**
   * Highlight one common element in all series
   * @param {String} key - The key matching the common element
   * @private
   */

  _highlight(key) {
    const barGroups = this.canvas
      .selectAll('.bar-group');

    if (key) {
      let idx = 0;
      this.data.series.forEach((serie, i) => {
        if (serie.name === key) {
          idx = i;
        }
      });

      barGroups.selectAll('.bar').attr('opacity', (d, i) => i === idx ? '1' : '.2');
    } else {
      barGroups.selectAll('.bar').attr('opacity', '1');
    }
  }
}
