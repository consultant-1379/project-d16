/**
 * @file Module to create Horizontal Bar Chart Grouped component.
 * @requires d3
 * @requires Stage
 * @requires Axis
 * @requires Tooltip
 * @requires Legend
 * @requires ColorScale
 */

import * as d3 from 'd3';
import { Stage } from '../common/Stage';
import { Axis } from '../common/Axis';
import { Tooltip } from '../common/Tooltip';
import { Legend } from '../common/Legend';
import { ColorScale } from '../common/ColorScale';

/**
 * Class representing a horizontal bar grouped chart.
 */
export class HorizontalBarChartGrouped {

  /**
   * Setup chart properties.
   * @param {Object} props - The properties to initialize the stage.
   * @param {Object} props.data - The data necessary to draw the chart.
   * @param {HTMLElement} props.element - The DOM element to append the chart.
   * @param {number} [props.height] - The height of the chart.
   * @param {Object} [props.margin] - The top, right, bottom and left margins.
   * @param {number} [props.margin.top] - The top margin.
   * @param {number} [props.margin.right] - The right margin.
   * @param {number} [props.margin.bottom] - The bottom margin.
   * @param {number} [props.margin.left] - The left margin.
   * @param {string} [props.x] - The X axis properties.
   * @param {string} [props.x.unit] - The unit of the X axis.
   * @param {Object} [props.tooltip] - Tooltip properties.
   * @param {boolean} [props.tooltip.isHidden] - Hide the tooltip.
   * @param {Object} [props.tooltip.format] - Format necessary for representing data.
   * @param {string} [props.tooltip.format.time] - Time specific format (see D3 formats).
   * @param {string} [props.tooltip.format.value] - Number specific format (see D3 formats).
   */
  constructor(props) {
    this.data = props.data;
    this.element = props.element;
    this.margin = {
      left: 16,
      right: 24,
      top: 16,
      bottom: 32,
      ...props.margin,
    };

    this.height = props.height || 250;
    this.thresholds = props.thresholds;
    this.x = { unit: '', ...props.x };
    this.tooltip = {
      ...props.tooltip
    };

    this.axisPadding = 8;
    this.fontSize = 14;
    this.barWidth = 6;
    this.animationSpeed = 400;

    if (this.x.unit) {
      this.margin.bottom += this.fontSize + this.axisPadding;
    }
  }

  /**
   * Initialize the chart
   * @public
   */

  init() {
    this.stage = new Stage({
      element: this.element,
      margin: this.margin,
      height: this.height
    });

    this.stage.init();
    this.stage.onResize(this.draw.bind(this));

    this.canvas = this.stage.getCanvas();

    this.colorScale = new ColorScale({
      length: this.data.series.length
    });

    this.colorScale.init();

    this.legend = new Legend({
      element: this.element,
      data: this.data,
      draw: this.draw.bind(this),
      highlight: this._highlight.bind(this),
      margin: this.margin
    });
    this.legend.init();

    this.tooltip = new Tooltip({
      element: this.element,
      data: this.data,
      unit: {
        value: this.x.unit
      },
      hoverClass: 'line-hover'
    });

    this.tooltip.init();

    this.draw();
  }

  /**
   * Destroy the chart and associated events.
   * @public
   */

  destroy() {
    this.stage.destroy();
  }

  /**
   * Draw the chart based on data.
   * @public
   * @param {Object} data - The data necessary to draw the chart.
   */

  draw(data) {
    this.data = data || this.data;
    this.data = this.legend.filter(this.data);
    this.width = this.stage.getCanvasWidth();

    const y0 = d3.scaleBand()
      .domain(this.data.common)
      .rangeRound([this.axisPadding, this.height + this.fontSize])
      .paddingInner(0.4)
      .paddingOuter(0.3);

    const y1 = d3.scaleBand()
      .domain(this.data.series.map(d => d.name))
      .rangeRound([0, y0.bandwidth()])
      .padding(0);

    const xMin = d3.min(this.data.series, d => d3.min(d.values)) >= 0 ? 0 :
      d3.min(this.data.series, d => d3.min(d.values));
    const xMax = d3.max(this.data.series, d => d3.max(d.values));
    const x = d3.scaleLinear()
      .domain([xMin, xMax])
      .nice()
      .rangeRound([0, this.width]);

    const axis = new Axis({
      position: 'bottom',
      canvas: this.canvas,
      x: x,
      width: this.width,
      height: this.height,
      margin: this.margin,
      fontSize: this.fontSize,
      axisPadding: this.axisPadding,
      tickFormat: (d) => d3.format('.2s')(d).replace('.0', ''),
      unit: this.x.unit
    });

    axis.init();

    const hasLabelSpace =
      this.height / this.data.common.length >
      this.axisPadding * 2 + this.fontSize + this.barWidth * this.data.common.length;

    const barGroups = this.canvas
      .classed('bar-chart', true)
      .selectAll('.bar-group')
      .data(this.data.common);

    const barGroupsEnter = barGroups
      .enter()
      .append('g')
      .classed('bar-group', true);

    barGroupsEnter
      .append('text')
      .classed('label', true)
      .classed('hidden', !hasLabelSpace)
      .attr('x', '2')
      .attr('y', -this.barWidth - 2)
      .style('pointer-events', 'none')
      .text(d => d);

    barGroups
      .selectAll('.line-hover')
      .attr('x1', -this.width)
      .attr('x2', this.width);

    barGroupsEnter
      .merge(barGroups)
      .transition()
      .duration(this.animationSpeed)
      .attr('transform', d => `translate(${isNaN(x(0)) ? 1 : x(0) + 1}, ${y0(d)})`);

    const bars = barGroupsEnter
      .merge(barGroups)
      .selectAll('.bar')
      .data((d, i) => this.data.series.map(serie => ({ key: serie.name, value: serie.values[i] })));

    bars
      .enter()
      .append('line')
      .merge(bars)
      .style('pointer-events', 'none')
      .attr('stroke-width', this.barWidth)
      .attr('class', d => 'bar ' + this.colorScale.get()(d.key))
      .transition()
      .duration(this.animationSpeed)
      .attr('y1', d => y1(d.key))
      .attr('y2', d => y1(d.key))
      .attr('x1', 0)
      .attr('x2', d => isNaN(d.value) ? 0 : x(d.value) - x(0));

    barGroups
      .exit()
      .remove();

    bars
      .exit()
      .transition()
      .duration(this.animationSpeed)
      .attr('x2', 0)
      .remove();

    if (this.data.series.length > 0) {
      barGroupsEnter
        .append('line')
        .classed('line-hover', true)
        .attr('stroke-width', y0(this.data.common[1]) - y0(this.data.common[0]))
        .attr('stroke', 'blue')
        .attr('opacity', '0')
        .attr('x1', -this.width)
        .attr('x2', this.width)
        .on('mouseover', (group, i, selection) => {
          const all = barGroupsEnter.selectAll('.bar');
          const allLabels = barGroupsEnter.selectAll('.label');

          this.tooltip.update(i, this.data);

          all.attr('opacity', '.2');
          allLabels.attr('opacity', '.2');

          d3.select(selection[i].parentNode).selectAll('.bar').attr('opacity', '1');
          d3.select(selection[i].parentNode).selectAll('.label').attr('opacity', '1');
        })
        .on('mouseout', () => {
          const all = barGroupsEnter.selectAll('.bar');
          const allLabels = barGroupsEnter.selectAll('.label');

          all.attr('opacity', '1');
          allLabels.attr('opacity', '1');
        });
    }
  }

  /**
   * Highlight one common element in all series.
   * @private
   * @param {String} key - The key matching the common element.
   */

  _highlight(key) {
    const bars = this.canvas
      .selectAll('.bar');

    if (key) {
      bars.attr('opacity', d => d.key === key ? '1' : '.2');
    } else {
      bars.attr('opacity', '1');
    }
  }
}
