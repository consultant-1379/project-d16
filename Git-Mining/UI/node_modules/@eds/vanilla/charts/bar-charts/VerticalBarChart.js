/**
 * @file Component to create vertical bar chart
 */

import * as d3 from 'd3';

import { Stage } from '../common/Stage';
import { Axis } from '../common/Axis';
import { Legend } from '../common/Legend';
import { ColorScale } from '../common/ColorScale';

export class VerticalBarChart {

  /**
   * Setup chart properties
   * @param {Object} props - The properties to initialize the stage
   * @param {Object[]} props.data - The data necessary to draw the chart
   * @param {HTMLElement} props.element - The DOM element to append the chart
   * @param {number} [props.height] - The height of the chart
   * @param {Object} [props.margin] - The top, right, bottom and left margins
   * @param {number} [props.margin.top] - The top margin
   * @param {number} [props.margin.right] - The right margin
   * @param {number} [props.margin.bottom] - The bottom margin
   * @param {number} [props.margin.left] - The left margin
   * @param {Object[]} [props.thresholds] - Thresholds that can be added to a chart
   * @param {number} [props.thresholds[].moreThan] - Sets the positive threshold
   * @param {number} [props.thresholds[].lessThan] - Sets the negative threshold
   * @param {string} [props.thresholds[].color] - Threshold color (green, red)
   * @param {string} [props.y] - The Y axis properties
   * @param {string} [props.y.unit] - The unit of the Y axis
   */
  constructor(props) {
    this.data = props.data;
    this.element = props.element;
    this.margin = {
      left: 32,
      right: 24,
      top: 24,
      bottom: 24,
      ...props.margin,
    };
    this.height = props.height || 250;
    this.thresholds = props.thresholds;
    this.y = { unit: '', ...props.y };

    this.axisPadding = 8;
    this.fontSize = 14;
    this.barWidth = 6;
    this.animationSpeed = 400;

    if (this.thresholds) {
      this.margin.right += this.axisPadding;
    }

    if (this.y.unit) {
      this.margin.top += this.fontSize;
    }
  }

  /**
   * Initialize the chart
   */

  init() {
    this.stage = new Stage({
      element: this.element,
      margin: this.margin,
      height: this.height
    });

    this.stage.init();
    this.stage.onResize(this.draw.bind(this));

    this.canvas = this.stage.getCanvas();

    this.colorScale = new ColorScale({
      length: this.data.series.length
    });

    this.colorScale.init();

    this.legend = new Legend({
      element: this.element,
      data: this.data,
      draw: this.draw.bind(this),
      margin: { ...this.margin, left: 0 }
    });
    this.legend.init();

    this.draw();
  }

  /**
   * Destroy the cart
   */
  destroy() {
    this.stage.destroy();
  }

  /**
   * Draw the chart based on data
   * @param {Object[]} data - The data necessary to draw the chart
   */

  draw(data) {
    this.data = data || this.data;
    this.data = this.legend.filter(this.data);
    this.width = this.stage.getCanvasWidth();

    const x0 = d3.scaleBand()
      .domain(this.data.common)
      .rangeRound([0, this.width])
      .paddingInner(0.7)
      .paddingOuter(0.3);

    const yMin = d3.min(this.data.series, d => d3.min(d.values)) >= 0 ? 0 :
      d3.min(this.data.series, d => d3.min(d.values));
    let yMax = 0;
    for (let i = 0; i < this.data.common.length; i += 1) {
      let sum = 0;

      for (let y = 0; y < this.data.series.length; y += 1) {
        sum += this.data.series[y].values[i];
      }
      if (sum > yMax) {
        yMax = sum;
      }
    }

    const y = d3.scaleLinear()
      .domain([yMin, yMax])
      .nice()
      .range([this.height, 0]);

    const axis = new Axis({
      position: 'left',
      canvas: this.canvas,
      y: y,
      width: this.width,
      height: this.height,
      margin: this.margin,
      fontSize: this.fontSize,
      axisPadding: this.axisPadding,
      thresholds: this.thresholds,
      ticks: this.height / 80,
      tickFormat: (d) => d3.format('.2s')(d).replace('.0', ''),
      unit: this.y.unit
    });

    axis.init();

    let hasLabelSpace = true;
    let hasNegativeValues = false;
    let seriesDistance;

    if (this.data.series.length > 0) {
      seriesDistance = x0(this.data.common[1]) - x0(this.data.common[0]);

      this.data.common.forEach(d => {
        if (hasLabelSpace) {
          hasLabelSpace = d.length * this.fontSize / 1.5 < seriesDistance;
        }
      });

      this.data.series.forEach(d => {
        if (!hasNegativeValues && d.values.filter(i => i < 0).length > 0) {
          hasNegativeValues = true;
        }

        d.values.forEach(value => {
          const valueLength = value.toString().length * this.fontSize / 1.5;
          if (hasLabelSpace) {
            hasLabelSpace = valueLength < seriesDistance;
          }
        });
      });
    }

    const barGroups = this.canvas
      .classed('bar-chart', true)
      .selectAll('.bar-group')
      .data(this.data.common);

    const barGroupsEnter = barGroups
      .enter()
      .append('g')
      .classed('bar-group', true);

    const barValuePosition = selection => {
      selection
        .text((d, i) => d3.format(',')(this.data.series[0].values[i]).replace(/,/g, ' '))
        .transition()
        .duration(this.animationSpeed)
        .attr('y', (d, i) =>
          y(this.data.series[0].values[i]) - y(0) + (this.data.series[0].values[i] >= 0 ? -4 : this.fontSize));
    };

    barGroupsEnter
      .append('text')
      .attr('text-anchor', 'middle')
      .classed('label', true)
      .classed('value', true)
      .classed('hidden', !hasLabelSpace)
      .call(barValuePosition);

    barGroupsEnter
      .append('text')
      .classed('label', true)
      .classed('text', true)
      .classed('hidden', !hasLabelSpace)
      .attr('text-anchor', 'middle')
      .style('pointer-events', 'none')
      .text(d => d)
      .transition()
      .duration(this.animationSpeed)
      .attr('y', hasNegativeValues ? this.height - y(0) + this.margin.bottom - 2 : this.fontSize + 2);

    barGroups
      .select('.label.value')
      .call(barValuePosition);

    barGroups
      .selectAll('.line-hover')
      .attr('stroke-width', seriesDistance);

    barGroupsEnter
      .merge(barGroups)
      .transition()
      .duration(this.animationSpeed)
      .attr('transform', d => `translate(${x0(d) + x0.bandwidth() / 2 + 1}, ${y(0, d)})`);

    const bars = barGroupsEnter
      .merge(barGroups)
      .selectAll('.bar')
      .data((d, i) => {
        const prevValues = [];
        return this.data.series.map((s, k) => {
          const getPrevious = () => {
            if (k === 0) {
              return 0;
            } else {
              prevValues.push(this.data.series[k - 1].values[i]);
              return prevValues.reduce((a, b) => a + b);
            }
          };

          return {
            key: s.name,
            value: s.values[i],
            previous: getPrevious()
          };
        });
      });

    const getThresholdsClass = d => {
      let color = '';
      if (this.thresholds) {
        this.thresholds
          .sort((a, b) => a.moreThan - b.moreThan || b.lessThan - a.lessThan)
          .forEach(t => {
            if (t.moreThan && d.value >= t.moreThan || t.lessThan && d.value <= t.lessThan) {
              color = t.color;
            }
          });
      }
      return color;
    };

    bars
      .enter()
      .append('line')
      .merge(bars)
      .style('pointer-events', 'none')
      .attr('stroke-width', this.barWidth)
      .attr('class', d => 'bar ' + this.colorScale.get()(d.key) + ' ' + getThresholdsClass(d))
      .transition()
      .duration(this.animationSpeed)
      .attr('y1', d => -(y(0) - y(d.previous)))
      .attr('y2', d => isNaN(d.value) ? 0 : -(y(0) - y(d.value) + y(0) - y(d.previous)));

    barGroups
      .exit()
      .remove();

    bars
      .exit()
      .transition()
      .duration(this.animationSpeed)
      .attr('y1', 0)
      .attr('y2', 0)
      .remove();

    if (this.data.series.length > 0) {
      barGroupsEnter
        .append('line')
        .classed('line-hover', true)
        .attr('stroke-width', seriesDistance)
        .attr('stroke', 'blue')
        .attr('opacity', '0')
        .attr('y1', -this.height)
        .attr('y2', this.height)
        .on('mouseover', (group, i, selection) => {
          const all = barGroupsEnter.selectAll('.bar');
          const allLabels = barGroupsEnter.selectAll('.label');

          all.attr('opacity', '.2');
          allLabels.attr('opacity', '.2');

          d3.select(selection[i].parentNode).selectAll('.bar').attr('opacity', '1');
          d3.select(selection[i].parentNode).selectAll('.label').attr('opacity', '1');
          d3.select(selection[i].parentNode).selectAll('.label').classed('hidden', false);
        })
        .on('mouseout', () => {
          const all = barGroupsEnter.selectAll('.bar');
          const allLabels = barGroupsEnter.selectAll('.label');

          all.attr('opacity', '1');
          allLabels.attr('opacity', '1');
          allLabels.classed('hidden', !hasLabelSpace);
        });
    }
  }
}
