import * as d3 from 'd3';

import { ColorScale } from '../common/ColorScale';
import { Legend } from '../common/Legend';
import { Tooltip } from '../common/Tooltip';
import { Stage } from '../common/Stage';

export class RadarChart {

  /**
   * Setup chart properties
   * @param {Object} props - The properties to initialize the stage
   * @param {Object} props.data - The data necessary to draw the chart
   * @param {HTMLElement} props.element - The DOM element to append the chart
   * @param {number} [props.height] - The height of the chart
   * @param {Object} [props.margin] - The top, right, bottom and left margins
   * @param {number} [props.margin.top] - The top margin
   * @param {number} [props.margin.right] - The right margin
   * @param {number} [props.margin.bottom] - The bottom margin
   * @param {number} [props.margin.left] - The left margin
   * @param {Object} [props.y] - Y axis properties
   * @param {string} [props.y.unit] - The Y axis unit
   * @param {boolean} [props.y.hideLabel] - If the y labels should be hidden
   * @param {Object} [props.x] - X axis properties
   * @param {string} [props.x.unit] - The X axis unit
   * @param {boolean} [props.x.hideLabel] - If the x labels should be hidden
   * @param {Tooltip} [props.tooltip] - Options for the tooltip
   */
  constructor(props) {
    this.data = props.data;
    this.element = props.element;
    this.height = props.height || 250;
    this.margin = {
      top: 25,
      bottom: 25,
      right: 25,
      left: 25,
      ...props.margin,
    };
    this.breakpointLimit = props.breakpoint || 400;
    this.y = {
      unit: '',
      hideLabel: false,
      ...props.y,
    };
    this.x = {
      unit: '',
      hideLabel: false,
      ...props.x,
    };
    this.tooltip = {
      format: {
        title: null,
        value: '.2f'
      },
      isHidden: false,
      ...props.tooltip,
    };
  }

  /**
   * Initialize the chart
   */
  init() {
    this.stage = new Stage({
      element: this.element,
      margin: {
        bottom: 0,
        left: 0,
        right: 0,
        top: 0
      },
      height: this.height,
    });
    this.stage.init();
    this.stage.onResize(this.draw.bind(this));

    this.canvas = this.stage.getCanvas();

    this.colorScale = new ColorScale({
      length: this.data.series.length
    });
    this.colorScale.init();

    const legend = new Legend({
      element: this.element,
      data: this.data,
      draw: this.draw.bind(this),
      highlight: this._highlight.bind(this),
      margin: {
        ...this.margin,
        left: 0
      }
    });
    legend.init();

    this.tooltipBox = new Tooltip({
      element: this.element,
      data: this.data,
      hoverClass: ['mouse-area', 'label'],
      format: this.tooltip.format,
      isTime: false,
      unit: {
        value: this.y.unit,
        title: this.x.unit,
      }
    });
    this.tooltipBox.init();

    this.animationSpeed = 950;
    this.outerLabelMargin = 14;
    this.firstDrawFlag = true;

    this.draw();
  }

  /**
   * Draw the chart based on data
   * @param {Object[]} data - The data necessary to draw the chart
   */
  draw(data) {
    const _this = this;

    this.data = data || this.data;
    this.width = this.stage.getCanvasWidth();

    const isBreakpointDraw = this.width <= this.breakpointLimit;
    const numberOfCommons = this.data.common.length;
    const angles = this.data.common.map((_, i) => Math.PI * 2 / numberOfCommons * i - Math.PI / 2);

    const rMin = d3.min(this.data.series, d => d3.min(d.values));
    const rMax = d3.max(this.data.series, d => d3.max(d.values));

    const effectiveWidth = this.width - this.margin.left - this.margin.right;
    const effectiveHeight = this.height - this.margin.top - this.margin.bottom;

    this.canvas.attr('transform', `translate(${this.margin.left},${this.margin.top})`);

    /**
     * Begin adjustment of margin so labels fit.
     */

    let autoMargin = 0;
    this.canvas.selectAll('text.temp')
      .data(this.data.common)
      .enter()
      .append('text')
      .classed('temp', true)
      .text(d => d)
      .each(function (d, i) {
        const { width, height } = this.getBBox();

        let rangeRadius;
        if (!isBreakpointDraw) {
          rangeRadius = Math.max(
            0,
            Math.min(effectiveWidth, effectiveHeight) / 2
          );
        } else {
          rangeRadius = Math.min(_this.width, _this.height) / 2;
        }

        const labelUnitX = Math.cos(angles[i]);
        const labelUnitY = Math.sin(angles[i]);
        const labelPositionX = (rangeRadius + _this.outerLabelMargin) * labelUnitX;
        const labelPositionY = (rangeRadius + _this.outerLabelMargin) * labelUnitY;

        let textOffsetPositionX = labelPositionX;
        let textOffsetPositionY = labelPositionY;

        if (i === 0) {
          textOffsetPositionX += width;
        } else if (angles.length % 2 === 0 && i === (angles.length / 2)) {
          textOffsetPositionX += width;
        } else {
          textOffsetPositionX += ((angles[i] > Math.PI / 2) ? -width : +width);
        }

        if (angles[i] > 0 && angles[i] < Math.PI) {
          textOffsetPositionY += height;
        } else {
          textOffsetPositionY -= height;
        }

        if (textOffsetPositionX > effectiveWidth / 2) {
          autoMargin = Math.max(autoMargin, textOffsetPositionX - effectiveWidth / 2);
        } else if (textOffsetPositionX < -effectiveWidth / 2) {
          autoMargin = Math.max(autoMargin, -textOffsetPositionX - effectiveWidth / 2);
        }
        if (textOffsetPositionY > effectiveHeight / 2) {
          autoMargin = Math.max(autoMargin, textOffsetPositionY - effectiveHeight / 2);
        } else if (textOffsetPositionY < -effectiveHeight / 2) {
          autoMargin = Math.max(autoMargin, -textOffsetPositionY - effectiveHeight / 2);
        }

        this.remove();
      });

    /**
     * End adjustment of margin so labels fit.
     */

    let rangeRadius;
    if (!isBreakpointDraw) {
      rangeRadius = Math.max(
        0,
        Math.min(
          effectiveWidth - 2 * autoMargin,
          effectiveHeight - 2 * autoMargin
        ) / 2
      );
    } else {
      rangeRadius = Math.min(this.width, this.height) / 2;
    }

    const rScale = d3.scaleLinear()
      .domain([rMin, rMax])
      .nice(Math.max(1, Math.round(rangeRadius / 60)))
      .range([0, rangeRadius]);
    const lineGenerator = d3.line()
      .x((d, i) => rScale(d) * Math.cos(angles[i]))
      .y((d, i) => rScale(d) * Math.sin(angles[i]));

    this.canvas.classed('radar-chart', true);

    const radarChart = this.firstDrawFlag ?
      this.canvas
        .append('g')
        .classed('container', true)
        .attr('transform', `translate(${(effectiveWidth)/2},${effectiveHeight/2})`) :
      this.canvas
        .selectAll('g.container')
        .attr('transform', `translate(${effectiveWidth/2},${effectiveHeight/2})`);

    /**
     * Draw the axis.
     */

    const suggestedTicks = Math.max(1, Math.round(rangeRadius / 60));
    const axisTicks = rScale.ticks(suggestedTicks).reverse();

    if (axisTicks[axisTicks.length-1] !== rScale.domain()[0]) {
      axisTicks.push(rScale.domain()[0]);
    }
    if (axisTicks[0] !== rScale.domain()[1]) {
      axisTicks.unshift(rScale.domain()[1]);
    }

    const axisLineGenerator = d3.line()
      .x((d, i) => d * Math.cos(angles[i]))
      .y((d, i) => d * Math.sin(angles[i]));

    const axisGroup = this.firstDrawFlag ?
      radarChart
        .append('g')
        .classed('axis', true)
        .classed('axis-bottom', true) :
      radarChart.selectAll('g.axis-bottom');

    if(numberOfCommons > 0) {
      const axisGroupCirclesUpdate = axisGroup
        .selectAll('path')
        .data(axisTicks.map(d => this.data.common.map(() => d)));
      axisGroupCirclesUpdate
        .transition()
        .duration(this.animationSpeed)
        .attr('d', d => lineGenerator(d) + 'Z');

      axisGroupCirclesUpdate
        .enter()
        .append('path')
        .classed('domain', true)
        .attr('fill', 'none')
        .attr('d', d => lineGenerator(d) + 'Z');

      axisGroupCirclesUpdate.exit().remove();

      if (!this.y.hideLabel) {
        const circlesTicksUpdate = axisGroup
          .selectAll('text.tick')
          .data(axisTicks)
          .attr('x', 0);
        circlesTicksUpdate
          .transition()
          .duration(this.animationSpeed)
          .attr('y', d => -rScale(d))
          .text(d => d);

        circlesTicksUpdate
          .enter()
          .append('text')
          .classed('tick', true)
          .attr('x', 0)
          .attr('y', d => -rScale(d))
          .attr('dominant-baseline', 'hanging')
          .text(d => d);

        circlesTicksUpdate.exit().remove();
      }

      // Update existing axis.
      if(!this.firstDrawFlag) {
        axisGroup
          .selectAll('line.line')
          .data(this.data.common)
          .transition()
          .duration(this.animationSpeed)
          .attr('x1', (_, i) => rangeRadius * Math.cos(angles[i]))
          .attr('y1', (_, i) => rangeRadius * Math.sin(angles[i]));

        if (!this.x.hideLabel) {
          axisGroup.selectAll('text.label')
            .data(this.data.common)
            .attr('opacity', () => isBreakpointDraw ? 0 : 1)
            .transition()
            .duration(this.animationSpeed)
            .attr('x', (_, i) => (rangeRadius + this.outerLabelMargin) * Math.cos(angles[i]))
            .attr('y', (_, i) => (rangeRadius + this.outerLabelMargin) * Math.sin(angles[i]));
        }
      }

      // Add new axis components.
      if(this.firstDrawFlag) {
        const axisTicksEnter = axisGroup
          .selectAll('g.tick')
          .data(this.data.common)
          .enter()
          .append('g')
          .classed('tick', true);

        axisTicksEnter
          .append('line')
          .classed('line', true)
          .attr('x0', '0')
          .attr('y0', '0')
          .attr('x1', (_, i) => rangeRadius * Math.cos(angles[i]))
          .attr('y1', (_, i) => rangeRadius * Math.sin(angles[i]));

        if (!this.x.hideLabel) {
          axisTicksEnter
            .append('text')
            .classed('label', true)
            .attr('opacity', () => isBreakpointDraw ? 0 : 1)
            .attr('x', (_, i) => (rangeRadius + this.outerLabelMargin) * Math.cos(angles[i]))
            .attr('y', (_, i) => (rangeRadius + this.outerLabelMargin) * Math.sin(angles[i]))
            .attr('text-anchor', (_, i) => {
              if (i === 0) {
                return 'middle';
              } else if (angles.length % 2 === 0 && i === (angles.length / 2)) {
                return 'middle';
              } else {
                return (angles[i] > Math.PI / 2) ? 'end' : 'start';
              }
            })
            .attr('dominant-baseline', (_, i) =>
              (angles[i] > 0 && angles[i] < Math.PI) ? 'hanging' : 'baseline'
            )
            .text(d => d);
        }
      }
    }

    /**
     * Draw the data points.
     */

    const lineGroup = this.firstDrawFlag ?
      radarChart
        .append('g')
        .classed('line-group', true) :
      radarChart
        .selectAll('g.line-group');

    const pathsUpdate = lineGroup
      .selectAll('path.line')
      .data(this.data.series, d => d.name);

    const pathsEnter = pathsUpdate
      .enter()
      .append('path')
      .attr('class', d => 'line ' + this.colorScale.get()(d.name));

    pathsUpdate
      .exit()
      .remove();

    pathsUpdate
      .merge(pathsEnter)
      .transition()
      .duration(this.animationSpeed)
      .attr('d', d => lineGenerator(d.values) + 'Z');

    /**
     * Draw the value labels.
     */

    const valueGroupsContainer = this.firstDrawFlag ?
      radarChart
        .append('g')
        .classed('axis', true)
        .classed('axis-top', true) :
      radarChart.selectAll('g.axis-top');

    const valueGroupsUpdate = valueGroupsContainer
      .selectAll('g.values')
      .data(this.data.series, d => d.name);
    const valueGroupsEnter = valueGroupsUpdate
      .enter()
      .append('g')
      .classed('values', true)
      .attr('opacity', 0);
    valueGroupsUpdate
      .exit()
      .remove();

    const valueGroups = valueGroupsUpdate.merge(valueGroupsEnter);

    const valueTextUpdate = valueGroups
      .selectAll('text.value')
      .data(d => d.values);
    const valueText = valueTextUpdate
      .enter()
      .append('text')
      .classed('value', true)
      .merge(valueTextUpdate);
    valueTextUpdate
      .exit()
      .remove();

    const calculateTextValuePosition = (d, i, tw, th, direction) => {
      const labelUnitX = Math.cos(angles[i]);
      const labelUnitY = Math.sin(angles[i]);
      const labelPositionX = (rScale(d) + 5) * labelUnitX;
      const labelPositionY = (rScale(d) + 5) * labelUnitY;

      let textOffsetPositionX = labelPositionX;
      let textOffsetPositionY = labelPositionY;

      if (i === 0) {
        textOffsetPositionX += tw;
      } else if (angles.length % 2 === 0 && i === (angles.length / 2)) {
        textOffsetPositionX += tw;
      } else {
        textOffsetPositionX += ((angles[i] > Math.PI / 2) ? -tw : +tw);
      }

      if (angles[i] > 0 && angles[i] < Math.PI) {
        textOffsetPositionY += th;
      } else {
        textOffsetPositionY -= th;
      }

      let angle;
      if (textOffsetPositionX >= 0) {
        angle = Math.atan(textOffsetPositionY / textOffsetPositionX);
      } else {
        angle = Math.atan(textOffsetPositionY / textOffsetPositionX) + Math.PI;
      }
      angle += Math.PI / 2;

      const tooltipDeltaAngle = Math.PI * 2 / numberOfCommons;
      const iCommon1 = Math.floor(angle / tooltipDeltaAngle) % numberOfCommons;
      const iCommon2 = (iCommon1 + 1) % numberOfCommons;

      const outerCircleX1 = rangeRadius * Math.cos(angles[iCommon1]);
      const outerCircleX2 = rangeRadius * Math.cos(angles[iCommon2]);
      const outerCircleY1 = rangeRadius * Math.sin(angles[iCommon1]);
      const outerCircleY2 = rangeRadius * Math.sin(angles[iCommon2]);

      const lineVectorX = outerCircleX2 - outerCircleX1;
      const lineVectorY = outerCircleY2 - outerCircleY1;

      const deltaVectorX = textOffsetPositionX - outerCircleX1;
      const deltaVectorY = textOffsetPositionY - outerCircleY1;

      const crossProduct = lineVectorX * deltaVectorY - lineVectorY * deltaVectorX;

      const projectionFactor =
        (
          lineVectorY * (textOffsetPositionX - outerCircleX1) -
          lineVectorX * (textOffsetPositionY - outerCircleY1)
        ) / (
          labelUnitX * lineVectorY -
          labelUnitY * lineVectorX
        );

      if (crossProduct < 0) {
        if (direction === 'x') {
          return labelPositionX - projectionFactor * labelUnitX;
        } else {
          return labelPositionY - projectionFactor * labelUnitY;
        }
      } else {
        if (direction === 'x') {
          return labelPositionX;
        } else {
          return labelPositionY;
        }
      }
    };

    valueText
      .text(d => d)
      .attr('text-anchor', function (d, i) {
        if (i === 0) {
          return 'middle';
        } else if (angles.length % 2 === 0 && i === (angles.length / 2)) {
          return 'middle';
        } else {
          return (angles[i] > Math.PI / 2) ? 'end' : 'start';
        }
      })
      .attr('dominant-baseline', function (d, i) {
        if (angles[i] > 0 && angles[i] < Math.PI) {
          return 'hanging';
        } else {
          return 'baseline';
        }
      })
      .attr('x', function (d, i) {
        const { width, height } = this.getBBox();
        return calculateTextValuePosition(d, i, width, height, 'x');
      })
      .attr('y', function (d, i) {
        const { width, height } = this.getBBox();
        return calculateTextValuePosition(d, i, width, height, 'y');
      });

    /**
     * Draw the tooltip points.
     */

    const groupCircles = this.firstDrawFlag ?
      radarChart
        .append('g')
        .classed('circles', true) :
      radarChart.selectAll('g.circles');

    const groupCirclesUpdate = groupCircles.selectAll('circle')
      .data(this.data.series, d => d.name);

    groupCirclesUpdate
      .enter()
      .append('circle')
      .attr('r', 3)
      .attr('class', d => 'tooltip-circle ' + this.colorScale.get()(d.name))
      .attr('opacity', 0);

    groupCirclesUpdate
      .exit()
      .remove();

    /**
     * Handle mouse hover effects.
     */

    const handleMousemove = (iCommon) => {
      if (iCommon > -1) {
        radarChart.selectAll('circle.tooltip-circle')
          .attr('opacity', 1)
          .attr('cx', d => rScale(d.values[iCommon]) * Math.cos(angles[iCommon]))
          .attr('cy', d => rScale(d.values[iCommon]) * Math.sin(angles[iCommon]));
        radarChart.selectAll('text.label')
          .style('font-weight', (d, i) => (i === iCommon) ? 'bold' : null);
        radarChart.selectAll('text.tick')
          .style('opacity', '0');
        radarChart.selectAll('line.line')
          .classed('selected', (d, i) => (i === iCommon));
        _this.tooltipBox.update(iCommon, _this.data);
      }
    };
    const handleMouseleave = () => {
      radarChart.selectAll('circle.tooltip-circle').attr('opacity', 0);
      radarChart.selectAll('text.label').style('font-weight', null);
      radarChart.selectAll('text.tick').style('opacity', null);
      radarChart.selectAll('line.line').classed('selected', false);
    };

    const mouseArea = this.firstDrawFlag ?
      radarChart.append('path')
        .classed('mouse-area', true) :
      radarChart.selectAll('path.mouse-area');

    mouseArea
      .attr('d', axisLineGenerator(this.data.common.map(() => rangeRadius * 1)) + 'Z');

    const labelArea = radarChart.selectAll('text.label');

    mouseArea.on('touchmove mousemove', function () {
      const coord = d3.mouse(this);

      const x = coord[0];
      const y = coord[1];

      let angle;
      if (x >= 0) {
        angle = Math.atan(y / x);
      } else {
        angle = Math.atan(y / x) + Math.PI;
      }
      angle += Math.PI / 2;

      const tooltipDeltaAngle = Math.PI * 2 / numberOfCommons;
      const iCommon = Math.round(angle / tooltipDeltaAngle) % numberOfCommons;

      handleMousemove(iCommon);
    });
    mouseArea.on('touchend mouseleave', function () {
      handleMouseleave();
    });
    labelArea.on('touchmove mousemove', function (d, i) {
      handleMousemove(i);
    });
    labelArea.on('touchend mouseleave', function () {
      handleMouseleave();
    });

    this.firstDrawFlag = false;
  }

  /**
   * Highlight one common element in all series
   * @param {String} key - The key matching the common element
   */
  _highlight(key) {
    const lines = this.canvas.selectAll('.line-group .line');
    const ticks = this.canvas.selectAll('.axis-bottom text.tick');
    const values = this.canvas.selectAll('.axis-top .values');

    if (key) {
      lines
        .attr('opacity', d => d.name === key ? '0.6' : '.2')
        .classed('line-focus', d => d.name === key);
      ticks
        .attr('opacity', '0');
      values
        .attr('opacity', d => d.name === key ? '1' : '0');
    } else {
      lines
        .attr('opacity', '1')
        .classed('line-focus', false);
      ticks
        .attr('opacity', '1');
      values
        .attr('opacity', '0');
    }
  }

  /**
   * Destroy method
   */
  destroy() {
    this.stage.destroy();
  }

}
