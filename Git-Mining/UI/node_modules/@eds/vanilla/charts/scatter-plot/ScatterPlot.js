/**
 * @file Module to create Scatter Plot.
 * @requires d3
 * @requires Stage
 * @requires Axis
 * @requires Legend
 * @requires ColorScale
 * @requires TooltipDot
 */

import * as d3 from 'd3';
import { Stage } from '../common/Stage';
import { Axis } from '../common/Axis';
import { ColorScale } from '../common/ColorScale';
import { Legend } from '../common/Legend';
import { TooltipDot } from '../common/TooltipDot';
import { regressionLinear } from '../common/regression';

/**
 * Class representing an scatter plot.
 */
export class ScatterPlot {

  /**
   * Setup chart properties
   * @param {Object} props - The properties to initialize the stage
   * @param {Object} props.data - The data necessary to draw the chart
   * @param {HTMLElement} props.element - The DOM element to append the chart
   * @param {number} [props.height] - The height of the chart
   * @param {Object} [props.margin] - The top, right, bottom and left margins
   * @param {number} [props.margin.top] - The top margin
   * @param {number} [props.margin.right] - The right margin
   * @param {number} [props.margin.bottom] - The bottom margin
   * @param {number} [props.margin.left] - The left margin
   * @param {string} [props.x] - The X axis properties
   * @param {string} [props.x.unit] - The unit of the X axis
   * @param {string} [props.x.tickFormat] - Format used for X axis (see D3 formats)
   * @param {boolean} [props.x.startFromZero] - If X axis starts on zero
   * @param {boolean} [props.x.isLogarithmic] - If X axis is logarithmic
   * @param {string} [props.y] - The Y axis properties
   * @param {string} [props.y.unit] - The unit of the Y axis
   * @param {string} [props.y.tickFormat] - Format used for Y axis (see D3 formats)
   * @param {boolean} [props.y.startFromZero] - If Y axis starts on zero
   * @param {boolean} [props.y.isLogarithmic] - If Y axis is logarithmic
   * @param {Object} [props.trendline] - The trendline properties
   * @param {boolean} [props.trendline.show] - If trendline should be displayed
   * @param {string} [props.trendline.type] - The type of trendline (currently only 'linear')
   * @param {number} [props.diameter] - Dot diameter
   */
  constructor(props) {
    this.data = props.data;
    this.element = props.element;
    this.margin = {
      left: 32,
      right: 24,
      top: 24,
      bottom: 32,
      ...props.margin,
    };
    this.height = props.height || 250;
    this.trendline = { show: false, type: 'linear', ...props.trendline };
    this.x = { unit: '', tickFormat: '', startFromZero: false, isLogarithmic: false, ...props.x };
    this.y = { unit: '', tickFormat: '', startFromZero: false, isLogarithmic: false, ...props.y };

    this.axisPadding = 8;
    this.fontSize = 14;
    this.animationSpeed = 400;

    this.yScale = null;
    this.xScale = null;

    // Default dot size 14x14, same as icon in legend pill
    this.radius = (props.diameter || 14) / 2;
    this.radiusHover = Math.max(this.radius, 7);

    if (this.y.unit) {
      this.margin.top += this.fontSize + this.axisPadding;
    }

    if (this.x.unit) {
      this.margin.bottom += this.fontSize + this.axisPadding;
    }

    this.id = Date.now();

    this.values = [];
  }

  /**
   * Initialize the chart
   * @public
   */
  init() {
    this.stage = new Stage({
      element: this.element,
      margin: this.margin,
      height: this.height
    });
    this.stage.init();
    this.stage.onResize(this.draw.bind(this));

    this.canvas = this.stage.getCanvas();
    this.canvas.classed('scatter-plot', true);

    this.colorScale = new ColorScale({
      length: this.data.series.length
    });
    this.colorScale.init();

    this.legend = new Legend({
      element: this.element,
      data: this.data,
      draw: this.draw.bind(this),
      highlight: this._highlight.bind(this),
      margin: this.margin
    });
    this.legend.init();

    this._drawTooltip();

    this.draw();
  }

  /**
   * Draw the chart based on data
   * @public
   * @param {Object} data - The data necessary to draw the chart
   */
  draw(data) {
    this.data = data || this.data;
    this.data = this.legend.filter(this.data);

    this.values = this._getValues();
    this.width = this.stage.getCanvasWidth();

    this._createX();
    this._createY();

    this._drawCrosshair();

    if (this.trendline.show) {
      this._drawTrendlines();
    }

    // Dots should be above crosshair for proper display of tooltip
    this._drawDots();

  }

  /**
   * Create X axis
   * @private
   */
  _createX() {
    let xMin = d3.min(this.values, (d) => d.x);
    const xMax = d3.max(this.values, (d) => d.x);

    // Logarithmic scale can't start with 0
    if (this.x.startFromZero && !this.x.isLogarithmic) {
      xMin = xMin < 0 ? xMin : 0;
    }

    this.xScale = this.y.isLogarithmic ? d3.scaleLog() : d3.scaleLinear();
    this.xScale
      .domain([xMin, xMax])
      .range([0, this.width])
      .nice();

    this.xAxis = new Axis({
      position: 'bottom',
      canvas: this.canvas,
      x: this.xScale,
      width: this.width,
      height: this.height,
      margin: this.margin,
      fontSize: this.fontSize,
      axisPadding: this.axisPadding,
      tickFormat: (d) => d3.format(this.x.tickFormat)(d),
      unit: this.x.unit,
      hasDomain: true,
      hasGrid: true
    });
    this.xAxis.init();
  }


  /**
   * Create Y axis
   * @private
   */
  _createY() {
    let yMin = d3.min(this.values, (d) => d.y);
    const yMax = d3.max(this.values, (d) => d.y);

    // Logarithmic scale can't start with 0
    if (this.y.startFromZero && !this.y.isLogarithmic) {
      yMin = yMin < 0 ? yMin : 0;
    }

    this.yScale = this.y.isLogarithmic ? d3.scaleLog() : d3.scaleLinear();
    this.yScale
      .domain([yMin, yMax])
      .range([this.height, 0])
      .nice();

    this.yAxis = new Axis({
      position: 'left',
      canvas: this.canvas,
      y: this.yScale,
      width: this.width,
      height: this.height,
      margin: this.margin,
      fontSize: this.fontSize,
      axisPadding: this.axisPadding,
      ticks: this.height / 80,
      tickFormat: (d) => d3.format(this.y.tickFormat)(d),
      unit: this.y.unit,
      hasDomain: true,
      hasGrid: true
    });
    this.yAxis.init();
  }

  /**
   * Dot tooltip
   * @private
   */
  _drawTooltip() {
    this.tooltip = new TooltipDot({
      element: this.element,
      data: this.data,
      // List of keys by which we update the tooltip items
      items: ['series', 'x', 'y'],
      hoverClass: 'dot-hover'
    });
    this.tooltip.init();
  }

  /**
   * Returns merged array of values.
   * @private
   * @return {{name: string, x: number, y: number, series: string}[]} - Array of objects
   */
  _getValues() {
    let data = [];
    if (this.data.series) {
      data = [].concat(...this.data.series.map(ser => ser.values.map(val => ({...val, series: ser.name}))));
    }
    return data;
  }

  /**
   * Dots
   * @private
   */
  _drawDots() {
    const dotsContainer = this.canvas.select('.dots').empty() ?
      this.canvas.append('g').classed('dots', true) :
      this.canvas.select('.dots');

    const dotGroups = dotsContainer
      .selectAll('.dot-group')
      .data(this.values, (d) => d.name);

    // Enter new elements presented in new data
    const dotGroupsEnter = dotGroups
      .enter()
      .append('g')
      .attr('class', 'dot-group');

    dotGroupsEnter
      .append('circle')
      .style('pointer-events', 'none')
      .attr('class', d => 'dot ' + this.colorScale.get()(d.series))
      .attr('cx', d => this.xScale(d.x))
      .attr('cy', d => this.yScale(d.y))
      .attr('r',  0)
      .transition()
      .duration(this.animationSpeed)
      .attr('r', this.radius);

    dotGroupsEnter
      .append('circle')
      .attr('class', 'dot-hover')
      .attr('fill', 'blue')
      .attr('opacity', 0)
      .attr('cx', d => this.xScale(d.x))
      .attr('cy', d => this.yScale(d.y))
      .attr('r', this.radiusHover)
      .on('mouseover', (group, i, selection) => {
        const all = dotsContainer.selectAll('.dot');

        const newData = {
          title: group.name,
          series: {
            label: group.series,
            value: ''
          },
          x: {
            label: this.x.unit,
            value: group.x
          },
          y: {
            label: this.y.unit,
            value: group.y
          }
        };

        /**
         * | Dot name           |
         * | __________________ |
         * | () Series          |
         * | x label          1 |
         * | y label          2 |
         * |                    |
         *  --------------------
         */
        this.tooltip.update(newData);

        all.attr('opacity', '.2');
        this.canvas.selectAll('.trendline').attr('opacity', '.2');

        d3.select(d3.select(selection[i].parentNode).selectAll('.dot').nodes()[0]).attr('opacity', 1);

        // Show crosshair intersecting dot center, text is hidden
        this.crosshair.select('.crosshair-line-x')
          .attr('x1', this.xScale(group.x)).attr('y1', 0)
          .attr('x2', this.xScale(group.x)).attr('y2', this.height);

        this.crosshair.select('.crosshair-line-y')
          .attr('x1', 0).attr('y1', this.yScale(group.y))
          .attr('x2', this.width).attr('y2', this.yScale(group.y));

        this.crosshair.attr('opacity', 1);
        this.crosshair.select('.crosshair-text').attr('opacity', 0);
      })
      .on('mouseout', () => {
        const all = dotsContainer.selectAll('.dot');
        all.attr('opacity', '1');
        this.canvas.selectAll('.trendline').attr('opacity', '1');

        // Hide crosshair
        this.crosshair.attr('opacity', 0);
        this.crosshair.select('.crosshair-text').attr('opacity', 1);
      });

    // Update old elements presented in new data
    dotGroups
      .select('.dot')
      .transition()
      .duration(this.animationSpeed)
      .attr('cx', d => this.xScale(d.x))
      .attr('cy', d => this.yScale(d.y));

    dotGroups
      .select('.dot-hover')
      .transition()
      .duration(this.animationSpeed)
      .attr('cx', d => this.xScale(d.x))
      .attr('cy', d => this.yScale(d.y));

    // Exit old elements not presented in new data
    dotGroups.exit().remove();
  }

  /**
   * Trendlines
   * @private
   */
  _drawTrendlines() {
    if (!this.trendTooltip) {
      this.trendTooltip = new TooltipDot({
        element: this.element,
        data: this.data,
        // List of keys by which we update the tooltip items
        items: ['series', 'equation', 'r2'],
        hoverClass: 'trendline-hover'
      });
      this.trendTooltip.init();
    }

    // Create a clip path
    let clipPath = this.canvas.select('defs');

    if (clipPath.empty()) {
      clipPath = this.canvas.append('defs');
      clipPath.append('clipPath')
        .attr('id', this.id)
        .append('rect')
        .classed('clip-rectangle', true)
        .attr('y', -1);
    }

    clipPath
      .select('rect')
      .attr('width', this.width)
      .attr('height', this.height + 1);

    const xMin = d3.min(this.values, (val) => val.x);
    const xMax = d3.max(this.values, (val) => val.x);
    const trendData = [];

    this.data.series.forEach((series) => {
      const coeff = regressionLinear(series.values);
      if (coeff.length) {
        trendData.push({
          name: series.name,
          a: coeff[0],
          b: coeff[1],
          rSquared: coeff[2],
          coords: [xMin, coeff[0] * xMin + coeff[1], xMax, coeff[0] * xMax + coeff[1]]
        });
      }
    });

    const trendsContainer = this.canvas.select('.trendlines').empty() ?
      this.canvas.append('g')
        .classed('trendlines', true)
        .attr('clip-path', `url(#${this.id})`) :
      this.canvas.select('.trendlines');

    const trendGroups = trendsContainer
      .selectAll('.trendline-group')
      .data(trendData, d => d.name);

    const trendGroupsEnter = trendGroups
      .enter()
      .append('g')
      .classed('trendline-group', true);

    trendGroupsEnter
      .append('line')
      .attr('class', (d) => `trendline ${this.colorScale.get()(d.name)}`)
      .attr('x1', (d) => this.xScale(d.coords[0]))
      .attr('y1', (d) => this.yScale(d.coords[1]))
      .attr('x2', (d) => this.xScale(d.coords[2]))
      .attr('y2', (d) => this.yScale(d.coords[3]))
      .attr('stroke-width', 1);

    trendGroupsEnter
      .append('line')
      .attr('class', 'trendline-hover')
      .attr('x1', (d) => this.xScale(d.coords[0]))
      .attr('y1', (d) => this.yScale(d.coords[1]))
      .attr('x2', (d) => this.xScale(d.coords[2]))
      .attr('y2', (d) => this.yScale(d.coords[3]))
      .attr('stroke', 'blue')
      .attr('stroke-width', 8)
      .attr('opacity', 0)
      .on('mouseover', (d) => {
        // Linear regression equation: y = ax + b
        const newData = {
          title: 'Linear trend',
          series: {
            label: d.name,
            value: ''
          },
          equation: {
            label: `y = ${d['a'].toFixed(3)} x ${d['b'] >= 0 ? '+': '-'} ${Math.abs(d['b'].toFixed(3))}`,
            value: ''},
          r2: {label: 'R-squared', value: d['rSquared'].toFixed(3)}
        };

        this.trendTooltip.update(newData);

        // Highlight trend line and corresponding dots
        this.canvas.selectAll('.dot').each((dd, i, selection) => {
          d3.select(selection[i]).attr('opacity', dd.series === d.name ? '1' : '.2');
        });
        this.canvas.selectAll('.trendline').each((dd, i, selection) => {
          d3.select(selection[i]).attr('opacity', dd.name === d.name ? '1' : '.2');
        });

      })
      .on('mouseout', () => {
        this.canvas.selectAll('.dot').attr('opacity', '1');
        this.canvas.selectAll('.trendline').attr('opacity', '1');
      });

    trendGroups
      .select('.trendline')
      .attr('x1', (d) => this.xScale(d.coords[0]))
      .attr('y1', (d) => this.yScale(d.coords[1]))
      .attr('x2', (d) => this.xScale(d.coords[2]))
      .attr('y2', (d) => this.yScale(d.coords[3]));

    trendGroups
      .select('.trendline-hover')
      .attr('x1', (d) => this.xScale(d.coords[0]))
      .attr('y1', (d) => this.yScale(d.coords[1]))
      .attr('x2', (d) => this.xScale(d.coords[2]))
      .attr('y2', (d) => this.yScale(d.coords[3]));

    trendGroups.exit().remove();
  }


  /**
   * Crosshair
   * @private
   */
  _drawCrosshair() {
    this.crosshair = this.canvas.select('.crosshair');

    if (this.crosshair.empty()) {
      this.crosshair = this.canvas.append('g')
        .attr('class', 'crosshair');

      this.crosshair.append('line')
        .attr('class', 'crosshair-line-x');

      this.crosshair.append('line')
        .attr('class', 'crosshair-line-y');

      this.crosshair.append('text')
        .attr('class', 'crosshair-text');
    }

    // Mouse area should be above crosshair for proper mouseenter / mouseleave
    this.mouseArea = this.canvas.select('.mouse-area').empty() ?
      this.canvas.append('svg:rect').classed('mouse-area', true) :
      this.canvas.select('.mouse-area');

    this.mouseArea
      .attr('width', this.width)
      .attr('height', this.height)
      .attr('fill', 'blue')
      .attr('opacity', '0')
      .attr('pointer-events', 'all')
      .on('mouseenter', () => this.crosshair.attr('opacity', 1))
      .on('mouseleave', () => this.crosshair.attr('opacity', 0))
      .on('mousemove', this._onMousemove.bind(this));
  }

  /**
   * Handle mouse move over `.mouse-area`.
   * @private
   */
  _onMousemove() {
    const mouse = d3.mouse(this.mouseArea.node());
    const mouseX = this.xScale.invert(mouse[0]);
    const mouseY = this.yScale.invert(mouse[1]);

    this.crosshair.select('.crosshair-line-x')
      .attr('x1', mouse[0]).attr('y1', 0)
      .attr('x2', mouse[0]).attr('y2', this.height);

    this.crosshair.select('.crosshair-line-y')
      .attr('x1', 0).attr('y1', mouse[1])
      .attr('x2', this.width).attr('y2', mouse[1]);

    this.crosshair.select('.crosshair-text')
      .attr('x', mouse[0] + 3)
      .attr('y', mouse[1] - 4)
      .text(`${mouseX.toFixed(2)}, ${mouseY.toFixed(2)}`);
  }

  /**
   * Highlight one common element in all series
   * @private
   * @param {String} key - The key matching the common element
   */
  _highlight(key) {
    const dots = this.canvas.selectAll('.dot');
    const trendlines = this.canvas.selectAll('.trendline');

    if (key) {
      dots.attr('opacity', d => d.series === key ? '1' : '.2');
      trendlines.attr('opacity', d => d.name === key ? '1' : '.2');
    } else {
      dots.attr('opacity', '1');
      trendlines.attr('opacity', '1');
    }
  }

  /**
   * Destroy component
   * @public
   */
  destroy() {

  }
}
