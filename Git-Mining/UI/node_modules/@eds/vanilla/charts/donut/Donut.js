/**
 * @file Component to create Donut chart.
 */

import * as d3 from 'd3';

import { Stage } from '../common/Stage';
import { Legend } from '../common/Legend';
import { ColorScale } from '../common/ColorScale';

export class Donut {

  /**
   * Setup chart properties
   * @param {Object} props - The properties to initialize the stage
   * @param {Object} props.data - The data necessary to draw the chart
   * @param {HTMLElement} props.element - The DOM element to append the chart
   * @param {Object} [props.margin] - The top, right, bottom and left margins
   * @param {number} [props.margin.top] - The top margin
   * @param {number} [props.margin.right] - The right margin
   * @param {number} [props.margin.bottom] - The bottom margin
   * @param {number} [props.margin.left] - The left margin
   * @param {boolean} [props.showAbsoluteValue] - Show absolute values instead of percentages
   * @param {boolean} [props.showValue] - Show absolute value when no interaction
   * @param {boolean} [props.isStatic] - Show initial value and no interactions
   * @param {string} [props.unit] - The label unit
   */
  constructor(props) {
    // private properties
    this.firstDrawFlag = true;
    this.height = 150;
    this.width = 150;

    this.data = props.data;
    this.element = props.element;
    this.margin = {
      top: this.height,
      bottom: 0,
      right: 0,
      left: this.width,
      ...props.margin
    };
    this.showAbsoluteValue = props.showAbsoluteValue || false;
    this.showValue = props.showValue || false;
    this.isStatic = props.isStatic || false;
    this.unit = props.unit;
    this.format = props.format;
  }

  /**
   * Initialize the chart
   */
  init() {
    this.stage = new Stage({
      element: this.element,
      margin: this.margin,
      height: this.height,
      width: this.width,
    });
    this.stage.init();

    this.canvas = this.stage.getCanvas();

    this.colorScale = new ColorScale({
      length: this.data.series.length
    });
    this.colorScale.init();

    this.legend = new Legend({
      element: this.element,
      data: this.data,
      draw: this.draw.bind(this),
      highlight: this._highlight.bind(this),
      margin: this.margin
    });
    this.legend.init();

    this.getOuterRadius = arc => this.radius - this._determineArcSize(arc);
    this.getInnerRadius = arc => this.radius + this._determineArcSize(arc);

    this.draw();
  }

  /**
   * Draw the chart based on data
   * @param {Object} newData - The data necessary to draw the chart
   * @param {Object[]} newData.series
   * @param {string} newData.series.name
   * @param {number[]} newData.series.values
   */
  draw(newData) {
    this.width = this.stage.getCanvasWidth();
    this.canvas.classed('donut', true);

    // variables
    const size = 180;
    const halfSize = size / 2;

    // some margin needed:
    this.radius = halfSize;
    this.arcs = d3.arc()
      .outerRadius(this.getOuterRadius)
      .innerRadius(this.getInnerRadius);

    this.thinArcs = d3.arc()
      .outerRadius(this.radius + 10)
      .innerRadius(this.radius - 10);

    this.thickArcs = d3.arc()
      .outerRadius(this.radius + 4)
      .innerRadius(this.radius - 4);

    this.hoverArcs = d3.arc()
      .outerRadius(() => this.radius + 10)
      .innerRadius(() => 0);

    this.pie = d3
      .pie()
      .sort(null)
      .value(d => d.values[0]);

    if(newData !== undefined) {
      this.data = newData;
      this.data = this.legend.filter(this.data);
    }

    if (this.firstDrawFlag) {
      this.labelGroup = this.canvas.append('g').attr('class', 'labels');
      this.activeGroup = this.canvas.append('g').attr('class', 'active-arc');
      this.hoverGroup = this.canvas.append('g').attr('class', 'hover-arc');

      this.activeGroup
        .datum(this.data.series)
        .selectAll('path')
        .data(this.pie)
        .enter()
        .append('path')
        .attr('class', d => {
          const colorClass = this.colorScale.get()(d.data.name);
          d.data.colorID = colorClass.substring(colorClass.length, colorClass.length-1);
          return colorClass;
        })
        .attr('name', d => d.data.name)
        .attr('d', this.arcs)
        .each(function(d) {
          this._current = d;
        });

      this.hoverGroup
        .datum(this.data.series)
        .selectAll('path')
        .data(this.pie)
        .enter()
        .append('path')
        .attr('class', 'transparent')
        .attr('name', d => d.data.name)
        .attr('d', this.hoverArcs)
        .each(function(d) {
          this._current = d;
        });

      this._drawLabels({
        unit: this.unit,
        total: this._getTotal()
      }, false);

      this.firstDrawFlag = false;
    }

    this.activeGroup
      .datum(this.data.series)
      .selectAll('path')
      .data(this.pie)
      .enter()
      .append('path')
      .attr('class', d => `color-data-${d.data.colorID}`)
      .attr('name', d => d.data.name)
      .attr('d', this.arcs)
      .each(function(d) {
        this._current = d;
      });

    // remove data not being used
    this.activeGroup
      .datum(this.data.series)
      .selectAll('path')
      .data(this.pie)
      .exit()
      .remove();

    this.hoverGroup
      .datum(this.data.series)
      .selectAll('path')
      .data(this.pie)
      .exit()
      .remove();

    if (this.isStatic) {
      this._highlight(this.data.series[0].name);
    } else {
      this.hoverGroup.selectAll('*').remove();
      this.hoverGroup
        .datum(this.data.series)
        .selectAll('path')
        .data(this.pie)
        .enter()
        .append('path')
        .attr('class', 'transparent')
        .attr('name', d => d.data.name)
        .on('mouseenter', (d) => this._highlight(d.data.name))
        .on('mouseleave', () => this._highlight(undefined))
        .attr('d', this.hoverArcs)
        .each(function(d) {
          this._current = d;
        });
    }
  }

  /**
   * Draws the chart labels in the canvas
   * @param {*} props - General Donut class properties
   * @param {boolean} isShown - If true shows the text value
   */
  _drawLabels(props, isShown) {
    const labelGroup = this.canvas.select('.labels');
    const isEmpty = this.canvas.select('.labels').node().innerHTML === '';
    if(isEmpty) {
      // value
      labelGroup
        .append('text')
        .classed('value', true)
        .attr('transform', `translate(${0}, ${0})`)
        .text(isShown ? props.value : '');

      // unit
      labelGroup
        .append('text')
        .classed('unit', true)
        .attr('transform', `translate(${0}, ${28})`)
        .text(isShown ? props.unit : '');

      // label
      labelGroup
        .append('text')
        .classed('label', true)
        .attr('transform', `translate(${0}, ${this.height - 28})`)
        .text(isShown ? props.label : '');
    } else {
      // value
      labelGroup.select('.value')
        .text(isShown ? props.value : '');

      // unit
      labelGroup.select('.unit')
        .text(isShown ? props.unit : '');

      // label
      labelGroup.select('.label')
        .text(isShown ? props.label : '');
    }

    if (this.showValue) {
      // value
      labelGroup.select('.value')
        .text(isShown ? props.value : props.total);

      // unit
      labelGroup.select('.unit')
        .text(props.unit);

      // label
      labelGroup.select('.label')
        .text(isShown ? props.label : '');
    }
  }

  /**
   * Returns the percentage a value represents within it's whole
   * @param {number} value - Number to get it's percentage equivalent
   * @return {string}
   */
  _getPercentage(value) {
    let total = 0;
    this.data.series.forEach(item => {
      total += item.values[0];
    });
    return ((value/total)*100).toFixed(1);
  }

  /**
   * Returns the sum (total) value of all data series
   * @return {number}
   */
  _getTotal() {
    let total = 0;
    this.data.series.forEach(item => {
      total += item.values[0];
    });
    return this._format(total);
  }

  /**
   * Returns the correct arc size
   * @param {Object} arc - Arc object containing data
   * @return {number}
   */
  _determineArcSize(arc) {
    // active arcs and placeholders (spaces) should be expanded:
    if (arc.data.placeholder || arc.data.active) {
      return 10;
    }
    // if some arc is active, the others should be collapsed:
    return this.data.series.some(v => v.active) ? 3 : 10;
  }

  /**
   * Highlight one common element in all series
   * @param {string} key - The key matching the common element
   */
  _highlight(key) {
    if (this.isStatic) {
      key = this.data.series[0].name;
    }
    if (key) {
      this.activeGroup
        .selectAll('path')
        .attr('class', d => `color-data-${d.data.colorID}`)
        .transition()
        .duration(300)
        .attr('opacity', d => d.data.name === key ? 1 : .2)
        .attr('d', d => {
          if(d.data.name === key){
            const percentage = this._getPercentage(d.data.values[0]);
            this._drawLabels({
              value: this.showAbsoluteValue ? this._format(d.data.values[0]) : percentage,
              unit: this.showAbsoluteValue ? this.unit : '%',
              label: d.data.name
            }, true);
            return this.thinArcs(d);
          } else {
            return this.thickArcs(d);
          }
        });
    } else {
      this.activeGroup
        .selectAll('path')
        .attr('class', d => `color-data-${d.data.colorID}`)
        .transition()
        .duration(200)
        .attr('opacity', 1)
        .attr('d', d => {
          this._drawLabels({
            unit: this.unit,
            total: this._getTotal()
          }, false);
          return this.thinArcs(d);
        });
    }
  }

  /**
   * Format value
   * @private
   */
  _format(d) {
    return this.format ? d3.format(this.format)(d) : d;
  }

  /**
   * Destroy method
   */
  destroy() {
    this.stage.destroy();
  }

}
