import * as d3 from 'd3';
import { ColorScale } from './ColorScale';
import { Format } from './Format';

export class Tooltip {

  /**
   * Common tooltip component for charts
   * @param {Object} props - The properties to initialize the tooltip
   * @param {HTMLElement} props.element - The DOM element to append the tooltip
   * @param {Object} props.data - The data necessary to populate the legend
   * @param {string} props.hoverClass - The class of the element you hover to show the tooltip
   * @param {Object} [props.format] - Format necessary for representing data
   * @param {string} [props.format.time] - Time specific format (see D3 formats)
   * @param {string} [props.format.value] - Number specific format (see D3 formats)
   * @param {boolean} [props.isTime] - Specifies if the tooltip woll be
   * @param {boolean} [props.rawMode] - Specifies if the tooltip will insert raw strings.
   * @param {boolean} [props.showSummary] - Show the summary values
   * @param {Object} [props.unit] - Format necessary for representing data
   * @param {string} [props.unit.title] - Unit represented next to the title
   * @param {string} [props.unit.value] - Unit represented above all the values
   */
  constructor(props) {
    this.element = props.element;
    this.data = props.data;
    this.hoverClass = props.hoverClass;
    this.showSummary = props.showSummary;
    this.colorScale = new ColorScale({
      length: this.data.series.length,
    });
    this.colorScale.init();
    this.format = {
      title: null,
      value: ',',
      ...props.format
    };
    this.unit = {
      title: '',
      value: '',
      ...props.unit
    };
    this.rawMode = props.rawMode || false;
    this.isTime = props.isTime || false;

    if (props.colorScale) {
      this.colorScale = props.colorScale;
    } else {
      this.colorScale = (() => {
        const scale = new ColorScale({
          length: this.data.series.length
        });
        scale.init();

        return {
          get() {
            return name => 'icon icon-alarm-level6 ' + scale.get()(name);
          }
        };
      })();
    }
  }

  /**
   * Creates the tooltip and adds the mousemove behavior
   */
  init() {
    // Clear tooltip if already exists
    d3.select(this.element).selectAll('.chart-tooltip').remove();

    this.tooltip = d3
      .select(this.element)
      .append('div')
      .classed('chart-tooltip', true);

    this.content = this.tooltip
      .append('div')
      .classed('content', true);

    const title = this.content
      .append('div')
      .classed('title', true);

    title.append('span')
      .classed('unit-title', true);

    title.append('span')
      .classed('unit-value', true);

    const item = this.content
      .selectAll('.item')
      .data(this.data.series.map(d => d.name))
      .enter()
      .append('div')
      .classed('item', true);

    if (!this.rawMode) {
      item
        .append('i')
        .attr('class', d => this.colorScale.get()(d));
    }

    item
      .append('span')
      .classed('key', true);

    if (!this.rawMode) {
      item
        .append('span')
        .classed('value', true);

      if (this.showSummary && this.data.summary) {
        const summary = this.content
          .append('div')
          .classed('summary', true);

        const summaryItem = summary
          .selectAll('.summary-item')
          .data(this.data.summary.map(d => d.name))
          .enter()
          .append('div')
          .classed('summary-item', true);

        summaryItem
          .append('span')
          .classed('key', true)
          .text(d => d);

        summaryItem
          .append('span')
          .classed('value', true);
      }
    }

    const hoverClassIsString =
      typeof this.hoverClass === 'string' ||
      this.hoverClass instanceof String;
    const hoverClassIsArray = Array.isArray(this.hoverClass);

    let hoverClassAggregate;
    if (hoverClassIsString) {
      hoverClassAggregate = () => d3.event.target.classList.contains(this.hoverClass);
    } else if (hoverClassIsArray) {
      hoverClassAggregate = () => {
        for (let i = 0; i < this.hoverClass.length; i += 1) {
          if (d3.event.target.classList.contains(this.hoverClass[i])) {
            return true;
          }
        }
        return false;
      };
    }

    let element = d3.select(this.element).select('svg');
    if (element.empty()) {
      element = d3.select(this.element).select('.svg');
    }

    element
      .on('mousemove', () => {
        const mouseDistance = 16;
        this.tooltip
          .classed('visible', () => hoverClassAggregate())
          .style('top', () => {
            if (d3.event.clientY + this.tooltip.node().offsetHeight + mouseDistance > window.innerHeight) {
              return d3.event.clientY - this.tooltip.node().offsetHeight - mouseDistance / 2 + 'px';
            } else {
              return d3.event.clientY + 16 + 'px';
            }
          })
          .style('left', () => {
            if (d3.event.clientX + this.tooltip.node().offsetWidth + mouseDistance * 2 > window.innerWidth) {
              return d3.event.clientX - this.tooltip.node().offsetWidth - mouseDistance + 'px';
            } else {
              return d3.event.clientX + 16 + 'px';
            }
          });
      })
      .on('mouseleave', () => {
        this.tooltip
          .classed('visible', false);
      });
  }

  /**
   * Updates the data of the tooltip from a series.
   * @param {number} seriesIndex - The index of the series
   * @param {Object} newData - The updated data from the chart
   */
  update(seriesIndex, newData) {
    const title = this.content.select('.title');
    const unitTitle = title.select('.unit-title');
    const unitValue = title.select('.unit-value');

    unitValue.text(this.unit.value);

    if (this.isTime) {
      unitTitle.text(Format.formatTime(this.format.title)(newData.common[seriesIndex]));
    } else {
      const label = Format.formatNumber(this.format.value)(newData.common[seriesIndex]);
      if (isNaN(label)) {
        unitTitle.text(newData.common[seriesIndex]);
      } else {
        unitTitle.text(label + ' ' + this.unit.title);
      }
    }

    let div;
    if (!this.rawMode) {
      const value = (d, data) => {
        const filteredSerie = data.filter(serie => serie.name === d)[0];
        if (filteredSerie) {
          return filteredSerie.values[seriesIndex];
        }
      };

      div = this.content
        .selectAll('.item')
        .classed('empty', d => newData.series.filter(serie => serie.name === d).length < 1);

      div
        .select('.value')
        .text(d => Format.formatNumber(this.format.value)(value(d, newData.series)));

      if (this.showSummary) {
        const summaryItem = this.content
          .selectAll('.summary-item')
          .classed('empty', d =>
            newData.summary.filter(serie => serie.name === d).length < 1
          );

        summaryItem
          .select('.value')
          .text(d => Format.formatNumber(this.format.value)(value(d, newData.summary)));
      }
    }

    if (this.rawMode === true) {
      const divUpdate = this.content
        .selectAll('.item')
        .data(newData.series.map(d => d.name))
        .classed('empty', false);
      const divEnter = divUpdate
        .enter()
        .append('span')
        .classed('item', true);
      divUpdate.exit().remove();
      div = divUpdate.merge(divEnter);

      div.selectAll('.key')
        .data(d => [d])
        .enter()
        .append('span')
        .classed('key', true);
    }

    div
      .select('.key')
      .text(d => d);
  }

  /**
   * Updates the data of the tooltip for only one data point.
   * @param {number} commonX - The x value of the series.
   * @param {number} commonY - The y value of the series
   * @param {value} - The value of the series.
   */
  updateSingle(commonX, commonY, value) {
    const title = this.content.select('.title');
    const unitTitle = title.select('.unit-title');
    const unitValue = title.select('.unit-value');

    unitValue.text(this.unit.value);

    if (this.isTime) {
      unitTitle.text(Format.formatTime(this.format.title)(commonX));
    } else {
      const label = Format.formatNumber(this.format.title)(commonX);
      if (isNaN(label) || typeof commonX === 'string') {
        unitTitle.text(commonX);
      } else {
        unitTitle.text(label + ' ' + this.unit.title);
      }
    }

    const div = this.content
      .selectAll('.item')
      .classed('empty', false);

    div
      .select('.key')
      .text(commonY);

    div
      .select('.value')
      .text(() => Format.formatNumber(this.format.value)(value));
  }
}
