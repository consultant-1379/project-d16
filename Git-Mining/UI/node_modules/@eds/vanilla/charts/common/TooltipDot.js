import * as d3 from 'd3';
import { ColorScale } from './ColorScale';

export class TooltipDot {

  /**
   * Common tooltip component for charts
   * @param {Object} props - The properties to initialize the tooltip
   * @param {HTMLElement} props.element - The DOM element to append the tooltip
   * @param {Object} props.data - The data necessary to populate the legend
   * @param {string} props.hoverClass - The class of the element you hover to show the tooltip
   * @param {array} props.items - List of items that are displayed below title
   */
  constructor(props) {
    this.element = props.element;
    this.data = props.data;
    this.hoverClass = props.hoverClass;
    this.items = props.items || [];

    this.seriesList = this.data.series.map(s => s.name);
    this.colorScale = new ColorScale({
      length: this.seriesList.length
    });
    this.colorScale.init();
  }

  /**
   * Creates the tooltip and adds the mousemove behavior
   */
  init() {
    this.tooltip = d3
      .select(this.element)
      .append('div')
      .classed('chart-tooltip', true);

    this.content = this.tooltip
      .append('div')
      .classed('content', true);

    const title = this.content
      .append('div')
      .classed('title', true);

    title.append('span')
      .classed('unit-title', true);

    const item = this.content
      .selectAll('.item')
      .data(this.items)
      .enter()
      .append('div')
      .classed('item', true)
      .attr('data-item', (d) => d);

    item
      .filter((d) => d === 'series')
      .append('i');

    item
      .append('span')
      .classed('key', true);

    item
      .append('span')
      .classed('value', true);

    d3.select(this.element)
      .select('svg')

      /*
       * Use optional name to allow multiple callbacks to be registered
       * https://github.com/d3/d3-selection/blob/master/README.md#handling-events
       */
      .on(`mousemove.${this.hoverClass}`, () => {
        const mouseDistance = 16;
        this.tooltip
          .classed('visible', d3.event.target.classList.contains(this.hoverClass))
          .style('top', () => {
            if (d3.event.clientY + this.tooltip.node().offsetHeight + mouseDistance > window.innerHeight) {
              return d3.event.clientY - this.tooltip.node().offsetHeight - mouseDistance / 2 + 'px';
            } else {
              return d3.event.clientY + 16 + 'px';
            }
          })
          .style('left', () => {
            if (d3.event.clientX + this.tooltip.node().offsetWidth + mouseDistance * 2 > window.innerWidth) {
              return d3.event.clientX - this.tooltip.node().offsetWidth - mouseDistance + 'px';
            } else {
              return d3.event.clientX + 16 + 'px';
            }
          });
      })
      .on('mouseleave', () => {
        this.tooltip
          .classed('visible', false);
      });
  }

  /**
   * Updates the data of the tooltip
   * @param {Object} data - The updated data from the chart
   */
  update(data) {
    const title = this.content.select('.title');
    const unitTitle = title.select('.unit-title');

    unitTitle.text(data.title);

    const div = this.content
      .selectAll('.item');

    if (data.series) {
      const sIndex = this.seriesList.indexOf(data.series.label);
      div
        .select('i')
        .attr('class', `icon icon-alarm-level6 ${this.colorScale.getColors()[sIndex]}`);
    }

    div
      .select('.key')
      .text((d) => data[d].label);

    div
      .select('.value')
      .text((d) => data[d].value);
  }
}
