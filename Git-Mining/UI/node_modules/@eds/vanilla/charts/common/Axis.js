import * as d3 from 'd3';

export class Axis {

  /**
   * Create common axis component for chart
   * @param {props} props - The properties for the axis component
   * @param {string} props.position - The predefined position for the axis: top, right, bottom or left
   * @param {Object} props.canvas - The DOM element to append the axis
   * @param {Object} [props.x] - The D3 x axis object
   * @param {Object} [props.y] - The D3 y axis object
   * @param {number} props.width - The width of the canvas
   * @param {number} props.height - The height of the canvas
   * @param {Object} [props.margin] - The top, right, bottom and left margins
   * @param {number} [props.margin.top] - The top margin
   * @param {number} [props.margin.right] - The right margin
   * @param {number} [props.margin.bottom] - The bottom margin
   * @param {number} [props.margin.left] - The left margin
   * @param {number} props.fontSize - The font size of the text elements in the axis
   * @param {number} props.axisPadding - The padding between the axis and the text elements
   * @param {number} [props.animationSpeed] - The speed of the animation if data changes
   * @param {Object[]} [props.thresholds] - Thresholds that can be added to a graph
   * @param {number} [props.thresholds[].moreThan] - Sets the positive threshold
   * @param {number} [props.thresholds[].lessThan] - Sets the negative threshold
   * @param {string} [props.thresholds[].color] - Threshold color (green, yellow, orange, red)
   * @param {boolean} [props.hasDomain] - Boolean determining the axis style to include domain or not
   * @param {boolean} [props.hasGrid] - Boolean determining to include grid or not (makes sense if hasDomain is true)
   * @param {number} [props.ticks] - The approximate number of ticks
   * @param {number} [props.tickFormat] - The number format for the ticks value (see D3 tickFormat)
   * @param {string} [props.unit] - The unit of the axis
   */
  constructor(props) {
    this.position = props.position;
    this.canvas = props.canvas;
    this.x = props.x;
    this.y = props.y;
    this.width = props.width;
    this.height = props.height;
    this.margin = props.margin;
    this.fontSize = props.fontSize;
    this.axisPadding = props.axisPadding;
    this.animationSpeed = props.animationSpeed || 400;
    this.thresholds = props.thresholds;
    this.hasDomain = props.hasDomain;
    this.hasGrid = props.hasGrid;
    this.ticks = props.ticks || this.width / 120;
    this.tickFormat = props.tickFormat;
    this.unit = props.unit || '';
  }

  /**
   * Initialize the axis
   */
  init() {
    if (this.x && !isNaN(this.x(0)) || this.y && !isNaN(this.y(0))) {
      this.draw();

      if (this.thresholds) {
        this.drawThreshold();
      }
    } else if (this.x || this.y) {
      this.draw();
    }
  }

  /**
   * Draw an axis based on the properties defined
   * @param {Object} scale - The transform of the axis.
   */
  draw() {
    let axisConfig;
    let gridConfig;

    const selectAxis = this.canvas.select(`.${this.position}.axis`);
    if (selectAxis.empty()) {
      this.axis = this.canvas.append('g');
      this.unit = this.axis
        .append('text')
        .classed('unit', true)
        .text(this.unit);
    } else {
      this.axis = selectAxis;
      this.unit = this.axis.select('.unit');
    }

    const selectGrid = this.canvas.select(`.${this.position}.grid`);
    if (selectGrid.empty()) {
      this.grid = this.canvas.append('g')
        .classed(this.position, true)
        .classed('grid', true);
    } else {
      this.grid = selectGrid;
    }

    switch (this.position) {
      case 'bottom': {
        axisConfig = d3
          .axisBottom(this.x)
          .tickSize(this.hasDomain ? this.axisPadding : this.height + this.axisPadding)
          .tickPadding(this.axisPadding)
          .ticks(this.ticks);

        if (this.hasDomain) {
          this.axis.attr('transform', `translate(0,${this.height})`);
        }

        if (this.hasGrid) {
          gridConfig = d3
            .axisBottom(this.x)
            .tickSize(this.height)
            .tickFormat('')
            .ticks(this.ticks);
        }

        if (this.margin) {
          this.unit
            .attr('text-anchor', 'end')
            .attr('x', this.width)
            .attr('y', (this.hasDomain ? 0 : this.height) + this.fontSize * 2 + this.axisPadding * 2);
        }
        break;
      }
      case 'left': {
        axisConfig = d3
          .axisLeft(this.y)
          .tickSize(this.hasDomain ? this.axisPadding : -this.width)
          .tickPadding(this.axisPadding)
          .ticks(this.ticks);

        if (this.hasGrid) {
          gridConfig = d3
            .axisLeft(this.y)
            .tickSize(-this.width)
            .tickFormat('')
            .ticks(this.ticks);
        }

        if (this.margin) {
          this.unit
            .attr('text-anchor', 'start')
            .attr('x', -this.margin.left)
            .attr('y', -this.fontSize - this.axisPadding);
        }
        break;
      }

    }

    if (this.tickFormat) {
      axisConfig.tickFormat(d => this.tickFormat(d));
    }

    this.axis
      .classed(this.position, true)
      .classed('axis', true)
      .transition()
      .duration(this.animationSpeed)
      .call(axisConfig);

    if (!this.hasDomain) {
      this.axis.selectAll('.domain').remove();
    }
    this.axis.selectAll('.tick').selectAll('line')
      .classed('solid', this.hasDomain)
      .classed('zero', d => d === 0);

    this.axis.selectAll('.tick').selectAll('text')
      .attr('font-size', this.fontSize);

    if (this.hasGrid) {
      this.grid
        .transition()
        .duration(this.animationSpeed)
        .call(gridConfig);
    }
  }

  /**
   * Draw a threshold axis based on the properties defined
   * Threshold will be drawn on the opposite of the axis defined, e.g,
   * if the axis is on the left the threshold will be on the right
   */
  drawThreshold() {
    const equalsThreshold = d => {
      let threshold;
      this.thresholds.forEach(t => {
        if (d === t.moreThan || d === t.lessThan) {
          threshold = t.color;
        }
      });
      return threshold;
    };

    this.axis
      .selectAll('.tick')
      .classed('marked-for-removal', d => !!equalsThreshold(d));

    this.axis
      .selectAll('.tick.marked-for-removal')
      .remove();


    let axisConfig;

    const thresholdTicks = this.thresholds.map(threshold => threshold.moreThan || threshold.lessThan);

    switch (this.position) {
      case 'bottom': {
        axisConfig = d3
          .axisTop(this.x)
          .tickPadding(this.axisPadding)
          .tickSize(-this.height - this.axisPadding)
          .tickValues(thresholdTicks);
        break;
      }
      case 'left': {
        axisConfig = d3
          .axisRight(this.y)
          .tickSize(this.width)
          .tickValues(thresholdTicks);
        break;
      }
    }

    if (this.tickFormat) {
      axisConfig.tickFormat(d => this.tickFormat(d));
    }

    const selectThresholdAxis = this.canvas.select('.axis.threshold');
    this.thresholdAxis = selectThresholdAxis.empty() ? this.canvas.append('g') : selectThresholdAxis;

    this.thresholdAxis
      .classed('axis', true)
      .classed('threshold', true)
      .transition()
      .duration(this.animationSpeed)
      .call(axisConfig);

    this.thresholdAxis.selectAll('.domain').remove();
    this.thresholdAxis.selectAll('.tick').selectAll('line')
      .attr('class', d => equalsThreshold(d))
      .classed('threshold', true);

    this.thresholdAxis.selectAll('.tick').selectAll('text')
      .attr('font-size', this.fontSize);
  }
}
