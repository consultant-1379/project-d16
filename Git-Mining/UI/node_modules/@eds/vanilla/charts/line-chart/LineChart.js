/**
 * @file Component to create line chart
 */

import * as d3 from 'd3';

import { Stage } from '../common/Stage';
import { Axis } from '../common/Axis';
import { Tooltip } from '../common/Tooltip';
import { Legend } from '../common/Legend';
import { ColorScale } from '../common/ColorScale';
import { Format } from '../common/Format';

export class LineChart {

  /**
   * Setup chart properties
   * @param {Object} props - The properties to initialize the stage
   * @param {Object} props.data - The data necessary to draw the chart
   * @param {HTMLElement} props.element - The DOM element to append the chart
   * @param {number} [props.height] - The height of the chart
   * @param {Object} [props.margin] - The top, right, bottom and left margins
   * @param {number} [props.margin.top] - The top margin
   * @param {number} [props.margin.right] - The right margin
   * @param {number} [props.margin.bottom] - The bottom margin
   * @param {number} [props.margin.left] - The left margin
   * @param {Object[]} [props.thresholds] - Thresholds that can be added to a chart
   * @param {number} [props.thresholds[].moreThan] - Sets the positive threshold
   * @param {number} [props.thresholds[].lessThan] - Sets the negative threshold
   * @param {string} [props.thresholds[].color] - Threshold color (green, red)
   * @param {Object} [props.y] - Y axis properties
   * @param {boolean} [props.y.startFromZero] - If Y axis starts on zero
   * @param {boolean} [props.y.isLogarithmic] - If Y axis is logarithmic
   * @param {string} [props.y.unit] - The Y axis unit
   * @param {string} [props.y.tickFormat] - The Y axis tick format
   * @param {Object} [props.x] - X axis properties
   * @param {boolean} [props.x.isTime] - If X axis is time-based
   * @param {string} [props.x.unit] - The X axis unit
   * @param {string} [props.x.tickFormat] - The X axis tick format
   * @param {Object} [props.format] - Format used for line chart data manipulation
   * @param {string} [props.format.input] - Format used to parse the data input
   * @param {Object} [props.tooltip] - Tooltip properties
   * @param {boolean} [props.tooltip.isHidden] - Hide the tooltip
   * @param {Object} [props.tooltip.format] - Format necessary for representing data
   * @param {string} [props.tooltip.format.title] - Time specific format (see D3 formats)
   * @param {string} [props.tooltip.format.value] - Number specific format (see D3 formats)
   * @param {boolean} [props.hasLiveData] - Enables sliding animation used  for live data only
   */

  constructor(props) {
    this.data = props.data;
    this.element = props.element;
    this.height = props.height || 250;
    this.margin = {
      top: 25,
      bottom: 35,
      right: 25,
      left: 35,
      ...props.margin,
    };

    this.thresholds = props.thresholds;
    this.y = {
      startFromZero: true,
      isLogarithmic: false,
      unit: '',
      ...props.y,
    };

    this.x = {
      isTime: true,
      unit: '',
      ...props.x,
    };

    this.format = {
      input: '%Y-%m-%d',
      ...props.format
    };

    this.tooltip = {
      format: {
        title: null,
        value: '.2f'
      },
      isHidden: false,
      ...props.tooltip,
    };

    this.hasLiveData = props.hasLiveData || false;

    // params
    this.axisPadding = 8;
    this.fontSize = 14;
    this.id = Date.now();
    this.firstDrawFlag = true;
    this.animationSpeed = 980;
    if (this.y.unit) {
      this.margin.top += this.fontSize + this.axisPadding;
    }
    if (this.x.unit) {
      this.margin.bottom += this.fontSize + this.axisPadding;
    }
  }

  /**
   * Initialize the chart
   */

  init() {
    this.stage = new Stage({
      element: this.element,
      margin: this.margin,
      height: this.height,
    });

    this.stage.init();
    this.stage.onResize(this.draw.bind(this));

    this.canvas = this.stage.getCanvas();

    this.colorScale = new ColorScale({
      length: this.data.series.length
    });

    this.colorScale.init();

    this.legend = new Legend({
      element: this.element,
      data: this.data,
      draw: this.draw.bind(this),
      highlight: this._highlight.bind(this),
      margin: {
        ...this.margin,
        left: 0
      }
    });
    this.legend.init();

    this.tooltipBox = new Tooltip({
      element: this.element,
      data: this.data,
      hoverClass: 'mouse-area',
      format: this.tooltip.format,
      isTime: this.x.isTime,
      unit: {
        value: this.y.unit,
        title: this.x.unit,
      }
    });

    this.tooltipBox.init();

    this._sortCommonData(this.data.common, this.x.isTime);
    this.draw();
  }

  /**
   * Destroy method
   */

  destroy() {
    this.stage.destroy();
  }

  /**
   * Draw the chart based on data
   * @param {Object[]} data - The data necessary to draw the chart
   */

  draw(data) {
    this.data = data || this.data;
    if (!this.hasLiveData) {
      this.data = this.legend.filter(this.data);
    }
    if (this.x.isTime) {
      this.data.common.forEach((date, i) => {
        if (!(date instanceof Date)) {
          const formatedDate = Format.formatTime(this.format.input)(new Date(date));
          this.data.common[i] = d3.timeParse(this.format.input)(formatedDate);
        }
      });
    }

    this.width = this.stage.getCanvasWidth();

    /**
     * X axis
     */

    let distanceBetween2Points = 0;

    // Time scale: default (time series)
    this.xScale = d3.scaleTime()
      .domain(d3.extent(this.data.common))
      .range([0, this.width]);

    // Linear scale: not time series

    if (!this.x.isTime) {
      this.xScale = d3.scaleLinear()
        .domain(d3.extent(this.data.common))
        .range([0, this.width]);
    }
    distanceBetween2Points = this.xScale(-this.data.common[1]) - this.xScale(-this.data.common[0]);

    if (!this.firstDrawFlag && this.hasLiveData) {
      this.xScale
        .domain(d3.extent(this.data.common))
        .range([0, this.width - distanceBetween2Points]);
    }

    let xTickFormat;
    if (this.x.isTime && this.x.tickFormat) {
      xTickFormat = d3.timeFormat(this.x.tickFormat);
    } else if (this.x.tickFormat) {
      xTickFormat = d3.format(this.x.tickFormat);
    }

    // Create new X axis
    const xAxis = new Axis({
      position: 'bottom',
      canvas: this.canvas,
      x: this.xScale,
      width: this.width,
      height: this.height,
      margin: this.margin,
      fontSize: 14,
      axisPadding: 8,
      hasDomain: true,
      unit: this.x.unit,
      tickFormat: xTickFormat,
      animationSpeed: this.animationSpeed
    });
    // Init X axis & append to Canvas
    xAxis.init();

    /**
     * Y axis
     */
    // Linear scale: default (linear, start from zero)
    let min = d3.min(this.data.series, d => d3.min(d.values));
    const max = d3.max(this.data.series, d => d3.max(d.values));

    if (this.y.startFromZero) {
      min = min < 0 ? min : 0;
    }

    this.yScale = d3.scaleLinear()
      .domain([min, max])
      .nice()
      .range([this.height, 0]);

    const tScale = d3.scaleLinear()
      .domain([min, max])
      .nice()
      .range([0, 100]);

    //  Logarithmic scale
    if (this.y.isLogarithmic) {
      min = d3.min(this.data.series, d => d3.min(d.values));
      this.yScale = d3.scaleLog()
        .domain([min, max])
        .nice()
        .range([this.height, 0]);
    }

    let yTickFormat;
    if (this.y.tickFormat) {
      yTickFormat = d3.format(this.y.tickFormat);
    }

    // Create new Y axis
    const yAxis = new Axis({
      position: 'left',
      canvas: this.canvas,
      y: this.yScale,
      width: this.width,
      height: this.height,
      margin: this.margin,
      fontSize: 14,
      axisPadding: 10,
      hasDomain: false,
      ticks: this.height / 60,
      thresholds: this.thresholds,
      tickFormat: yTickFormat,
      unit: this.y.unit
    });
    // Init Y axis & append to Canvas
    yAxis.init();

    /**
     * Value line (path)
     */
    // Default path: date information
    const valueline = d3.line()
      .defined(d => !isNaN(d))
      .x((d, i) => this.xScale(this.data.common[i]))
      .y(d => this.yScale(d));

    const onTransition = () => {
      this.xScale
        .domain(d3.extent(this.data.common))
        .range([0, this.width]);
      xAxis.draw();

      this.showTooltip(true);
    };

    // Append path to Canvas
    const lineChart = this.canvas.classed('line-chart', true);
    const lines = lineChart.select('.line-group').empty() ?
      lineChart.append('g')
        .classed('line-group', true)
        .attr('clip-path', `url(#${this.id})`)
        .selectAll('.line')
        .data(
          this.data.series,
          d => d.name
        ) :
      lineChart.select('.line-group')
        .selectAll('.line')
        .data(
          this.data.series,
          d => d.name
        );

    // Enter
    lines
      .enter()
      .append('path')
      .attr('d', d => valueline(d.values))
      .attr('class', d => 'line ' + this.colorScale.get()(d.name))
      .attr('name', d => d.name);

    if (this.data.series.length > 0) {
      // Update
      if (this.hasLiveData) {

        if (this.firstDrawFlag) {
          this.canvas.append('defs')
            .append('clipPath')
            .attr('id', this.id)
            .append('rect')
            .classed('clip-rectangle', true)
            .attr('y', -1)
            .attr('width', this.width)
            .attr('height', this.height + 1);
        } else {
          this.canvas.selectAll('.line')
            .attr('d', d => valueline(d.values))
            .attr('class', d => 'line ' + this.colorScale.get()(d.name))
            .attr('transform', null)
            .transition()
            .duration(this.animationSpeed)
            .on('start', onTransition)
            .attr('transform', `translate(${distanceBetween2Points})`);

          this.canvas.select('.clip-rectangle')
            .attr('width', this.width);
        }
      } else {
        this.canvas.selectAll('.line')
          .transition()
          .duration(this.animationSpeed)
          .on('start', onTransition)
          .attr('d', d => valueline(d.values))
          .attr('class', d => 'line ' + this.colorScale.get()(d.name));
      }

    }

    // Exit
    lines.exit().remove();

    // Threshold
    if (this.thresholds) {
      let minValue = 0;
      if (!this.y.startFromZero) {
        minValue = d3.min(this.data.series, d => d3.min(d.values));
      }
      const maxValue = d3.max(this.data.series, d => d3.max(d.values));
      const input = this.thresholds;
      const output = [];

      output.push({
        offset: tScale(minValue),
        color: 'line'
      });
      input.forEach(element => {
        output.push({
          offset: tScale(element.moreThan || element.lessThan),
          color: 'line'
        });
        output.push({
          offset: tScale(element.moreThan || element.lessThan),
          color: 'line'
        });
      });
      output.push({
        offset: tScale(maxValue),
        color: 'line'
      });

      output.sort((a, b) => a.offset - b.offset);
      output.forEach(element => {
        element.offset = element.offset + '%';
      });

      // LessThan
      const lessThanArray = input.filter((element) => {
        if (element.lessThan) {
          return element;
        }
      });
      if (lessThanArray.length > 0) {
        lessThanArray.sort((a, b) => a.lessThan - b.lessThan);
        let j = 0;
        for (let i = 0; i < lessThanArray.length; i += 1) {
          output[j].color = lessThanArray[i].color;
          output[j + 1].color = lessThanArray[i].color;
          j += 2;
        }
      }

      // MoreThan
      const moreThanArray = input.filter((element) => {
        if (element.moreThan) {
          return element;
        }
      });
      if (moreThanArray.length > 0) {
        moreThanArray.sort((a, b) => b.moreThan - a.moreThan);
        let j = output.length - 1;
        for (let i = 0; i < moreThanArray.length; i += 1) {
          output[j].color = moreThanArray[i].color;
          output[j - 1].color = moreThanArray[i].color;
          j -= 2;
        }
      }

      if (this.data.series.length > 0) {
        this.canvas.append('linearGradient')
          .classed('linear-gradient', true)
          .attr('id', `gradient-${this.element.id}`)
          .attr('gradientUnits', 'userSpaceOnUse')
          .attr('x1', 0).attr('y1', this.height)
          .attr('x2', 0).attr('y2', 0)
          .selectAll('stop')
          .data(output)
          .enter()
          .append('stop')
          .attr('offset', function (d) {
            return d.offset;
          })
          .attr('stop-color', function (d) {
            return d.color;
          });

        // Paint the lines with threshold colors
        const pathLines = this.element.querySelectorAll('path.line');
        Array.from(pathLines).forEach(line => {
          line.setAttribute('style', `stroke: url(#gradient-${this.element.id})`);
        });
      }
    }

    /**
     * Tooltip & hovering
     */

    if (!this.tooltip.isHidden) {
      // Append: tooltip line
      this.tooltipLine = this.canvas.select('.tooltip-line').empty() ?
        this.canvas.append('path').classed('tooltip-line', true) :
        this.canvas.select('.tooltip-line');

      // Append: tooltip circles
      const circlesContainer = this.canvas.select('.circles').empty() ?
        this.canvas.append('g').classed('circles', true) :
        this.canvas.select('.circles');

      const tooltipCirclesGroup = circlesContainer
        .selectAll('.tooltip-circle')
        .data(this.data.series, d => d.name);

      tooltipCirclesGroup
        .enter()
        .append('circle')
        .attr('r', 3)
        .attr('opacity', 0)
        .attr('class', d => `tooltip-circle ${this.colorScale.get()(d.name)}`);

      // Append the mouse interaction area
      const mouseArea = this.canvas.select('.mouse-area').empty() ?
        this.canvas.append('svg:rect').classed('mouse-area', true) :
        this.canvas.select('.mouse-area');

      mouseArea
        .attr('width', this.width)
        .attr('height', this.height)
        .attr('fill', 'blue')
        .attr('opacity', 0)
        .attr('pointer-events', 'all');

      const _this = this;
      const chartParentD3 = d3.select(`#${_this.element.id}`);
      this.chartTooltip = chartParentD3.select('.chart-tooltip');

      // Set even on mouse move
      mouseArea.on('touchmove mousemove', function() {
        _this.interruptTransition();
        _this.coord = d3.mouse(this);
        _this.showTooltip();
      });

      // Set even on mouse leave
      mouseArea.on('touchend mouseleave', function() {
        _this.coord = null;
        _this.hideTooltip();
      });

      tooltipCirclesGroup.exit().remove();
    }

    // end of draw
    this.firstDrawFlag = false;
  }

  showTooltip(isSmooth) {
    if (!this.coord) {
      return;
    }

    const _this = this;
    const xCommon = this.data.common.map(element => this.xScale(element));
    // const xValue = x.invert(coord[0]);
    const iCommon = d3.bisect(xCommon, this.coord[0]) - 1;
    const xDistance = xCommon[iCommon] || 0;
    // const yDistance = y(this.data.series[0].values[iCommon]);
    const transition = d3.transition().duration(this.animationSpeed);

    if (iCommon > -1) {
      this.canvas.selectAll('.tooltip-circle')
        .attr('opacity', d => this.data.series.filter(serie => serie.name === d.name).length < 1 ? 0 : 1)
        .each(function() {
          if (isSmooth) {
            d3.select(this)
              .transition(transition)
              .attr('cx', xDistance)
              .attr('cy', d => _this.yScale(d.values[iCommon]));
          } else {
            d3.select(this)
              .attr('cx', xDistance)
              .attr('cy', d => _this.yScale(d.values[iCommon]));
          }
        });

      // Position tooltip-line
      this.tooltipLine
        .attr('opacity', 1)
        .attr('d', `M0,${0}L0,${this.height}`)
        .each(function() {
          if (isSmooth) {
            d3.select(this)
              .transition(transition)
              .attr('transform', `translate(${xDistance},0)`);
          } else {
            d3.select(this).attr('transform', `translate(${xDistance},0)`);
          }
        });

      // Update tooltip (next to the mouse)
      this.tooltipBox.update(iCommon, this.data);
    }
    this.chartTooltip.style('opacity', this.data.series.length > 0 ? 1 : 0);
  }

  hideTooltip() {
    this.tooltipLine.attr('opacity', 0);
    this.canvas.selectAll('.tooltip-circle').attr('opacity', 0);
    this.chartTooltip.style('opacity', 0);
  }

  interruptTransition() {
    this.canvas.selectAll('.tooltip-circle').interrupt();
    this.tooltipLine.interrupt();
  }

  /**
   * Sorts the common data in increasing order (date or numerical)
   * @param {array} commonData - array of common continuous data
   * @param {boolean} isDate - specifies if the chart uses Date values
   * @private
   */

  _sortCommonData(commonData, isDate) {
    // Note: to perform the bisection correctly, the array must be ordered
    if (isDate) {
      commonData.sort((a, b) =>
        new Date(a) - new Date(b)
      );
    } else {
      commonData.sort((a, b) => a - b);
    }
  }

  /**
   * Highlight one common element in all series
   * @param {String} key - The key matching the common element
   * @private
   */

  _highlight(key) {
    const lines = this.canvas.selectAll('.line');
    if (key) {
      lines.attr('opacity', d => d.name === key ? '1' : '.2');
    } else {
      lines.attr('opacity', '1');
    }
  }
}
