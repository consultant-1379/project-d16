/**
 * @file Module to create Tile component.
 */

/**
 * Class representing a tile.
 */
export class Tile {

  /**
   * Setup properties.
   * @param {HTMLElement} element - The DOM element to append the component.
   */
  constructor(element) {
    this.dom = {
      tile: element,
      header: element.querySelector('.header'),
      actions: element.querySelectorAll('.header .action'),
      id: element.id,
    };

    this.events = {
      maximizeTile: new CustomEvent('maximizeTile', {
        detail: {
          id: this.dom.id,
          message: 'tile maximized',
        },
        bubbles: false,
        cancelable: true,
      }),
      minimizeTile: new CustomEvent('minimizeTile', {
        detail: {
          id: this.dom.id,
          message: 'tile minimize',
        },
        bubbles: true,
        cancelable: true,
      }),
    };

    this.listeners = {
      show: () => this.show(),
      toggleFullScreen: [],
    };
  }

  /**
   * Create component.
   * @public
   */
  init() {
    this._addEventListeners();
  }

  /**
   * Destroy component.
   * @public
   */
  destroy() {
    this._removeEventListeners();
  }

  /**
   * Add event listeners.
   * @private
   */
  _addEventListeners() {
    const actions = this.dom.actions;
    if (actions) {
      Array.from(actions).forEach((action, index) => {
        if (action.dataset.type === 'maximize') {
          const listener = () => this._toggleFullScreen(action);
          action.addEventListener('click', listener);
          this.listeners.toggleFullScreen[index] = listener;
        }
      });
    }

    this.dom.tile.addEventListener('minimizeTile', this.listeners.show);
  }

  /**
   * Remove event listeners.
   * @private
   */
  _removeEventListeners() {
    const actions = this.dom.actions;
    if (actions) {
      Array.from(actions).forEach((action, index) => {
        if (action.dataset.type === 'maximize') {
          action.removeEventListener('click', this.listeners.toggleFullScreen[index]);
        }
      });
      this.listeners.toggleFullScreen = [];
    }

    this.dom.tile.removeEventListener('minimizeTile', this.listeners.show);
  }

  /**
   * Toggle tile size (basic / fullscreen).
   * @private
   * @param {HTMLElement} action - Action element.
   */
  _toggleFullScreen(action) {
    if (this.dom.tile.classList.contains('fullscreen')) {
      this._minimize(action);
    } else {
      this._maximize(action);
    }
  }

  /**
   * Maximize tile.
   * @private
   * @param {HTMLElement} action - Action element.
   */
  _maximize(action) {
    this._setTooltipMessage(action, 'Minimize tile');
    this.dom.tile.classList.add('fullscreen');
    const icon = action.querySelector('.icon');
    icon.classList.add('icon-minimize');
    icon.classList.remove('icon-maximize');
    window.document.dispatchEvent(this.events.maximizeTile);
  }

  /**
   * Minimize tile.
   * @private
   * @param {HTMLElement} action - Action element.
   */
  _minimize(action) {
    this._setTooltipMessage(action, 'Maximize tile');
    this.dom.tile.classList.remove('fullscreen');
    const icon = action.querySelector('.icon');
    icon.classList.remove('icon-minimize');
    icon.classList.add('icon-maximize');
    window.document.dispatchEvent(this.events.minimizeTile);
  }

  /**
   * Update tooltip message.
   * @private
   * @param {HTMLElement} action - Action element.
   * @param {string} message - New text for tooltip.
   */
  _setTooltipMessage(action, message) {
    action.querySelector('.tooltip .message').innerText = message;
  }

  /**
   * Show tile.
   * @public
   */
  show() {
    this.dom.tile.classList.remove('hidden');
  }

  /**
   * Hide tile.
   * @public
   */
  hide() {
    this.dom.tile.classList.add('hidden');
  }

  /**
   * @deprecated
   * @param {CustomEvent} event
   */
  hideNotSelf(event) {
    if (event.detail.id !== this.dom.id) {
      this.dom.hide();
    }
  }
}
