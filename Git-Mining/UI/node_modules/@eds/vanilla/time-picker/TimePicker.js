/**
 * @file Module to create Time picker component.
 */

/**
 * Class representing a time picker.
 */
export class TimePicker {

  /**
   * Setup properties.
   * @param {HTMLElement} element - The DOM element to append the component.
   */
  constructor(element) {
    this.settings = {
      type: element.getAttribute('type') || 'combined',
      format: Number(element.getAttribute('format')) || 24,
      min: element.getAttribute('min'),
      max: element.getAttribute('max'),
      disable: element.getAttribute('disable') ? element.getAttribute('disable').split(', ') : false,
      step: Number(element.getAttribute('step')) || 5,
      classes: {
        inputType: 'input-type',
        separator: 'tp-col-sep',
        hhInput: 'tp-hh-input',
        mmInput: 'tp-mm-input',
        intervalSelect: 'tp-interval-select',
        singleSelect: 'tp-single-select',
        smartSelect: 'tp-smart-select',
        hoursSelect: 'tp-hours-select',
        minutesSelect: 'tp-minutes-select',
      }
    };

    this.dom = {
      element: element
    };

    this.value = '';
  }

  /**
   * Create component.
   * @public
   */
  init() {
    this.render();
    this.checkDisabledState();
    this.labelAction();
    this._addEventListeners();
  }

  render() {
    const o = this.settings;
    const c = o.classes;

    const colSep = this.createElement('span', c.separator);
    const hhInput = this.createElement('input', c.hhInput);
    const mmInput = this.createElement('input', c.mmInput);

    const intervalSelect = this.createElement('div', c.intervalSelect);

    // check and correct time format

    o.format = o.format !== 24 && o.format !== 12 ? 24 : o.format;

    // for input type

    colSep.textContent = ':';

    hhInput.type = 'text';
    hhInput.placeholder = 'HH';

    mmInput.type = 'text';
    mmInput.placeholder = 'MM';

    // input type AM-PM interval select

    intervalSelect.classList.add('tp-select', 'closed');

    intervalSelect.innerHTML = `
      <button type="button" class="btn tp-select-current">AM</button>
      <div class="tp-select-options" hlindex="-1">
        <div class="tp-select-option active">AM</div>
        <div class="tp-select-option">PM</div>
      </div>
    `;

    // build markup

    if (o.type === 'inputs') {
      this.dom.element.classList.add(c.inputType);
      this.dom.element.append(hhInput, colSep, mmInput);

      if (o.format === 12) {
        this.dom.element.appendChild(intervalSelect);
      }
    } else if (o.type === 'combined') {
      const singleSelect = this.createElement('div', c.singleSelect);

      singleSelect.classList.add('tp-select', 'time-format-' + o.format, 'closed');

      this.dom.element.classList.add(c.singleSelect);

      const timeList = [];

      if (o.format === 12) {
        o.min = !o.min ? '01AM' : o.min;
        o.max = !o.max ? '12PM' : o.max;

        singleSelect.innerHTML = `
          <button type="button" class="btn tp-select-current">HH:MM ` + this.getInterval(o.min) + `</button>
          <div class="tp-select-options" hlindex="-1"></div>
        `;

        timeList.push('<div class="tp-select-option">HH:MM ' + this.getInterval(o.min) + '</div>');

        if (this.getInterval(o.min) === this.getInterval(o.max)) {
          this.printTimeOptions(timeList, Number(o.min.slice(0, 2)),
            Number(o.max.slice(0, 2)), o.step, this.getInterval(o.min));

        } else {
          this.printTimeOptions(timeList, Number(o.min.slice(0, 2)), 12, o.step, this.getInterval(o.min));
          this.printTimeOptions(timeList, 1, Number(o.max.slice(0, 2)), o.step, this.getInterval(o.max));
        }
      } else {
        o.min = !o.min ? '00' : o.min;
        o.max = !o.max ? '23' : o.max;

        singleSelect.innerHTML = `
          <button type="button" class="btn tp-select-current">HH:MM</button>
          <div class="tp-select-options" hlindex="-1"></div>
        `;

        timeList.push('<div class="tp-select-option">HH:MM</div>');
        this.printTimeOptions(timeList, Number(o.min), Number(o.max), o.step);
      }

      singleSelect.querySelector('.tp-select-options').innerHTML = timeList.join('');
      this.dom.element.appendChild(singleSelect);

    } else if (o.type === 'separate') {

      // select for hours

      const hoursSelect = this.createElement('div', c.hoursSelect);
      const hoursList = [];

      hoursSelect.classList.add('tp-select', 'closed');

      hoursSelect.innerHTML = `
        <input class="tp-select-current ` + c.hhInput + `" placeholder="HH">
        <div class="tp-select-options" hlindex="-1"></div>
      `;

      if (o.format === 12) {
        o.min = !o.min ? 1 : o.min;
        o.max = !o.max ? 12 : o.max;
        o.max = o.max > 12 ? 12 : o.max;
      } else {
        o.min = !o.min ? 0 : o.min;
        o.max = !o.max ? 23 : o.max;
        o.max = o.max > 23 ? 23 : o.max;
      }

      for (let i = Number(o.min); i <= Number(o.max); i += 1) {
        hoursList.push('<div class="tp-select-option">' + this.leadingZeroFormat(i, 2) + '</div>');
      }

      hoursSelect.querySelector('.tp-select-options').innerHTML = hoursList.join('');

      this.settings.hoursList = hoursSelect.querySelectorAll('.tp-select-option');
      this.settings.hoursOldVal = '';

      // select for minutes

      const minutesSelect = this.createElement('div', c.minutesSelect);
      const minutesList = [];
      let minutes = 0;

      minutesSelect.classList.add('tp-select', 'closed');

      minutesSelect.innerHTML = `
        <input class="tp-select-current ` + c.mmInput + `" placeholder="MM">
        <div class="tp-select-options" hlindex="-1"></div>
      `;

      for (let i = 0; i < 60; i += o.step) {
        minutesList.push('<div class="tp-select-option">' + this.leadingZeroFormat(minutes, 2) + '</div>');
        minutes += o.step;
      }

      minutesSelect.querySelector('.tp-select-options').innerHTML = minutesList.join('');

      this.settings.minutesList = minutesSelect.querySelectorAll('.tp-select-option');
      this.settings.minutesOldVal = '';

      // collect elements together

      this.dom.element.append(hoursSelect, colSep, minutesSelect);

      if (o.format === 12) {
        this.dom.element.appendChild(intervalSelect);
      }
    } else {
      this.dom.element.classList.add('invalid-type');
      this.dom.element.innerText = 'Invalid type';
    }
  }


  checkDisabledState() {
    const inputs = this.dom.element.querySelectorAll('input');
    const buttons = this.dom.element.querySelectorAll('button');

    if (this.dom.element.hasAttribute('disabled')) {
      this.dom.element.classList.add('disabled');
      this.dom.element.removeAttribute('disabled');

      // prevent receiving a focus when the user uses the Tab key

      for (let i = 0; i < inputs.length; i += 1) {
        inputs[i].tabIndex = -1;
      }

      for (let i = 0; i < buttons.length; i += 1) {
        buttons[i].tabIndex = -1;
      }

    } else {
      this.dom.element.classList.remove('disabled');

      for (let i = 0; i < inputs.length; i += 1) {
        inputs[i].removeAttribute('tabIndex');
      }

      for (let i = 0; i < buttons.length; i += 1) {
        buttons[i].removeAttribute('tabIndex');
      }
    }
  }


  getInterval(number) {
    number = number.slice(2).toUpperCase();
    return number;
  }


  printTimeOptions(arr, min, max, step, tInt) {
    tInt = tInt ? ' ' + tInt : '';

    for (let i = min; i < max; i += 1) {
      let counter = 0;

      for (let z = 0; z < 60; z += step) {
        const timeItem = this.leadingZeroFormat(counter, 2);
        const timeString =  this.leadingZeroFormat(i, 2) + ':' + timeItem + tInt;
        const disabledValues = this.settings.disable;

        if (disabledValues){
          const disabledClass = disabledValues.find(val => val.indexOf(timeString) > -1) ? 'disabled' : '';

          arr.push('<div class="tp-select-option ' + disabledClass + '">' + timeString + '</div>');
        } else {
          arr.push('<div class="tp-select-option">' + timeString + '</div>');
        }

        counter += step;
      }
    }
  }

  /**
   * Add event listeners.
   * @private
   */
  _addEventListeners() {
    const selects = this.dom.element.querySelectorAll('.tp-select');

    for (const select of selects) {

      select.querySelector('.tp-select-current').addEventListener('click',
        event => this.toggleSelectOpt(event.target.parentElement));

      if (select.querySelector('.tp-select-current').tagName === 'INPUT') {
        select.querySelector('.tp-select-current').addEventListener('input', () => {

          if (!select.classList.contains('open')) {
            this.toggleSelectOpt(select);
          }

          this.filterOptions(select);
          this.setComponentValue();
        });
      }

      select.querySelector('.tp-select-options').addEventListener('click', (evt) => {
        const target = evt.target;
        if (target.classList.contains('tp-select-option') && !target.classList.contains('disabled')
          && !target.classList.contains('no-results')) {
          this.setSelectValue(select, target);
          this.setComponentValue();
        }
      });

      select.addEventListener('keydown', event => {
        if (event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === 'Enter') {
          event.preventDefault();
        }

        if (event.key === ' ') {
          event.preventDefault();
        }
      });

      select.addEventListener('keyup', event => this.arrowKeyActions(event, select));

      this.ifClickedOutside(() => this.hideSelectOpt(select), 'add', select);

    }

    switch (this.settings.type) {
      case 'inputs':
        this.dom.element.querySelector('.tp-hh-input').addEventListener('input', event => {
          event.target.value = this.validateInputValue(event.target);
          this.setComponentValue();
        });

        this.dom.element.querySelector('.tp-mm-input').addEventListener('input', event => {
          event.target.value = this.validateInputValue(event.target);
          this.setComponentValue();
        });
        break;
    }

    if (document.querySelector('.appcontent')) {
      document.querySelector('.appcontent').addEventListener('scroll', () => {
        const openSelects = this.dom.element.querySelectorAll('.tp-select.open');

        for (const select of openSelects) {
          this.optionsListPosition(select);
        }
      });
    }
  }

  /**
   * Remove event listeners.
   * @private
   */
  _removeEventListeners() {
    const selects = this.dom.element.querySelectorAll('.tp-select');

    for (const select of selects) {

      select.querySelector('.tp-select-current').removeEventListener('click',
        event => this.toggleSelectOpt(event.target.parentElement));

      if (select.querySelector('.tp-select-current').tagName === 'INPUT') {
        select.querySelector('.tp-select-current').removeEventListener('input', () => {

          if (!select.classList.contains('open')) {
            this.toggleSelectOpt(select);
          }

          this.filterOptions(select);
          this.setComponentValue();
        });
      }

      select.querySelector('.tp-select-options').removeEventListener('click', event => {
        if (!event.target.classList.contains('no-results')) {
          this.setSelectValue(select, event.target);
          this.setComponentValue();
        }
      });

      select.removeEventListener('keydown', event => {
        if (event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === 'Enter') {
          event.preventDefault();
        }

        if (event.key === ' ') {
          event.preventDefault();
        }
      });

      select.removeEventListener('keyup', event => this.arrowKeyActions(event, select));

      this.ifClickedOutside(() => this.hideSelectOpt(select), 'add', select);
    }

    switch (this.settings.type) {
      case 'inputs':
        this.dom.element.querySelector('.tp-hh-input').removeEventListener('keyup', () => {
          this.setComponentValue();
        });

        this.dom.element.querySelector('.tp-mm-input').removeEventListener('keyup', () => {
          this.setComponentValue();
        });
        break;
    }

    if (document.querySelector('.appcontent')) {
      document.querySelector('.appcontent').removeEventListener('scroll', () => {
        const openSelects = this.dom.element.querySelectorAll('.tp-select.open');

        for (const select of openSelects) {
          this.optionsListPosition(select);
        }
      });
    }
  }

  /**
   * Destroy component.
   * @public
   */
  destroy() {
    this._removeEventListeners();
  }


  toggleSelectOpt(select) {
    this.highlightRemove(select);
    select.classList.toggle('open');
    select.classList.toggle('closed');

    this.optionsListPosition(select);
  }


  optionsListPosition(select) {
    let bottomOffset = window.innerHeight - select.getBoundingClientRect().height;

    bottomOffset = bottomOffset - select.getBoundingClientRect().top;

    const listHeight = select.querySelector('.tp-select-options').offsetHeight + 4;

    if (bottomOffset < listHeight && select.classList.contains('open')) {
      select.classList.add('open-top');
    } else {
      select.classList.remove('open-top');
    }
  }


  hideSelectOpt(select) {
    this.highlightRemove(select);
    select.classList.remove('open');
    select.classList.add('closed');
  }


  labelAction() {
    const el = this.dom.element;
    const prevSib = el.previousElementSibling;

    if (prevSib && prevSib.tagName === 'LABEL') {
      if (prevSib.getAttribute('for') === el.id) {
        prevSib.addEventListener('click', () => {
          if (!this.dom.element.classList.contains('disabled')) {
            if (this.dom.element.firstChild.classList.contains('tp-select')) {
              this.dom.element.querySelector('.tp-select-current').focus();
            } else {
              this.dom.element.firstChild.focus();
            }
          }
        });
      }
    }
  }


  validateInputValue(input) {
    let value = input.value;
    const currInput = input.classList.contains('tp-mm-input') ? 'hoursOldVal' : 'minutesOldVal';

    if (/^[0-9]{1,2}?$/.test(value) || (value === '')) {
      this.settings[currInput] = value;
      return this.settings[currInput];
    } else {
      value = this.settings[currInput];
      return value;
    }
  }


  // add key controls

  arrowKeyActions(event, select) {

    const optionsLength = select.querySelectorAll('.tp-select-option').length - 1;
    const optionsList = select.querySelector('.tp-select-options');
    const highlightedOption = select.querySelector('.highlighted');
    const sClasses = select.classList;
    let highlightIndex = Number(optionsList.getAttribute('hlindex'));

    switch (event.key) {
      case 'Escape':
        this.hideSelectOpt(select);
        break;

      case 'ArrowDown':

        if (highlightIndex >= optionsLength) {
          highlightIndex = 0;
        } else {
          highlightIndex += 1;
        }

        optionsList.setAttribute('hlindex', highlightIndex);
        this.highlightOption(select, highlightIndex);
        break;

      case 'ArrowUp':

        if (highlightIndex <= 0) {
          highlightIndex = optionsLength;
        } else {
          highlightIndex -= 1;
        }

        optionsList.setAttribute('hlindex', highlightIndex);
        this.highlightOption(select, highlightIndex);
        break;

      case 'Enter':
        if (sClasses.contains('open')
          && !highlightedOption.classList.contains('no-results')
          && !highlightedOption.classList.contains('disabled')) {
          this.setSelectValue(select);
          this.setComponentValue();
        }

        break;

      case ' ':

        if (sClasses.contains('open') && highlightedOption && !highlightedOption.classList.contains('disabled')
          && !highlightedOption.classList.contains('no-results')) {
          this.setSelectValue(select);
          this.setComponentValue();
        } else if (!sClasses.contains('disabled')) {
          this.toggleSelectOpt(select);
        }
        break;
    }
  }


  highlightOption(select, hlindex) {
    const options = select.querySelectorAll('.tp-select-option');
    const optionsList = select.querySelector('.tp-select-options');

    for (const item of options) {
      item.classList.remove('highlighted');
    }

    options[hlindex].classList.add('highlighted');

    if (!this.isInViewport(options[hlindex], optionsList)) {
      optionsList.scrollTop = options[hlindex].offsetTop;
    }
  }


  highlightRemove(select) {
    const options = select.querySelectorAll('.tp-select-option');
    const optionsList = select.querySelector('.tp-select-options');

    for (const item of options) {
      item.classList.remove('highlighted');
    }

    optionsList.setAttribute('hlindex', -1);
  }


  setSelectValue(select, target) {
    const current = select.querySelector('.tp-select-current');
    const selected = select.querySelector('.highlighted') || target;
    const options = select.querySelectorAll('.tp-select-option');

    for (const item of options) {
      item.classList.remove('active');
    }

    this.hideSelectOpt(select);

    if (current.classList.contains('tp-hh-input') || current.classList.contains('tp-mm-input')) {
      if (selected) {
        current.value = selected.innerText;
      }
      this.filterOptions(select);
    } else {
      selected.classList.add('active');
      current.innerText = selected.innerText;
    }
  }


  setComponentValue() {
    switch (this.settings.type) {
      case 'inputs': {
        let hours = this.validateInputValue(this.dom.element.querySelector('.tp-hh-input')) || '--';
        let minutes = this.dom.element.querySelector('.tp-mm-input').value || '--';
        const interval = this.dom.element.querySelector('.tp-interval-select');

        hours = this.leadingZeroFormat(hours);
        minutes = this.leadingZeroFormat(minutes);

        if (interval) {
          this.value = hours + ':' + minutes + ' ' + interval.innerText;
        } else {
          this.value = hours + ':' + minutes;
        }
        break;
      }

      case 'combined':
        this.value = this.dom.element.querySelector('.tp-select-current').innerText;
        break;

      case 'separate': {
        let hours = this.dom.element.querySelector('.tp-hh-input').value || '--';
        let minutes = this.dom.element.querySelector('.tp-mm-input').value || '--';
        const interval = this.dom.element.querySelector('.tp-interval-select');

        hours = this.leadingZeroFormat(hours);
        minutes = this.leadingZeroFormat(minutes);

        if (interval) {
          this.value = hours + ':' + minutes + ' ' + interval.innerText;
        } else {
          this.value = hours + ':' + minutes;
        }
        break;
      }
    }
  }


  leadingZeroFormat(val, size) {
    let s = String(val);
    while (s.length < (size || 2)) { s = '0' + s; }
    return s;
  }

  /*
   *filterOptions(select){
   *const selectCurrent = select.querySelector('.tp-select-current');
   *const selectOptions =  select.querySelector('.tp-select-options');
   *let initialOptionsList = [];
   *
   *if (selectCurrent.classList.contains('tp-hh-input')){
   *  initialOptionsList =  Array.from(this.settings.hoursList);
   *} else if (selectCurrent.classList.contains('tp-mm-input')) {
   *  initialOptionsList =  Array.from(this.settings.minutesList);
   *}
   *
   *selectCurrent.value = this.validateInputValue(selectCurrent);
   *
   *const inputVal = selectCurrent.value.toLowerCase().trim();
   *const filteredOptions = initialOptionsList.filter(val => val.innerText.toLowerCase().indexOf(inputVal) > -1);
   *
   *selectOptions.setAttribute('hlindex', -1);
   *
   *if (filteredOptions.length){
   *  selectOptions.innerHTML = '';
   *
   *  for (let i = 0; i < filteredOptions.length; i += 1){
   *    if (inputVal !== filteredOptions[i].innerText.trim().toLowerCase()){
   *      filteredOptions[i].classList.remove('active', 'highlighted');
   *    } else {
   *      filteredOptions[i].classList.add('active');
   *    }
   *    selectOptions.appendChild(filteredOptions[i]);
   *  }
   *} else {
   *  selectOptions.innerHTML = '<div class="tp-select-option no-results">--</div>';
   *}
   *}
   */


  filterOptions(select) {
    const selectCurrent = select.querySelector('.tp-select-current');
    const selectOptions = select.querySelector('.tp-select-options');

    const initialOptionsList = Array.from(selectOptions.children);

    selectCurrent.value = this.validateInputValue(selectCurrent);

    const inputVal = selectCurrent.value.toLowerCase().trim();

    // reset option's classes

    [].forEach.call(initialOptionsList, function (option) {
      option.classList.remove('active', 'highlighted');
    });

    // reset scroll position

    selectOptions.setAttribute('hlindex', -1);
    selectOptions.scrollTop = 0;

    // look for matches
    let filteredOption = 0;

    if (inputVal.length > 0) {
      filteredOption = initialOptionsList.find(val => val.innerText.toLowerCase().indexOf(inputVal) > -1);
    }

    // highlight filtered option

    if (filteredOption !== 0 && filteredOption !== undefined) {
      selectOptions.setAttribute('hlindex', initialOptionsList.indexOf(filteredOption));
      filteredOption.classList.add('active', 'highlighted');
      filteredOption.parentNode.scrollTop = filteredOption.offsetTop;
    }
  }


  // check if an option is in viewport of list

  isInViewport(option, optionsList) {
    const elementTop = option.offsetTop;
    const elementBottom = elementTop + option.clientHeight;
    const viewportTop = optionsList.scrollTop;
    const viewportBottom = viewportTop + optionsList.offsetHeight - 4;

    return elementBottom > viewportTop && elementTop < viewportBottom;
  }


  createElement(type, obj) {
    const el = document.createElement(type);

    if (typeof obj === 'string') {
      el.classList.add(obj);
    } else if (obj === Object(obj)) {
      for (const prop in obj) {
        if (prop in el) {
          el[prop] = obj[prop];
        } else {
          el.setAttribute(el[prop], obj[prop]);
        }
      }
    }

    return el;
  }


  ifClickedOutside(callback, type, select) {
    if (type === 'remove') {
      document.removeEventListener('click', ({ target }) => {
        if (!select.contains(target)) {
          callback.bind(this)();
        }
      });
    } else {
      document.addEventListener('click', ({ target }) => {
        if (!select.contains(target)) {
          callback.bind(this)();
        }
      });
    }
  }
}
