/**
 * @file Module to create table component.
 */

import TableModel from './features/TableModel';
import TableInfo from './features/TableInfo';
import TableSelect from './features/TableSelect';
import TableSort from './features/TableSort';
import TableSettings from './features/TableSettings';

import { Pagination } from '../pagination/Pagination';

import { createFromMarkup, debounce } from './features/utils';
import { Dropdown } from '../dropdown/Dropdown';

/**
 * Class representing a dynamic table.
 */
export class Table {

  /**
   * Setup table properties.
   * @param {HTMLElement} element - The DOM element of the table.
   * @param {Object} options - Table options.
   */
  constructor(element, options) {
    this.dom = {
      table: element,
      tableTop: element.parentElement.querySelector('.table-top'),
      tableBottom: element.parentElement.querySelector('.table-bottom'),
      tableButtons: element.parentElement.querySelector('.table-buttons'),
      tablePagination: element.parentElement.querySelector('.pagination-group'),
      tableSettingsIcon: element.parentElement.querySelector('.table-top .table-settings'),
      bodyRows: []
    };
    this.listeners = {
      onToggleSelectRow: () => {

        /*
         * When select rows, info width can change and affect available width for table actions
         * Used _onResize() instead of CSS min-width because filters may go after table-info
         * Timeout in case buttons show/hide dynamically from outside
         */
        if (this.dom.tableButtons && this.dom.tableTop.querySelector('.table-info')) {
          setTimeout(() => this._onResize(), 100);
        }
      },
      onScroll: (evt) => this._fixTableHead(evt),
      onResize: () => this._onResize(),
      onResizeDebounce: debounce(this._onResize.bind(this), 500),
      onPageNumChange: () => {
        this.model.setDisplayedData();
        this.updateRows();

        this.dom.table.dispatchEvent(new CustomEvent('tableUpdate'));
      },
      onSelectNumChange: () => {
        this.dom.tablePagination.querySelector('input[type="number"]').value = '';
        this.model.setDisplayedData();
        this._renderBodyRows();

        this.dom.table.dispatchEvent(new CustomEvent('tableUpdate'));
      },
      onExpandClick: (evt) => {
        if (evt.target.closest('.expand')) {
          this._toggleDetailsRow(evt.target.closest('tr'));
        }
      },
      onRemoveRow: (evt) => {
        evt.detail.removeEventListener('mouseover', this.listeners.onRowMouseOver);
        evt.detail.removeEventListener('mouseout', this.listeners.onRowMouseOut);
      },
      onRowMouseOver: (evt) => {
        // if currentElem is set, we didn't leave the previous <tr>, ignore the event
        if (this.currentRow) return;

        // ignore if we moved not into a <tr>
        const target = evt.target.closest('tr');
        if (!target) return;

        // ignore if moved into <tr>, but outside of current table
        if (!this.dom.table.contains(target)) return;

        // entered a new <td>
        this.currentRow = target;
      },
      onRowMouseOut: (evt) => {
        // ignore if we're outside of any <tr>
        if (!this.currentRow) return;

        // we're leaving the element. go up the parent chain and check if we're still inside the current row
        let relatedTarget = evt.relatedTarget;
        while (relatedTarget) {
          if (relatedTarget === this.currentRow) return;
          relatedTarget = relatedTarget.parentNode;
        }

        // we left the <tr>. close dropdowns and reset current row
        this.currentRow.querySelectorAll('.dropdown.open').forEach((dd) => {
          dd.classList.remove('open');
          dd.querySelector('.menu').classList.remove('visible');
        });
        this.currentRow = null;
      }
    };

    this.pagination = null;
    this.settings = {
      columns: options.columns || [],
      scroll: options.scroll,
      height: options.height || false,
      selectable: options.selectable || false,
      sortable: options.sortable || false,
      expandable: options.expandable || false,
      actions: options.actions || false,

      // If pagination doesn't include 'show entries' select, use static value
      rowsPerPage: options.rowsPerPage || 5,
      emptyState: {message: 'No data found.', ...options.emptyState}
    };
    this.callbacks = {
      createdHeadCallback: options.onCreatedHead,
      createdBodyCallback: options.onCreatedBody,
      createdRowCallback: options.onCreatedRow,
      createdDetailsRowCallback: options.onCreatedDetailsRow,
      onCreatedActionsCell: options.onCreatedActionsCell,
    };
    this.events = {

    };
    this.features = {};

    // Data model
    this.model = new TableModel(this, options.data);

    // <tr> under the mouse right now (if any)
    this.currentRow = null;
  }

  /**
   * Initialize table.
   * @public
   */
  init() {
    this._enablePagination();
    this._render();
    this._enableStickyHead();
    this._addEventListeners();
  }

  /**
   * Destroy SignIn page and associated events.
   * @public
   */
  destroy() {
    this._removeEventListeners();

    // Destroy features and remove event listeners
    if (Object.keys(this.features).length) {
      for (const f in this.features) {
        this.features[f].destroy();
      }
    }
  }

  /**
   * Add event listeners.
   * @private
   */
  _addEventListeners() {
    this.dom.table.addEventListener('toggleSelectRow', this.listeners.onToggleSelectRow);

    if (this.dom.tableButtons) {
      window.addEventListener('resize', this.listeners.onResize);
      // Run resize callback after toggle animation has finished
      document.addEventListener('toggleNavigation', this.listeners.onResizeDebounce);
    }

    if (this.dom.tablePagination) {
      this.dom.tablePagination.addEventListener('paginationChangePage', this.listeners.onPageNumChange);
      this.dom.tablePagination.addEventListener('paginationChangeSelect', this.listeners.onSelectNumChange);
    }

    if (this.settings.expandable) {
      this.dom.table.addEventListener('click', this.listeners.onExpandClick);
    }

    this.dom.table.addEventListener('removeRow', this.listeners.onRemoveRow);
  }

  /**
   * Remove event listeners.
   * @private
   */
  _removeEventListeners() {
    this.dom.table.removeEventListener('toggleSelectRow', this.listeners.onToggleSelectRow);

    if (this.settings.height) {
      this.dom.table.parentElement.removeEventListener('scroll', this.listeners.onScroll);
    }

    if (this.dom.tableButtons) {
      window.removeEventListener('resize', this.listeners.onResize);
      document.removeEventListener('toggleNavigation', this.listeners.onResizeDebounce);
    }

    if (this.dom.tablePagination) {
      this.dom.tablePagination.removeEventListener('paginationChangePage', this.listeners.onPageNumChange);
      this.dom.tablePagination.removeEventListener('paginationChangeSelect', this.listeners.onSelectNumChange);
    }

    if (this.settings.expandable) {
      this.dom.table.removeEventListener('click', this.listeners.onExpandClick);
    }
  }

  /**
   * @type {Array}
   */
  get selected() {
    return this.model.data.filter((item) => item.selected);
  }

  /**
   * @type {Array}
   */
  get selectedOnPage() {
    return this.model.displayedData.filter((item) => item.selected);
  }

  /**
   * @type {Array}
   */
  get data() {
    return this.model.data;
  }

  /**
   * @type {Array}
   */
  get displayedData() {
    return this.model.displayedData;
  }

  /**
   * Render table.
   * @private
   */
  _render() {
    this._renderScrollWrapper();
    this._renderHead();
    this._renderBody();
    this._addFeatures();
    this._toggleFreeze();

    this._createActionsDropdown();
  }

  /**
   * Render wrapper for horizontal scroll.
   * @private
   */
  _renderScrollWrapper() {
    if (this.settings.scroll || this.settings.height) {
      const wrapper = document.createElement('div');
      wrapper.classList.add('table-scroll');
      this.dom.table.parentNode.insertBefore(wrapper, this.dom.table);
      wrapper.appendChild(this.dom.table);
    }
  }

  /**
   * Render <thead>.
   * @private
   */
  _renderHead() {
    const thead = document.createElement('thead');
    const tr = document.createElement('tr');
    thead.append(tr);

    if (this.settings.expandable) {
      this.dom.table.classList.add('expandable');
      const th = document.createElement('th');
      th.classList.add('cell-expand');
      tr.append(th);
    }

    this.settings.columns.forEach((column) => {
      const th = document.createElement('th');

      if (column.key) {
        th.dataset.key = column.key;
      }

      if (column.headerClass) {
        th.classList.add(column.headerClass);
      }

      if (column.headerStyle) {
        th.style = column.headerStyle;
      }

      if (column.width) {
        th.style.width = column.width;
      }

      if (column.hidden) {
        th.classList.add('hidden');
      }

      if (column.freeze) {
        th.classList.add('freeze');
        th.style.left = '';
      }

      if (column.title && column.tooltip) {
        th.append(this._renderTooltip(column.title, column.tooltip));
      } else {
        th.innerHTML = column.title || '';
      }

      tr.append(th);
    });

    if (this.settings.actions) {
      const th = document.createElement('th');
      th.classList.add('cell-actions');

      tr.append(th);
    }

    this.dom.table.append(thead);
    this.dom.thead = this.dom.table.querySelector('thead');

    if (this.callbacks.createdHeadCallback) {
      this.callbacks.createdHeadCallback(thead, this.settings.columns);
    }
  }

  /**
   * Render <tbody>.
   * @private
   */
  _renderBody() {
    this.dom.tbody = document.createElement('tbody');
    this.dom.table.append(this.dom.tbody);

    this._renderBodyRows();
  }

  /**
   * Render <tr>s.
   * @private
   */
  _renderBodyRows() {
    // Remove table body rows from DOM and variable
    while (this.dom.bodyRows.length > 0) {
      const tr = this.dom.bodyRows.pop();
      this._removeRow(tr);
    }

    this.model.displayedData.forEach((dataElem, index) => {
      this._renderBodyRow(dataElem, index);
    });

    if (this.features['select']) {
      this.features['select'].update();
    }

    if (this.callbacks.createdBodyCallback) {
      this.callbacks.createdBodyCallback(this.dom.tbody, this.model.displayedData);
    }
  }

  /**
   * Render one <tr>.
   * @private
   * @param {Object} rowData
   */
  _renderBodyRow(rowData = {}) {
    const tr = document.createElement('tr');
    this.dom.tbody.append(tr);

    if (this.settings.expandable) {
      const td = document.createElement('td');
      const btn = document.createElement('button');
      const icon = document.createElement('i');
      btn.classList.add('expand', 'btn-icon');
      icon.classList.add('icon', 'icon-chevron-right');
      td.classList.add('cell-expand');
      btn.append(icon);
      td.append(btn);
      tr.append(td);
      tr.classList.add('main-row');

      const detailsTR = this._createDetailsRow(tr, rowData);
      detailsTR.classList.add('hidden');
      this.dom.tbody.append(detailsTR);
    }

    this.settings.columns.forEach((column) => {
      const td = document.createElement('td');

      if (column.cellClass) {
        td.classList.add(column.cellClass);
      }

      if (column.cellStyle) {
        td.style = column.cellStyle;
      }

      if (column.hidden) {
        td.classList.add('hidden');
      }

      if (column.freeze) {
        td.classList.add('freeze');
        td.style.left = '';
      }

      if (column.width) {
        td.style.width = column.width;
      }

      if (Array.isArray(rowData[column.key])) {
        td.classList.add('cell-split');

        rowData[column.key].forEach((item) => {
          const div = document.createElement('div');
          div.innerHTML = item;

          td.append(div);
        });
      } else {
        td.innerText = rowData[column.key] || '';
      }

      tr.append(td);

      if (column.onCreatedCell) {
        column.onCreatedCell(td, rowData[column.key]);
      }
    });

    if (this.settings.actions) {
      const td = document.createElement('td');
      td.classList.add('cell-actions');

      if (this.callbacks.onCreatedActionsCell) {
        this.callbacks.onCreatedActionsCell(td, rowData);
      }

      tr.append(td);

      if (this.settings.expandable) {
        const emptyTD = document.createElement('td');
        emptyTD.classList.add('cell-actions');
        tr.nextSibling.append(emptyTD);
      }
    }

    if (this.callbacks.createdRowCallback) {
      this.callbacks.createdRowCallback(tr, rowData);
    }

    tr.addEventListener('mouseover', this.listeners.onRowMouseOver);
    tr.addEventListener('mouseout', this.listeners.onRowMouseOut);

    this.dom.bodyRows.push(tr);
  }

  /**
   * Render tooltip in <th>.
   * @private
   */
  _renderTooltip(title, data) {
    const tooltipDOM = document.createElement('span');
    const tooltipMessage = document.createElement('span');

    tooltipDOM.classList.add('tooltip', 'dotted');
    tooltipMessage.classList.add('message', data.position || 'bottom');

    tooltipDOM.innerText = title;
    tooltipMessage.innerText = data.text;

    if (data.width) {
      tooltipMessage.style.width = data.width;
    }

    tooltipDOM.append(tooltipMessage);

    return tooltipDOM;
  }

  /**
   * Render table.
   * @private
   */
  _addFeatures() {
    // Table Info
    if (this.dom.tableTop && this.dom.tableTop.querySelector('.table-info')) {
      this.dom.tableInfo = this.dom.tableTop.querySelector('.table-info');
      this.features['info'] = new TableInfo(this);
      this.features['info'].init();

      this.features['info'].updateNumTotal();
      this.features['info'].updateNumShow();
    }

    // Selectable rows
    if (this.settings.selectable === 'multi' || this.settings.selectable === 'single') {
      this.features['select'] = new TableSelect(this);
      this.features['select'].init(this.settings.selectable);
    }

    // Sortable table
    if (this.settings.sortable) {
      this.dom.table.classList.add('sortable');
      this.features['sort'] = new TableSort(this);
      this.features['sort'].init();
    }

    // Table settings
    if (this.dom.tableSettingsIcon) {
      this.features['settings'] = new TableSettings(this);
      this.features['settings'].init();
    }
  }

  /**
   * Enable pagination feature.
   * @private
   */
  _enablePagination() {
    if (this.dom.tablePagination) {
      this.pagination = new Pagination(this.dom.tablePagination);
      this.pagination.state.numPerPage = this.settings.rowsPerPage;
      this.pagination.state.numEntries = this.model.data.length;

      const initNum = this.dom.tablePagination.querySelector('.actions .select') ? this.pagination.state.numEntries :
        Math.ceil(this.pagination.state.numEntries/this.pagination.state.numPerPage);
      this.pagination.init(initNum);
    }

    this.model.setDisplayedData();
  }

  /**
   * Enable sticky head and vertical scroll.
   * CSS solution with workaround for IE.
   * https://stackoverflow.com/questions/21168521/table-fixed-header-and-scrollable-body
   * @private
   */
  _enableStickyHead() {
    if (this.settings.height) {
      this.dom.table.parentElement.style.height = this.settings.height;
      this.dom.table.parentElement.classList.add('sticky');

      // https://stackoverflow.com/questions/19999388/check-if-user-is-using-ie
      const ua = window.navigator.userAgent;
      const isIE = RegExp(/MSIE|Trident/).test(ua);
      if (isIE) {
        this.dom.table.parentElement.addEventListener('scroll', this.listeners.onScroll);
      }
    }
  }

  /**
   * Create details row for expandable row.
   * @private
   */
  _createDetailsRow(tr, rowData) {
    const detailsTR = document.createElement('tr');
    const detailsTD = document.createElement('td');
    const emptyTd = document.createElement('td');
    detailsTR.classList.add('details-row');
    detailsTD.classList.add('cell-details');
    emptyTd.classList.add('cell-expand');

    detailsTD.setAttribute('colspan', this.settings.columns.filter((col) => !col.hidden).length);

    if (this.callbacks.createdDetailsRowCallback) {
      this.callbacks.createdDetailsRowCallback(detailsTD, rowData);
    }

    detailsTR.append(emptyTd);
    detailsTR.append(detailsTD);

    return detailsTR;
  }

  /**
   * Toggle details row for expandable row.
   * @private
   */
  _toggleDetailsRow(tr) {
    if (tr.nextSibling && tr.nextSibling.classList.contains('details-row')) {
      tr.nextSibling.classList.toggle('hidden');
      tr.classList.toggle('expanded');

      tr.querySelector('.expand .icon').classList.toggle('icon-chevron-right');
      tr.querySelector('.expand .icon').classList.toggle('icon-chevron-down');
    }
  }

  /**
   * Hide details row for expandable row.
   * @private
   */
  _hideDetailsRow(tr) {
    if (tr.nextSibling && tr.nextSibling.classList.contains('details-row')) {
      tr.nextSibling.classList.add('hidden');
      tr.classList.remove('expanded');

      tr.querySelector('.expand .icon').classList.add('icon-chevron-right');
      tr.querySelector('.expand .icon').classList.remove('icon-chevron-down');
    }
  }

  /**
   * Fix table head on top position.
   * Workaround for IE
   * @private
   * @param {Event} evt
   */
  _fixTableHead (evt) {
    const el = evt.target;
    const sT = el.scrollTop;
    el.querySelectorAll('thead th').forEach(th =>
      th.style.transform = `translateY(${sT}px)`
    );
  }

  /**
   * Create dropdown for actions button.
   * The Priority+ Navigation Pattern: show as many items
   * as will fit horizontally with a UI toggle to show the rest
   * @private
   */
  _createActionsDropdown() {
    if (!this.dom.tableButtons) {
      return;
    }

    const actionButtons = this.dom.tableButtons.querySelectorAll('button');

    const dropdownMarkup = `
      <div class="dropdown more" data-type="click">
        <button class="btn clickable"><i class="icon icon-more"></i></button>
        <div class="menu right">
           ${Array.from(actionButtons).map((btn) => `<div class="item">${btn.innerText}</div>`).join('')}
        </div>
      </div>`;

    const dropdownDOM = createFromMarkup(dropdownMarkup);
    this.dom.tableButtons.append(dropdownDOM);

    const dropdown = new Dropdown(dropdownDOM);
    dropdown.init();

    // By clicking on dropdown item trigger click on corresponding button
    Array.from(dropdownDOM.querySelectorAll('.item')).forEach((item, i) => {
      item.addEventListener('click', () => actionButtons[i].click());
    });

    this._onResize();
  }

  /**
   * On window resize callback.
   * Calculate available width and trigger buttons wrapping.
   * @private
   */
  _onResize() {
    const wrapWidth = parseFloat(getComputedStyle(this.dom.tableTop).width, 10);
    const topLeftWidth = this.dom.tableTop.querySelector('.table-top-left') ?
      parseFloat(getComputedStyle(this.dom.tableTop.querySelector('.table-top-left')).width, 10) : 0;
    const tableActionsWidth = this.dom.tableTop.querySelector('.table-actions') ?
      parseFloat(getComputedStyle(this.dom.tableTop.querySelector('.table-actions')).width, 10) : 0;
    const fixedWidth = topLeftWidth + tableActionsWidth + 32;
    const availableWidth = Math.floor(wrapWidth - fixedWidth);

    this._wrapActionButtons(availableWidth);
  }

  /**
   * Wrap action buttons that do not fit.
   * Solution https://stackoverflow.com/questions/31849831/hide-menu-items-one-by-one-on-window-resize
   * @private
   * @param {Number} availableWidth
   */
  _wrapActionButtons(availableWidth) {
    let widthSoFar = 0;

    const actionButtons = Array.from(this.dom.tableButtons.querySelectorAll(':scope > .btn'));

    const dropdown = this.dom.tableButtons.querySelector('.dropdown.more');
    const items = Array.from(dropdown.querySelectorAll('.menu .item'));

    actionButtons.forEach((btn, i) => {
      let btnWidth;

      if (btn.classList.contains('hidden')) {
        // Need to do this trick because elements width display none don't have width
        btn.classList.remove('hidden');
        btnWidth = parseFloat(getComputedStyle(btn).width)  + parseFloat(getComputedStyle(btn).marginLeft);
        btn.classList.add('hidden');
      } else {
        btnWidth = parseFloat(getComputedStyle(btn).width)  + parseFloat(getComputedStyle(btn).marginLeft);
      }

      // Check for buttons with inline styles 'display: none'
      if (isNaN(btnWidth)) {
        btnWidth = 0;
      }


      /*
       * If the menu width has already exceeded the available space,
       * or if this menu item will cause it to exceed the space
       */
      if( widthSoFar > availableWidth || (widthSoFar + btnWidth > availableWidth) ) {
        // Start hiding the menu items
        btn.classList.add('hidden');
        items[i].classList.remove('hidden');
      } else {
        // Otherwise, show the menu item, and update the width count
        btn.classList.remove('hidden');
        items[i].classList.add('hidden');
        widthSoFar += btnWidth;
      }
    });

    // Hide dropdown if all buttons are visible
    dropdown.style.display = actionButtons.every((btn) => !btn.classList.contains('hidden')) ? 'none' : '';

  }

  /**
   * Update data and redraw table.
   * @public
   */
  update(newData) {
    this.model.setData(newData);
    this.dom.table.dispatchEvent(new CustomEvent('tableUpdate'));

    if (this.pagination) {
      this.pagination.update(this.model.data.length);
    }

    this.updateRows();
  }

  /**
   * Update rows with new data (on sorting, pagination, etc).
   * Used this instead of destroy all rows and render again for better performance.
   * @public
   */
  updateRows() {
    const ths = Array.from(this.dom.thead.querySelectorAll('tr th'));

    // Remove extra rows
    while (this.dom.bodyRows.length > this.model.displayedData.length) {
      const tr = this.dom.bodyRows.pop();
      this._removeRow(tr);
    }

    this.model.displayedData.forEach((data, index) => {
      const row = this.dom.bodyRows[index];
      // Add missing rows
      if (!row) {
        this._renderBodyRow(data);
      } else {
        this._hideDetailsRow(row);
        const tds = row.querySelectorAll('td');
        const selectTd = row.querySelector('td.cell-select');
        if (selectTd) {
          selectTd.querySelector('input').checked = data.selected;
          row.classList.toggle('selected', data.selected);
        }

        this.settings.columns.forEach((column) => {
          if (column.key) {
            const columnIndex = ths.findIndex((th) => th.dataset.key === column.key);
            const td = tds[columnIndex];

            if (Array.isArray(data[column.key])) {
              // Just re-render cell content as old data length and new data length can be different
              td.innerHTML = '';
              data[column.key].forEach((item) => {
                const div = document.createElement('div');
                div.innerHTML = item;
                td.append(div);
              });
            } else {
              td.classList.remove('cell-split');
              td.innerText = data[column.key] || '';
            }

            // Using !! in front of an expression coerces the value to a boolean
            td.classList.toggle('hidden', !!column.hidden);
            td.classList.toggle('freeze', !!column.freeze);
            td.style.left = '';

            if (column.onCreatedCell) {
              column.onCreatedCell(td, data[column.key]);
            }
          }
        });

        if (this.settings.expandable) {
          row.nextSibling.querySelector('td.cell-details').setAttribute('colspan',
            this.settings.columns.filter((col) => !col.hidden).length);
        }

        if (this.callbacks.createdDetailsRowCallback) {
          this.callbacks.createdDetailsRowCallback(row.nextSibling.querySelector('td.cell-details'), data);
        }
      }
    });

    // Add missing inputs and update master checkbox
    if (this.features['select']) {
      this.features['select'].update();
    }

    this._toggleFreeze();
    this._toggleEmptyState();
  }

  /**
   * Update columns.
   * @public
   * @param {Object} newColumns
   */
  updateColumns(newColumns) {
    if (newColumns) {
      this.settings.columns = newColumns;

      this.dom.thead.querySelectorAll('th[data-key]').forEach((th, i) => {
        const column = this.settings.columns[i];

        th.removeAttribute('class');
        th.removeAttribute('style');

        if (column.key) {
          th.dataset.key = column.key;
        }

        if (column.headerClass) {
          th.classList.add(column.headerClass);
        }

        if (column.headerStyle) {
          th.style = column.headerStyle;
        }

        if (column.width) {
          th.style.width = column.width;
        }

        if (column.hidden) {
          th.classList.add('hidden');
        }

        if (column.freeze) {
          th.classList.add('freeze');
          th.style.left = '';
        }

        if (column.title && column.tooltip) {
          th.innerHTML = '';
          th.append(this._renderTooltip(column.title, column.tooltip));
        } else {
          th.innerHTML = column.title || '';
        }
      });

      this._renderBodyRows();
      this._toggleFreeze();
    }
  }

  /**
   * Delete data and corresponding row.
   * @public
   */
  delete(toDelete) {
    if (toDelete instanceof HTMLElement) {
      // Remove from data by index
      this.model.deleteByIndex(this.getIndexByRow(toDelete));
      // Remove row
      this._deleteRow(toDelete);
    } else {
      const dataIndex = this.model.data.indexOf(toDelete);
      const trIndex = this.model.displayedData.indexOf(toDelete);

      // Remove from data by index
      this.model.deleteByIndex(dataIndex);

      // If we are on the page with this row, remove it too
      if (trIndex > -1) {
        this._deleteRow(this.dom.bodyRows[trIndex]);
      }
    }

    if (this.pagination) {
      this.pagination.update(this.model.data.length);
      this.model.setDisplayedData();
      this.updateRows();
    } else {
      this._toggleEmptyState();
    }

    this.dom.table.dispatchEvent(new CustomEvent('tableUpdate'));
  }

  /**
   * Remove row from DOM and refresh.
   * @public
   */
  _deleteRow(tr) {
    this.dom.bodyRows.splice(this.dom.bodyRows.indexOf(tr), 1);
    this._removeRow(tr);
  }

  /**
   * Remove row from DOM and it's details row.
   * @public
   */
  _removeRow(tr) {
    if (tr.nextSibling && tr.nextSibling.classList.contains('details-row')) {
      tr.nextSibling.remove();
    }
    tr.remove();
    this.dom.table.dispatchEvent(new CustomEvent('removeRow', {detail: tr}));
  }

  /**
   * Add new data and create row.
   * @public
   * @param {HTMLElement} newData
   */
  add(newData) {
    // add data to model
    this.model.addData(newData);
    this.dom.table.dispatchEvent(new CustomEvent('tableUpdate'));

    // update pagination
    if (this.pagination) {
      this.pagination.update(this.model.data.length);
    }

    this.updateRows();

  }

  /**
   * Get index of data item by <tr> element.
   * @public
   * @param {HTMLElement} tr
   */
  getIndexByRow(tr) {
    let index = Array.from(this.dom.bodyRows).indexOf(tr);

    if (this.pagination) {
      index = (this.pagination.state.currentPage - 1) * this.pagination.state.numPerPage + index;
    }

    return index;
  }

  _toggleEmptyState() {
    // remove empty state
    if (this.model.displayedData.length && this.dom.table.querySelector('.no-data-row')) {
      this.dom.table.style.height = '';
      this.dom.table.querySelector('.no-data-row').remove();
      if (this.dom.tablePagination && this.dom.tablePagination.querySelector('.actions')) {
        this.dom.tablePagination.querySelector('input').disabled = false;
        this.dom.tablePagination.querySelector('.select').classList.remove('disabled');
      }
    }

    // add empty state
    if (!this.model.displayedData.length && !this.dom.table.querySelector('.no-data-row')) {
      this.dom.table.style.height = '100%';
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      tr.classList.add('no-data-row');
      td.colSpan = this.dom.thead.querySelectorAll('th').length;
      td.innerText = this.settings.emptyState.message;
      tr.append(td);
      this.dom.tbody.append(tr);
      if (this.dom.tablePagination && this.dom.tablePagination.querySelector('.actions')) {
        this.dom.tablePagination.querySelector('input').disabled = true;
        this.dom.tablePagination.querySelector('.select').classList.add('disabled');
      }
    }
  }

  _toggleFreeze() {
    const isFrozen = this.settings.columns.some((col) => col.freeze);

    this.dom.table.querySelectorAll('tr .freeze').forEach(cell => {
      cell.style.left = isFrozen ? `${cell.offsetLeft}px` : '';
    });

    this.dom.table.querySelectorAll('tr:not(.details-row) .cell-expand').forEach(cell => {
      cell.classList.toggle('freeze', !!isFrozen);
      cell.style.left = isFrozen ? `${cell.offsetLeft}px` : '';
    });

    this.dom.table.querySelectorAll('tr:not(.details-row) .cell-select').forEach(cell => {
      cell.classList.toggle('freeze', !!isFrozen);
      cell.style.left = isFrozen ? `${cell.offsetLeft}px` : '';
    });
  }
}
