/**
 * @file Module to describe model of table's data.
 */

/**
 * Class representing data model.
 */
export default class TableModel {
  constructor(table, data) {
    this.component = table;
    this.setData(data);
  }

  setData(data = []) {
    this.initialData = data;
    this.data = this._processData(this.initialData);
    this.setDisplayedData();
  }

  addData(newData) {
    if (newData) {
      this.data.push({...newData, selected: newData.selected || false, indexOriginal: this.data.length});
    }
  }

  deleteByIndex(index) {
    this.data.splice(index, 1);
    this.setDisplayedData();
  }

  selectByIndex(index) {
    this.data[index].selected = true;
  }

  deselectByIndex(index) {
    this.data[index].selected = false;
  }

  selectAll() {
    this.data.forEach((item) => item.selected = true);
  }

  deselectAll() {
    this.data.forEach((item) => item.selected = false);
  }

  sort(key, direction = 'asc') {
    // Reset sort to make sure previous sorting does not affect new order
    this.resetSort();

    if (direction === 'asc') {
      this._sortAsc(key);
    }

    if  (direction === 'desc') {
      this._sortDesc(key);
    }
  }

  _processData(data) {
    return data.map((d, i) => ({...d, selected: d.selected || false, indexOriginal: i}));
  }

  /**
   * Subtract data to display.
   * Example. Rows per page: 10
   * 1: [0, 10) 2: [10, 20) 3: [20, 30)...
   */
  setDisplayedData() {
    if (this.component.pagination) {
      const rowsPerPage = this.component.pagination.state.numPerPage;
      const currentPage = this.component.pagination.state.currentPage;
      // "start" included, "end" not included.
      const start = rowsPerPage * (currentPage - 1);
      const end = rowsPerPage * currentPage;

      this.displayedData = this.data.slice(start, end);
    } else {
      this.displayedData = this.data;
    }
  }

  _sortAsc(key) {
    this.data.sort((a, b) => {
      if (a[key] < b[key]) {
        return -1;
      }

      if (a[key] > b[key]) {
        return 1;
      }

      return 0;
    });
  }

  _sortDesc(key) {
    this.data.sort((a, b) => {
      if (a[key] < b[key]) {
        return 1;
      }

      if (a[key] > b[key]) {
        return -1;
      }

      return 0;
    });
  }

  resetSort() {
    // this.data = [...this.initialData];
    this.data.sort((a, b) => a.indexOriginal - b.indexOriginal);
  }
}
