/**
 * @file Module to describe Table Sort feature.
 */

/**
 * Class representing Table Sort feature.
 */
export default class TableSort {
  constructor(table) {
    this.component = table;
    this.dom = this.component.dom;
    this.sortable = this.component.sortable;
    this.sortBy = [];

    this.listeners = {
      onTheadClick: (evt) => {
        if (evt.target.classList.contains('is-sortable')) {
          const clickedTh = evt.target;

          /*
           * Sorting only by single columns for now. In future should implement multi column sorting.
           * To insure backward compatibility `sortable: true` and `sortable: 'single'` should be the same.
           */
          this.sortBy = [{key: clickedTh.dataset.key, dir: this._getSortDirection(clickedTh)}];
          this.sort();
        }
      },
      onTableUpdate: () => this.sort()
    };
  }

  init() {
    this.enable();
    this._addEventListeners();
  }

  destroy() {
    this._removeEventListeners();
  }

  _addEventListeners() {
    this.component.dom.thead.addEventListener('click', this.listeners.onTheadClick);
    this.dom.table.addEventListener('tableUpdate', this.listeners.onTableUpdate);
  }

  _removeEventListeners() {
    this.component.dom.thead.removeEventListener('click', this.listeners.onTheadClick);
    this.dom.table.removeEventListener('tableUpdate', this.listeners.onTableUpdate);
  }

  enable() {
    this.component.settings.columns.forEach((column) => {
      if (column.key && column.sort) {
        const th = this.dom.thead.querySelector(`th[data-key=${column.key}]`);
        th.classList.add('is-sortable');
        if (column.sort !== 'none') {
          th.classList.add(column.sort);
          this.sortBy = [{key: th.dataset.key, dir: column.sort}];
          this.sort();
        }
      }
    });
  }

  _getSortDirection(th) {
    switch(true) {
      case th.classList.contains('asc'):
        return 'desc';

      case th.classList.contains('desc'):
        // Use `return 'none';` here if you want to change order to: Asc -> Desc -> No sorting -> Asc -> etc.
        return 'asc';

      default:
        th.classList.add('asc');
        return 'asc';
    }
  }

  _singleSort(sortKey, sortDir) {
    Array.from(this.dom.thead.querySelectorAll('th.is-sortable')).forEach((th) => {
      if (th.dataset.key === sortKey) {
        switch(sortDir) {
          case 'asc':
            th.classList.remove('desc');
            th.classList.add('asc');
            this.component.model.sort(sortKey, sortDir);
            break;

          case 'desc':
            th.classList.remove('asc');
            th.classList.add('desc');
            this.component.model.sort(sortKey, sortDir);
            break;

          case 'none':
            th.classList.remove('asc');
            th.classList.remove('desc');
            this.component.model.resetSort();
            break;
        }
      } else {
        // Remove sorting for all other columns
        th.classList.remove('asc');
        th.classList.remove('desc');
      }
    });

    this.component.model.setDisplayedData();
    this.component.updateRows();
  }

  _multiSort() {

  }

  sort() {
    if (this.sortBy.length) {
      this._singleSort(this.sortBy[0].key, this.sortBy[0].dir);
    }
  }

}
