/**
 * @file Module to create Gauge chart.
 */

import * as d3 from 'd3';

/**
 * Class representing a gauge chart.
 */
export class Gauge {

  /**
   * Setup properties.
   * @param {HTMLElement} element - The DOM element to append the chart.
   */
  constructor(element) {
    this.dom = {
      gauge: element,
      settings: element.dataset.settings,
      valueArc: undefined,
      valueLabel: undefined,
    };
    this.data = null;
  }

  /**
   * Initialize the chart.
   * @public
   */
  init() {
    this.data = this._parseData();
    this._setDataDefaults();
    this._drawChart();
    this._injectTexture();
    // this.setRandomData();
  }

  /**
   * Create chart canvas.
   * @private
   * @param {HTMLElement} element - Element to create svg.
   * @param {number} scale - Scale (size of chart).
   * @return {Object} - d3 Selection
   */
  _setCanvas(element, scale) {
    return d3.select(element)
      .append('svg')
      .attr('width', 250 * scale)
      .attr('height', 250 * scale)
      .append('g')
      .attr('transform', 'translate(' + 125 * scale + ', ' + 125 * scale + ')');

  }

  /**
   * Add texture to arch.
   * @private
   */
  _injectTexture() {
    const dTexture = window.document.querySelector('#diagonalTexture');
    if (dTexture === undefined) {
      d3.select('body')
        .append('svg')
        .append('defs')
        .append('pattern')
        .attr('id', 'diagonalTexture')
        .attr('width', 5)
        .attr('height', 5)
        .attr('patternUnits', 'userSpaceOnUse')
        .append('path')
        .attr('fill', 'white')
        .attr('stroke', '#767676')
        .attr('stroke-width', '1')
        .attr('d', 'M0 5L5 0ZM6 4L4 6ZM-1 1L1 -1Z');
    }
  }

  /**
   * Return numeric value for size of chart.
   * @private
   * @param {string} size - Chart size, 'small', 'medium' or 'large'.
   * @return {number} - Chart scale.
   */
  _getScale(size) {
    switch (size) {
      case 'small':
        return .5;
      case 'medium':
        return .75;
      case 'large':
        return 1;
      default:
        return .75;
    }
  }

  /**
   * Return function to create d3 arc.
   * @private
   * @param {Object} options
   * @param {number} options.scale
   * @param {number} options.radius.inner
   * @param {number} options.radius.outer
   * @param {number} options.angle.start
   * @param {number} options.angle.end
   * @return {Function}
   */
  _createArc(options) {
    const s = options.scale || .75;
    return d3.arc()
      .innerRadius(options.radius.inner * s)
      .outerRadius(options.radius.outer * s)
      .startAngle(options.angle.start * (Math.PI / 180))
      .endAngle(options.angle.end * (Math.PI / 180));
  }

  /**
   * Draw arc.
   * @private
   * @param {Object} canvas - Element to append the arc (d3 Selection)
   * @param {Object} options - Arc options.
   * @param {number} options.arc.radius.inner
   * @param {number} options.arc.radius.outer
   * @param {number} options.arc.angle.start
   * @param {number} options.arc.angle.end
   * @param {number} options.arc.scale
   * @param {string} options.props.class - CSS class.
   * @return {Object} - Arc element (d3 Selection).
   */
  _drawArc(canvas, options) {
    const createArc = this._createArc;
    return canvas.append('path')
      .attr('class', options.props.class || 'arc')
      .attr('d', createArc(options.arc))
      .attr('fill', options.props.color)
      .attr('opacity', options.props.opacity || 1);
  }

  /**
   * Draw label.
   * @private
   * @param {Object} canvas - Element to append the label (d3 Selection).
   * @param {Object} options - Label options.
   * @param {string} options.message - Label text.
   * @param {string} options.class - CSS class.
   * @param {number} options.x - x position.
   * @param {number} options.y - y position.
   * @param {number} options.fontSize - Font size.
   * @param {number} options.scale
   * @return {Object} - Label element (d3 Selection).
   */
  _drawLabel(canvas, options) {
    return canvas.append('g')
      .attr('transform', 'translate(' +
        (options.x * options.scale || 0) + ',' +
        (options.y * options.scale || 0) + ')')
      .append('text')
      .text(options.message)
      .style('font-size', (options.fontSize * options.scale) + 'px')
      .attr('class', options.class || 'text');
  }

  /**
   * Converts chart settings from string format to Object.
   * @private
   * @return {Object} - Converted settings.
   */
  _parseData() {
    return JSON.parse(this.dom.settings);
  }

  /**
   * Sets default chart data.
   * @private
   */
  _setDataDefaults() {
    this.data.value = this.data.value || 0;
    this.data.min = this.data.min || 0;
    this.data.max = this.data.max || 100;
    this.data.units = this.data.units || '%';
    this.data.scale = this._getScale(this.data.size) || .75;
  }

  /**
   * Update chart value.
   * @public
   * @param {number | string} value - New value.
   */
  setValue(value) {
    const _parentThis = this;
    const valueArc = this.dom.valueArc;
    const prevAngle = this._valueToAngle(this.data.value);
    const newAngle = this._valueToAngle(value);
    valueArc
      .transition()
      .duration(750)
      .attrTween('d', this._arcTween(newAngle, prevAngle, _parentThis));
    this.data.value = this._angleToValue(newAngle);
  }

  /**
   * @deprecated
   */
  setRandomData() {
    const _parentThis = this;
    d3.interval(() => {
      const randomAngle = Math.random() * 270 - 135;
      const randomValue = _parentThis._angleToValue(randomAngle, _parentThis);
      _parentThis.setValue(randomValue);
    }, 1500);
  }

  /**
   * Convert value of units to angle.
   * @private
   * @param {number} value
   * @return {number}
   */
  _valueToAngle(value) {
    const scale =
      d3.scaleLinear()
        .domain([this.data.min, this.data.max])
        .range([-135, 135]);
    return scale(value);
  }

  /**
   * Convert angle to value of units.
   * @private
   * @param {number} angle
   * @param {Gauge} _parentThis
   * @return {number}
   */
  _angleToValue(angle, _parentThis) {
    const _this = _parentThis !== undefined ? _parentThis : this;
    const scale =
      d3.scaleLinear()
        .domain([-135, 135])
        .range([_this.data.min, _this.data.max]);
    return scale(angle);
  }

  /**
   * Animate changing of value text.
   * @private
   * @param {number} angle
   * @param {Gauge} _parentThis
   */
  _setLabelAngle(angle, _parentThis) {
    const valueLabel = _parentThis.dom.valueLabel;
    const decimals = _parentThis._parseData().decimals;
    valueLabel.text(() => _parentThis._angleToValue(angle, _parentThis).toFixed(decimals));
  }

  /**
   * Custom tween function used by the attrTween method to draw the intermediary steps.
   * @private
   * @param {number} newAngle
   * @param {number} oldAngle
   * @param {Gauge} _parentThis
   * @return {Function}
   */
  _arcTween(newAngle, oldAngle, _parentThis) {
    const { _setArcColor: setArcColor, _setLabelAngle: setLabelAngle, _angleToValue: angleToValue, data } = _parentThis;
    return () => {
      const interpolate = d3.interpolate(oldAngle, newAngle);
      return (t) => {
        oldAngle = interpolate(t);
        const arc = this._createArc({
          angle: { start: -135, end: oldAngle },
          radius: { inner: 95, outer: 102 },
          scale: data.scale,
        });
        setLabelAngle(oldAngle, _parentThis);
        const decimals = data.decimals || 0;
        const val = angleToValue(oldAngle, _parentThis);
        setArcColor(parseFloat(val).toFixed(decimals), data.limits, _parentThis);
        return arc(t);
      };
    };
  }

  /**
   * Set arc color depending on limits.
   * @private
   * @param {number | string} value
   * @param {Object} limits
   * @param {number} limits.from
   * @param {number} limits.to
   * @param {string} limits.color
   * @param {string} limits.label
   * @param {Gauge} _parentThis
   */
  _setArcColor(value, limits, _parentThis) {
    const d = _parentThis !== undefined ? _parentThis.dom : this.dom;
    d.valueArc.attr('class', 'valueArc');
    if (limits) {
      Array.from(limits).forEach(limit => {
        if (value >= limit.from && value <= limit.to) {
          if (limit.color !== 'transparent'
            && limit.color !== 'unknown'
            && limit.color !== 'gray') {
            d.valueArc.attr('class', limit.color);
          }
        }
      });
    }
  }

  /**
   * Draw the chart based on data.
   * @private
   */
  _drawChart() {
    // variables
    const gScale = this.data.scale;

    //  set canvas
    const svg = this._setCanvas(this.dom.gauge, gScale);

    // foreground arc
    this._drawArc(svg, {
      arc: {
        radius: { inner: 95, outer: 102 },
        angle: { start: -135, end: 135 },
        scale: gScale,
      },
      props: {
        class: 'foregroundArc',
      },
    });

    // value arc
    this.dom.valueArc = this._drawArc(svg, {
      arc: {
        radius: { inner: 95, outer: 102 },
        angle: { start: -135, end: this._valueToAngle(this.data.value) },
        scale: gScale,
      },
      props: {
        class: 'valueArc',
      },
    });

    // set value arc color
    this._setArcColor(this.data.value, this.data.limits);

    // negative arcs
    const frequency = 275 / 37; const length = 5;
    for (let i = -140; i < 135; i = i + frequency) {
      this._drawArc(svg, {
        arc: {
          radius: { inner: 94, outer: 103 },
          angle: { start: i, end: i + length },
          scale: gScale,
        },
        props: {
          class: 'negativeArc',
        },
      });
    }

    // draw limits
    if (this.data.limits) {
      Array.from(this.data.limits).forEach(limit => {
        const limitArc = this._drawArc(svg, {
          arc: {
            radius: { inner: 82, outer: 87 },
            angle: {
              start: this._valueToAngle(limit.from) + 1,
              end: this._valueToAngle(limit.to) - 1,
            },
            scale: gScale,
          },
          props: {
            class: limit.color,
            opacity: 0.3,
          },
        });

        // limit hover arc
        const limitHoverArc = this._drawArc(svg, {
          arc: {
            radius: { inner: 72, outer: 117 },
            angle: {
              start: this._valueToAngle(limit.from) + 1,
              end: this._valueToAngle(limit.to) - 1,
            },
            scale: gScale,
          },
          props: {
            class: 'transparent',
          },
        });

        // tooltip
        const tooltip =
          d3.select(this.dom.gauge)
            .append('div')
            .attr('class', 'tooltip hidden')
            .style('left', '0px')
            .style('top', '0px')
            .html(limit.label);

        // animation
        limitHoverArc.on('mouseenter', () => {
          tooltip.node().classList.remove('hidden');
          limitArc.style('opacity', 1);
        });
        limitHoverArc.on('mousemove', () => {
          tooltip.style('left', d3.event.clientX + 'px').style('top', d3.event.clientY - 40 + 'px');
        });
        limitHoverArc.on('mouseleave', () => {
          tooltip.node().classList.add('hidden');
          limitArc.style('opacity', 0.3);
        });
      });
    }

    // labels
    this._drawLabel(svg, {
      message: this.data.units,
      class: 'units',
      x: 0,
      y: 40,
      fontSize: 28,
      scale: gScale,
    });

    this._drawLabel(svg, {
      message: this.data.min,
      class: 'label left',
      x: -65,
      y: 110,
      fontSize: 24,
      scale: gScale,
    });

    this._drawLabel(svg, {
      message: this.data.max,
      class: 'label right',
      x: 65,
      y: 110,
      fontSize: 24,
      scale: gScale,
    });

    this.dom.valueLabel = this._drawLabel(svg, {
      message: this.data.value,
      class: 'total',
      fontSize: 60,
      scale: gScale,
    });
  }

  /**
   * Destroy component.
   * @public
   */
  destroy() {

  }
}
